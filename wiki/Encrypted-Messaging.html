<p>One of the benefits of adopting a message-based design is being able to easily layer functionality and generically add value to all Services, we've seen this recently with <a href="https://github.com/ServiceStack/ServiceStack/wiki/Auto-Batched-Requests">Auto Batched Requests</a> which automatically enables each Service to be batched and executed in a single HTTP Request. Similarly the new Encrypted Messaging feature 
enables a secure channel for all Services (inc Auto Batched Requests :) offering protection to clients who can now easily send and receive encrypted messages over unsecured HTTP!</p>

<h3>
<a id="user-content-encrypted-messaging-overview" class="anchor" href="#encrypted-messaging-overview" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Encrypted Messaging Overview</h3>

<p><a href="https://raw.githubusercontent.com/ServiceStack/Assets/master/img/release-notes/encrypted-messaging.png" target="_blank"><img src="https://raw.githubusercontent.com/ServiceStack/Assets/master/img/release-notes/encrypted-messaging.png" alt="" style="max-width:100%;"></a></p>

<h3>
<a id="user-content-configuration" class="anchor" href="#configuration" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Configuration</h3>

<p>Encrypted Messaging support is enabled by registering the plugin:</p>

<div class="highlight highlight-source-cs"><pre>Plugins.Add(<span class="pl-k">new</span> EncryptedMessagesFeature {
    PrivateKeyXml = ServerRsaPrivateKeyXml
});</pre></div>

<p>Where <code>PrivateKeyXml</code> is the Servers RSA Private Key Serialized as XML. </p>

<h3>
<a id="user-content-generate-a-new-private-key" class="anchor" href="#generate-a-new-private-key" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Generate a new Private Key</h3>

<p>If you don't have an existing one, a new one can be generated with:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> rsaKeyPair = RsaUtils.CreatePublicAndPrivateKeyPair();
<span class="pl-k">string</span> ServerRsaPrivateKeyXml = rsaKeyPair.PrivateKey;</pre></div>

<p>Once generated, it's important the Private Key is kept confidential as anyone with access will be able to decrypt 
the encrypted messages! Whilst most <a href="http://stackoverflow.com/a/6018247/85785">obfuscation efforts are ultimately futile</a> the goal should be to contain the private key to your running Web Application, limiting access as much as possible.</p>

<p>Once registered, the EncryptedMessagesFeature enables the 2 Services below:</p>

<ul>
<li>
<code>GetPublicKey</code> - Returns the Serialized XML of your Public Key (extracted from the configured Private Key)</li>
<li>
<code>EncryptedMessage</code> - The Request DTO which encapsulates all encrypted Requests (can't be called directly)</li>
</ul>

<h3>
<a id="user-content-giving-clients-the-public-key" class="anchor" href="#giving-clients-the-public-key" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Giving Clients the Public Key</h3>

<p>To communicate clients need access to the Server's Public Key, it doesn't matter who has accessed the Public Key only that clients use the <strong>real</strong> Servers Public Key. It's therefore not advisable to download the Public Key over unsecure <code>http://</code> where traffic can potentially be intercepted and the key spoofed, subjecting them to a <a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">Man-in-the-middle attack</a>. </p>

<p>It's safer instead to download the public key over a trusted <code>https://</code> url where the servers origin is verified by a trusted <a href="https://en.wikipedia.org/wiki/Certificate_authority">CA</a>. Sharing the Public Key over Dropbox, Google Drive, OneDrive or other encrypted channels are also good options.</p>

<p>Since <code>GetPublicKey</code> is just a ServiceStack Service it's easily downloadable using a Service Client:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> client = <span class="pl-k">new</span> JsonServiceClient(BaseUrl);
<span class="pl-k">string</span> publicKeyXml = client.Get(<span class="pl-k">new</span> GetPublicKey());</pre></div>

<p>If the registered <code>EncryptedMessagesFeature.PublicKeyPath</code> has been changed from its default <code>/publickey</code>, it can be dowloaded with:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">string</span> publicKeyXml = client.Get&lt;<span class="pl-k">string</span>&gt;(<span class="pl-s"><span class="pl-pds">"</span>/my-publickey<span class="pl-pds">"</span></span>); <span class="pl-c">//or with HttpUtils</span>
<span class="pl-k">string</span> publicKeyXml = BaseUrl.CombineWith(<span class="pl-s"><span class="pl-pds">"</span>/my-publickey<span class="pl-pds">"</span></span>).GetStringFromUrl();</pre></div>

<blockquote>
<p>To help with verification the SHA256 Hash of the PublicKey is returned in <code>X-PublicKey-Hash</code> HTTP Header</p>
</blockquote>

<h3>
<a id="user-content-encrypted-service-client" class="anchor" href="#encrypted-service-client" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Encrypted Service Client</h3>

<p>Once they have the Server's Public Key, clients can use it to get an <code>EncryptedServiceClient</code> via the <code>GetEncryptedClient()</code> extension method on <code>JsonServiceClient</code> or new <code>JsonHttpClient</code>, e.g:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> client = <span class="pl-k">new</span> JsonServiceClient(BaseUrl);
IEncryptedClient encryptedClient = client.GetEncryptedClient(publicKeyXml);</pre></div>

<p>Once configured, clients have access to the familiar typed Service Client API's and productive workflow they're used to with the generic Service Clients, sending typed Request DTO's and returning the typed Response DTO's - rendering the underlying encrypted messages a transparent implementation detail:</p>

<div class="highlight highlight-source-cs"><pre>HelloResponse response = encryptedClient.Send(<span class="pl-k">new</span> Hello { Name = <span class="pl-s"><span class="pl-pds">"</span>World<span class="pl-pds">"</span></span> });
response.Result.Print(); <span class="pl-c">//Hello, World!</span></pre></div>

<p>REST Services Example:</p>

<div class="highlight highlight-source-cs"><pre>HelloResponse response = encryptedClient.Get(<span class="pl-k">new</span> Hello { Name = <span class="pl-s"><span class="pl-pds">"</span>World<span class="pl-pds">"</span></span> });</pre></div>

<p>Auto-Batched Requests Example:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> requests = <span class="pl-k">new</span>[] { <span class="pl-s"><span class="pl-pds">"</span>Foo<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Bar<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Baz<span class="pl-pds">"</span></span> }.Map(x =&gt; 
    <span class="pl-k">new</span> HelloSecure { Name = x });
<span class="pl-k">var</span> responses = encryptedClient.SendAll(requests);</pre></div>

<p>When using the <code>IEncryptedClient</code>, the entire Request and Response bodies are encrypted including Exceptions which continue to throw a populated <code>WebServiceException</code>:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">try</span>
{
    <span class="pl-k">var</span> response = encryptedClient.Send(<span class="pl-k">new</span> Hello());
}
<span class="pl-k">catch</span> (WebServiceException ex)
{
    ex.ResponseStatus.ErrorCode.Print(); <span class="pl-c">//= ArgumentNullException</span>
    ex.ResponseStatus.Message.Print();   <span class="pl-c">//= Value cannot be null. </span>
}</pre></div>

<h3>
<a id="user-content-authentication-with-encrypted-messaging" class="anchor" href="#authentication-with-encrypted-messaging" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Authentication with Encrypted Messaging</h3>

<p>Many encrypted messaging solutions use Client Certificates which Servers can use to cryptographically verify a client's identity - providing an alternative to HTTP-based Authentication. We've decided against using this as it would've forced an opinionated implementation and increased burden of PKI certificate management and configuration onto Clients and Servers - reducing the applicability and instant utility of this feature.</p>

<p>We can instead leverage the existing Session-based Authentication Model in ServiceStack letting clients continue to use the existing Auth functionality and Auth Providers they're already used to, e.g:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> authResponse = encryptedClient.Send(<span class="pl-k">new</span> Authenticate {
    provider = CredentialsAuthProvider.Name,
    UserName = <span class="pl-s"><span class="pl-pds">"</span>test@gmail.com<span class="pl-pds">"</span></span>,
    Password = <span class="pl-s"><span class="pl-pds">"</span>p@55w0rd<span class="pl-pds">"</span></span>,
});</pre></div>

<p>Encrypted Messages have their cookies stripped so they're no longer visible in the clear which minimizes their exposure to Session hijacking. This does pose the problem of how we can call authenticated Services if the encrypted HTTP Client is no longer sending Session Cookies? </p>

<p>Without the use of clear-text Cookies or HTTP Headers there's no longer an <em>established Authenticated Session</em> for the <code>encryptedClient</code> to use to make subsequent Authenticated requests. What we can do  instead is pass the Session Id in the encrypted body for Request DTO's that implement the new <code>IHasSessionId</code> interface, e.g:</p>

<div class="highlight highlight-source-cs"><pre>[Authenticate]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">HelloAuthenticated</span> : <span class="pl-k">IReturn</span>&lt;<span class="pl-k">HelloAuthenticatedResponse</span>&gt;, 
    <span class="pl-k">IHasSessionId</span>
{
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">SessionId</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Name</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}

<span class="pl-k">var</span> response = encryptedClient.Send(<span class="pl-k">new</span> HelloAuthenticated {
    SessionId = authResponse.SessionId,
    Name = <span class="pl-s"><span class="pl-pds">"</span>World<span class="pl-pds">"</span></span>
});</pre></div>

<p>Here we're injecting the returned Authenticated <code>SessionId</code> to access the <code>[Authenticate]</code> protected Request DTO. However remembering to do this for every authenticated request can get tedious, a nicer alternative is just setting it once on the <code>encryptedClient</code> which will then use it to automatically populate any <code>IHasSessionId</code> Request DTO's:</p>

<div class="highlight highlight-source-cs"><pre>encryptedClient.SessionId = authResponse.SessionId;

<span class="pl-k">var</span> response = encryptedClient.Send(<span class="pl-k">new</span> HelloAuthenticated {
    Name = <span class="pl-s"><span class="pl-pds">"</span>World<span class="pl-pds">"</span></span>
});</pre></div>

<blockquote>
<p>Incidentally this feature is now supported in <strong>all Service Clients</strong></p>
</blockquote>

<h3>
<a id="user-content-combined-authentication-strategy" class="anchor" href="#combined-authentication-strategy" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Combined Authentication Strategy</h3>

<p>Another potential use-case is to only use Encrypted Messaging when sending any sensitive information and the normal Service Client for other requests. In which case we can Authenticate and send the user's password with the <code>encryptedClient</code>:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> authResponse = encryptedClient.Send(<span class="pl-k">new</span> Authenticate {
    provider = CredentialsAuthProvider.Name,
    UserName = <span class="pl-s"><span class="pl-pds">"</span>test@gmail.com<span class="pl-pds">"</span></span>,
    Password = <span class="pl-s"><span class="pl-pds">"</span>p@55w0rd<span class="pl-pds">"</span></span>,
});</pre></div>

<p>But then fallback to using the normal <code>IServiceClient</code> for subsequent requests. But as the <code>encryptedClient</code> doesn't receive cookies we'd need to set it explicitly on the client ourselves with:</p>

<div class="highlight highlight-source-cs"><pre>client.SetCookie(<span class="pl-s"><span class="pl-pds">"</span>ss-id<span class="pl-pds">"</span></span>, authResponse.SessionId);</pre></div>

<p>After which the ServiceClient "establishes an authenticated session" and can be used to make Authenticated requests, e.g:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> response = <span class="pl-k">await</span> client.GetAsync(<span class="pl-k">new</span> HelloAuthenticated { Name = <span class="pl-s"><span class="pl-pds">"</span>World<span class="pl-pds">"</span></span> });</pre></div>

<blockquote>
<p>Note: EncryptedServiceClient is unavailable in PCL Clients</p>
</blockquote>

<h3>
<a id="user-content-rsa-and-aes-hybrid-encryption-verified-with-hmac-sha-256" class="anchor" href="#rsa-and-aes-hybrid-encryption-verified-with-hmac-sha-256" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>RSA and AES Hybrid Encryption verified with HMAC SHA-256</h3>

<p>The Encrypted Messaging Feature follows a <a href="https://en.wikipedia.org/wiki/Hybrid_cryptosystem">Hybrid Cryptosystem</a> 
which uses RSA Public Keys for <a href="https://en.wikipedia.org/wiki/Public-key_cryptography">Asymmetric Encryption</a> 
combined with the performance of AES <a href="https://en.wikipedia.org/wiki/Symmetric-key_algorithm">Symmetric Encryption</a> 
making it suitable for encrypting large message payloads. The authenticity of Encrypted Data are then verified 
with HMAC SHA-256, essentially following an <a href="http://crypto.stackexchange.com/a/205/25652">Encrypt-then-MAC strategy</a>. </p>

<p>The key steps in the process are outlined below:</p>

<ol>
<li>Client creates a new <code>IEncryptedClient</code> configured with the Server <strong>Public Key</strong>
</li>
<li>Client uses the <code>IEncryptedClient</code> to create a EncryptedMessage Request DTO:

<ol>
<li>Generates a new AES 256bit/CBC/PKCS7 Crypt Key <strong>(Kc)</strong>, Auth Key <strong>(Ka)</strong> and <strong>IV</strong>
</li>
<li>Encrypts Crypt Key <strong>(Kc)</strong>, Auth Key <strong>(Ka)</strong> with Servers Public Key padded with OAEP = <strong>(Kc+Ka+P)e</strong>
</li>
<li>Authenticates <strong>(Kc+Ka+P)e</strong> with <strong>IV</strong> using HMAC SHA-256 = <strong>IV+(Kc+Ka+P)e+Tag</strong>
</li>
<li>Serializes Request DTO to JSON packed with current <code>Timestamp</code>, <code>Verb</code> and <code>Operation</code> = <strong>(M)</strong>
</li>
<li>Encrypts <strong>(M)</strong> with Crypt Key <strong>(Kc)</strong> and <strong>IV</strong> = <strong>(M)e</strong>
</li>
<li>Authenticates <strong>(M)e</strong> with Auth Key <strong>(Ka)</strong> and <strong>IV</strong> = <strong>IV+(M)e+Tag</strong>
</li>
<li>Creates <code>EncryptedMessage</code> DTO with Servers <code>KeyId</code>, <strong>IV+(Kc+Ka+P)e+Tag</strong> and <strong>IV+(M)e+Tag</strong>
</li>
</ol>
</li>
<li>Client uses the <code>IEncryptedClient</code> to send the populated <code>EncryptedMessage</code> to the remote Server</li>
</ol>

<p>On the Server, the <code>EncryptedMessagingFeature</code> Request Converter processes the <code>EncryptedMessage</code> DTO:</p>

<ol>
<li>Uses Private Key identified by <strong>KeyId</strong> or the current Private Key if <strong>KeyId</strong> wasn't provided

<ol>
<li>Request Converter Extracts <strong>IV+(Kc+Ka+P)e+Tag</strong> into <strong>IV</strong> and <strong>(Kc+Ka+P)e+Tag</strong>
</li>
<li>Decrypts <strong>(Kc+Ka+P)e+Tag</strong> with Private Key into <strong>(Kc)</strong> and <strong>(Ka)</strong>
</li>
<li>The <strong>IV</strong> is checked against the nonce Cache, verified it's never been used before, then cached</li>
<li>The <strong>IV+(Kc+Ka+P)e+Tag</strong> is verified it hasn't been tampered with using Auth Key <strong>(Ka)</strong>
</li>
<li>The <strong>IV+(M)e+Tag</strong> is verified it hasn't been tampered with using Auth Key <strong>(Ka)</strong>
</li>
<li>The <strong>IV+(M)e+Tag</strong> is decrypted using Crypt Key <strong>(Kc)</strong> = <strong>(M)</strong>
</li>
<li>The <strong>timestamp</strong> is verified it's not older than <code>EncryptedMessagingFeature.MaxRequestAge</code>
</li>
<li>Any expired nonces are removed. (The <strong>timestamp</strong> and <strong>IV</strong> are used to prevent replay attacks)</li>
<li>The JSON body is deserialized and resulting <strong>Request DTO</strong> returned from the Request Converter</li>
</ol>
</li>
<li>The converted <strong>Request DTO</strong> is executed in ServiceStack's Request Pipeline as normal</li>
<li>The <strong>Response DTO</strong> is picked up by the EncryptedMessagingFeature <strong>Response Converter</strong>:

<ol>
<li>Any <strong>Cookies</strong> set during the Request are removed</li>
<li>The <strong>Response DTO</strong> is serialized with the <strong>AES Key</strong> and returned in an <code>EncryptedMessageResponse</code>
</li>
</ol>
</li>
<li>The <code>IEncryptedClient</code> decrypts the <code>EncryptedMessageResponse</code> with the <strong>AES Key</strong>

<ol>
<li>The <strong>Response DTO</strong> is extracted and returned to the caller</li>
</ol>
</li>
</ol>

<p>A visual of how this all fits together in captured in the high-level diagram below:</p>

<p><a href="https://raw.githubusercontent.com/ServiceStack/Assets/master/img/release-notes/encrypted-messaging.png" target="_blank"><img src="https://raw.githubusercontent.com/ServiceStack/Assets/master/img/release-notes/encrypted-messaging.png" alt="" style="max-width:100%;"></a></p>

<ul>
<li>Components in <strong>Yellow</strong> show the encapsulated Encrypted Messaging functionality where all encryption and decryption is performed</li>
<li>Components in <strong>Blue</strong> show Unencrypted DTO's</li>
<li>Components in <strong>Green</strong> show Encrypted content:

<ul>
<li>The AES Keys and IV in <strong>Dark Green</strong> is encrypted by the client using the Server's Public Key</li>
<li>The EncryptedRequest in <strong>Light Green</strong> is encrypted with a new AES Key generated by the client on each Request</li>
</ul>
</li>
<li>Components in <strong>Dark Grey</strong> depict existing ServiceStack functionality where Requests are executed as normal through the <a href="https://github.com/ServiceStack/ServiceStack/wiki/C%23-client">Service Client</a> and <a href="https://github.com/ServiceStack/ServiceStack/wiki/Order-of-Operations">Request Pipeline</a>
</li>
</ul>

<p>All Request and Response DTO's get encrypted and embedded in the <code>EncryptedMessage</code> and <code>EncryptedMessageResponse</code> DTO's below:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">EncryptedMessage</span> : <span class="pl-k">IReturn</span>&lt;<span class="pl-k">EncryptedMessageResponse</span>&gt;
{
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">KeyId</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">EncryptedSymmetricKey</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">EncryptedBody</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">EncryptedMessageResponse</span>
{
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">EncryptedBody</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}</pre></div>

<p>The diagram also expands the <code>EncryptedBody</code> Content containing the <strong>EncryptedRequest</strong> consisting of the following parts:</p>

<ul>
<li>
<strong>Timestamp</strong> - Unix Timestamp of the Request</li>
<li>
<strong>Verb</strong> - Target HTTP Method</li>
<li>
<strong>Operation</strong> - Request DTO Name</li>
<li>
<strong>JSON</strong> - Request DTO serialized as JSON</li>
</ul>

<h3>
<a id="user-content-support-for-versioning-private-keys-with-key-rotations" class="anchor" href="#support-for-versioning-private-keys-with-key-rotations" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Support for versioning Private Keys with Key Rotations</h3>

<p>One artifact visible in the above process was the use of a <code>KeyId</code>. This is a human readable string used 
to identify the Servers Public Key using the first 7 characters of the Public Key Modulus 
(visible when viewing the Private Key serialized as XML). 
This is automatically sent by <code>IEncryptedClient</code> to tell the <code>EncryptedMessagingFeature</code> which Private Key 
should be used to decrypt the AES Crypt and Auth Keys.</p>

<p>By supporting multiple private keys, the Encrypted Messaging feature allows the seamless transition to a 
new Private Key without affecting existing clients who have yet to adopt the latest Public Key. </p>

<p>Transitioning to a new Private Key just involves taking the existing Private Key and adding it to the 
<code>FallbackPrivateKeys</code> collection whilst introducing a new Private Key, e.g:</p>

<div class="highlight highlight-source-cs"><pre>Plugins.Add(<span class="pl-k">new</span> EncryptedMessagesFeature
{
    PrivateKey = NewPrivateKey,
    FallbackPrivateKeys = {
        PreviousKey2015,
        PreviousKey2014,
    },
});</pre></div>

<h3>
<a id="user-content-why-rotate-private-keys" class="anchor" href="#why-rotate-private-keys" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Why Rotate Private Keys?</h3>

<p>Since anyone who has a copy of the Private Key can decrypt encrypted messages, rotating the private key clients
use limits the amount of exposure an adversary who has managed to get a hold of a compromised private key has. 
i.e. if the current Private Key was somehow compromised, an attacker with access to the encrypted 
network packets will be able to read each message sent that was encrypted with the compromised private key 
up until the Server introduces a new Private Key which clients switches over to.</p>

<h3>
<a id="user-content-source-code" class="anchor" href="#source-code" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Source Code</h3>

<ul>
<li>The Client implementation is available in <a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack.Client/EncryptedServiceClient.cs">EncryptedServiceClient.cs</a>
</li>
<li>The Server implementation is available in <a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack/EncryptedMessagesFeature.cs">EncryptedMessagesFeature.cs</a>
</li>
<li>The Crypto Utils used are available in the <a href="https://github.com/ServiceStack/ServiceStack/blob/3af2526d2f710576a9764d22501af428e85315cb/src/ServiceStack.Client/CryptUtils.cs#L31">RsaUtils.cs</a> and <a href="https://github.com/ServiceStack/ServiceStack/blob/3af2526d2f710576a9764d22501af428e85315cb/src/ServiceStack.Client/CryptUtils.cs#L198">AesUtils.cs</a>
</li>
<li>Tests are available in <a href="https://github.com/ServiceStack/ServiceStack/blob/master/tests/ServiceStack.WebHost.Endpoints.Tests/UseCases/EncryptedMessagesTests.cs">EncryptedMessagesTests.cs</a>
</li>
</ul>
