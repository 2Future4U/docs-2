<p>The Service Gateway is implemented on top of ServiceStack's existing message-based architecture to open up 
exciting new possibilities for development of loosely-coupled
<a href="https://github.com/ServiceStack/ServiceStack/wiki/Modularizing-services">Modularized Service Architectures</a>.</p>

<p>The new <a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack.Interfaces/IServiceGateway.cs">IServiceGateway</a>
interfaces represent the minimal surface area required to support ServiceStack's different calling conventions 
in a formalized API that supports both Sync and Async Service Integrations:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">interface</span> <span class="pl-en">IServiceGateway</span>
{
    <span class="pl-c">// Normal Request/Reply Services</span>
    TResponse Send&lt;TResponse&gt;(<span class="pl-k">object</span> requestDto);

    <span class="pl-c">// Auto Batched Request/Reply Requests</span>
    List&lt;TResponse&gt; SendAll&lt;TResponse&gt;(IEnumerable&lt;<span class="pl-k">object</span>&gt; requestDtos);

    <span class="pl-c">// OneWay Service</span>
    <span class="pl-k">void</span> <span class="pl-en">Publish</span>(<span class="pl-k">object</span> <span class="pl-smi">requestDto</span>);

    <span class="pl-c">// Auto Batched OneWay Requests</span>
    <span class="pl-k">void</span> <span class="pl-en">PublishAll</span>(IEnumerable&lt;object&gt; requestDtos);
}

<span class="pl-c">// Equivalent Async API's</span>
<span class="pl-k">public</span> <span class="pl-k">interface</span> <span class="pl-en">IServiceGatewayAsync</span>
{
    Task&lt;TResponse&gt; SendAsync&lt;TResponse&gt;(<span class="pl-k">object</span> requestDto, 
        CancellationToken token = <span class="pl-en">default</span>(CancellationToken));

    Task&lt;List&lt;TResponse&gt;&gt; SendAllAsync&lt;TResponse&gt;(IEnumerable&lt;<span class="pl-k">object</span>&gt; requestDtos, 
        CancellationToken token = <span class="pl-en">default</span>(CancellationToken));

    Task <span class="pl-en">PublishAsync</span>(<span class="pl-k">object</span> <span class="pl-smi">requestDto</span>, 
        <span class="pl-k">CancellationToken</span> <span class="pl-smi">token</span> <span class="pl-k">=</span> default(CancellationToken));

    Task <span class="pl-en">PublishAllAsync</span>(IEnumerable&lt;object&gt; requestDtos, 
        <span class="pl-k">CancellationToken</span> <span class="pl-smi">token</span> <span class="pl-k">=</span> default(CancellationToken));
}</pre></div>

<p>The minimum set of API's above requires the least burden for <code>IServiceGateway</code> implementers whilst the
<a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack.Client/ServiceGatewayExtensions.cs">ServiceGatewayExtensions</a>
overlays convenience API's common to all implementations providing the nicest API's possible for Request DTO's 
implementing the recommended <code>IReturn&lt;T&gt;</code> and <code>IReturnVoid</code> interface markers. The extension methods also 
provide fallback pseudo-async support for <code>IServiceGateway</code> implementations that also don't implement the
optional <code>IServiceGatewayAsync</code>, but will use native async implementations for those that do.</p>

<p>Naked Request DTO's without annotations are sent as a <strong>POST</strong> but alternative Verbs are also supported 
by annotating Request DTO's with 
<a href="https://github.com/ServiceStack/ServiceStack/wiki/C%23-client#http-verb-interface-markers">HTTP Verb Interface Markers</a>
where Request DTO's containing <code>IGet</code>, <code>IPut</code>, etc. are sent using the typed Verb API, e.g:</p>

<div class="highlight highlight-source-cs"><pre>[Route(<span class="pl-s"><span class="pl-pds">"</span>/customers/{Id}<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">GetCustomer</span> : <span class="pl-k">IReturn</span>&lt;<span class="pl-k">Customer</span>&gt;, <span class="pl-k">IGet</span>
{
    <span class="pl-k">public</span> <span class="pl-k">int</span> <span class="pl-en">Id</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span> ;}
}

<span class="pl-k">var</span> customer = client.Send(<span class="pl-k">new</span> GetCustomer { Id = <span class="pl-c1">1</span> }); <span class="pl-c">//GET /customers/1</span>
<span class="pl-c">//Equivalent to:</span>
<span class="pl-k">var</span> customer = client.Get(<span class="pl-k">new</span> GetCustomer { Id = <span class="pl-c1">1</span> });  </pre></div>

<h3>
<a id="user-content-service-integration-apis" class="anchor" href="#service-integration-apis" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Service Integration API's</h3>

<p>To execute existing ServiceStack Services internally you can call <code>ExecuteRequest(requestDto)</code> which 
passes the Request DTO along with the current <code>IRequest</code> into the <code>ServiceController.Execute()</code> to execute. 
The alternative is to call <code>ResolveService&lt;T&gt;</code> to resolve an autowired instance of the Service that's 
injected with the current <code>IRequest</code> context letting you call methods on the Service instance directly.
Below is an example of using both API's:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">object</span> Any(GetCustomerOrders request)
{
    <span class="pl-k">using</span> (<span class="pl-k">var</span> orderService = <span class="pl-c1">base</span>.ResolveService&lt;OrderService&gt;())
    {
        <span class="pl-k">return</span> <span class="pl-k">new</span> GetCustomerOrders {
            Customer = (Customer)<span class="pl-c1">base</span>.ExecuteRequest(<span class="pl-k">new</span> GetCustomer { Id = request.Id }),
            Orders = orderService.Any(<span class="pl-k">new</span> QueryOrders { CustomerId = request.Id })
        };
    }
}</pre></div>

<p>The recommended approach now is to instead use the <code>IServiceGateway</code> accessible from <code>base.Gateway</code> 
available in all Service, Razor Views, MVC ServiceStackController classes, etc. It works similar to
the <code>ExecuteRequest()</code> API (which it now replaces) where you can invoke a Service with just a populated 
Request DTO, but instead yields an ideal typed API for Request DTO's implementing the recommended <code>IReturn&lt;T&gt;</code>
or <code>IReturnVoid</code> markers:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">object</span> Any(GetCustomerOrders request)
{
    <span class="pl-k">return</span> <span class="pl-k">new</span> GetCustomerOrders {
        Customer = Gateway.Send(<span class="pl-k">new</span> GetCustomer { Id = request.Id }),
        Orders = Gateway.Send(<span class="pl-k">new</span> QueryOrders { CustomerId = request.Id })
    };
}</pre></div>

<p>Or you can use the Async API if you prefer the non-blocking version:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">async</span> Task&lt;GetCustomerOrdersResponse&gt; Any(GetCustomerOrders request)
{
    <span class="pl-k">return</span> <span class="pl-k">new</span> GetCustomerOrdersResponse {
        Customer = <span class="pl-k">await</span> Gateway.SendAsync(<span class="pl-k">new</span> GetCustomer { Id = request.Id }),
        Orders = <span class="pl-k">await</span> Gateway.SendAsync(<span class="pl-k">new</span> QueryOrders { CustomerId = request.Id })
    };
}</pre></div>

<p>The capability that sets the ServiceGateway apart (other than offering a nicer API to work with) 
is that this System could later have its <strong>Customer</strong> and <strong>Order</strong> Subsystems split out into different 
hosts and this exact Service implementation would continue to function as before, albeit a little slower due 
to the overhead of any introduced out-of-process communications.</p>

<p>The default implementation of <code>IServiceGateway</code> uses the 
<a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack/InProcessServiceGateway.cs">InProcessServiceGateway</a>
which delegates the Request DTO to the appropriate <code>ServiceController.Execute()</code> or 
<code>ServiceController.ExecuteAsync()</code> methods to execute the Service. One noticeable difference is that any 
Exceptions thrown by downstream Services are automatically converted into the same <code>WebServiceException</code> 
that clients would throw when calling the Service externally, this is so Exceptions are indistinguishable
whether it's calling an internal Service or an external one, which begins touching on the benefits of the 
Gateway... </p>

<p>The ServiceGateway is the same interface whether you're calling an Internal Service on the Server or a 
remote Service from a client. It exposes an ideal message-based API that's
<a href="http://www.infoq.com/articles/interview-servicestack">optimal for remote Service Integrations</a> 
that also supports 
<a href="https://github.com/ServiceStack/ServiceStack/wiki/Auto-Batched-Requests">Auto Batched Requests</a> 
for combining multiple Service Calls into a single Request, minimizing latency when possible.</p>

<h3>
<a id="user-content-substitutable-service-gateways" class="anchor" href="#substitutable-service-gateways" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Substitutable Service Gateways</h3>

<p>These characteristics makes it easy to substitute and customize the behavior of the Gateway as visible in the
examples below. The easiest scenario to support is to redirect all Service Gateway calls to a remote 
ServiceStack instance which can be done by registering any .NET Service Client against the <code>IServiceGateway</code> 
interface, e.g:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-k">void</span> Configure(Container container)
{
    container.Register&lt;IServiceGateway&gt;(c =&gt; <span class="pl-k">new</span> JsonServiceClient(baseUrl));
}</pre></div>

<p>A more likely scenario you'd want to support is a mix where internal requests are executed in-process 
and external requests call their respective Service. If your system is split in two this becomes a simple
check to return the local InProcess Gateway for Requests which are defined in this ServiceStack instance
otherwise return a Service Client configured to the alternative host when not, e.g:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">CustomServiceGatewayFactory</span> : <span class="pl-k">ServiceGatewayFactoryBase</span>
{
    <span class="pl-k">public</span> <span class="pl-k">override</span> IServiceGateway <span class="pl-en">GetGateway</span>(<span class="pl-k">Type</span> <span class="pl-smi">requestType</span>)
    {
        <span class="pl-k">var</span> isLocal = HostContext.Metadata.RequestTypes.Contains(requestType);
        <span class="pl-k">var</span> gateway = isLocal
            ? (IServiceGateway)<span class="pl-c1">base</span>.localGateway
            : <span class="pl-k">new</span> JsonServiceClient(alternativeBaseUrl);
        <span class="pl-k">return</span> gateway;
    }
}</pre></div>

<p>For this we needed to implement the
<a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack.Interfaces/Web/IServiceGatewayFactory.cs">IServiceGatewayFactory</a>
so we can first capture the current <code>IRequest</code> that's needed in order to call the In Process Service Gateway with.
The convenience <a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack/ServiceGatewayFactoryBase.cs">ServiceGatewayFactoryBase</a>
abstracts the rest of the API away so you're only tasked with returning the appropriate Service Gateway for 
the specified Request DTO. </p>

<p>Capturing the current <code>IRequest</code> makes the Gateway factory instance non-suitable to use as a singleton, 
so we'll need to register it with a <code>ReuseScope.None</code> scope so a new instance is resolved each time:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-k">void</span> Configure(Container container)
{
    container.Register&lt;IServiceGatewayFactory&gt;(x =&gt; <span class="pl-k">new</span> CustomServiceGatewayFactory())
        .ReusedWithin(ReuseScope.None);
}</pre></div>

<h2>
<a id="user-content-service-discovery" class="anchor" href="#service-discovery" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>[[Service Discovery]]</h2>

<p>This demonstrates the underpinnings by which we can plug into and intercept all intra-Service calls and apply our own high-level custom logic which sets the foundation for other value-added functionality like [[Service Discovery]] which can transparently route service calls to the most appropriate available remote endpoint at run-time, automatically without additional configuration or code-maintenance overhead.</p>

<h2>
<a id="user-content-designing-for-microservices" class="anchor" href="#designing-for-microservices" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Designing for Microservices</h2>

<p>Whether or not Systems 
<a href="http://blog.cleancoder.com/uncle-bob/2014/09/19/MicroServicesAndJars.html">benefit overall from a fine-grained microservices architecture</a>,
enough to justify the additional latency, management and infrastructure overhead it requires, we still see 
value in the development process of
<a href="https://channel9.msdn.com/events/Build/2016/C918">designing for Microservices</a> where decoupling naturally 
isolated components into loosely-coupled subsystems has software-architecture benefits with overall complexity 
of an entire system being reduced into smaller, more manageable logical scopes which encapsulates their capabilities 
<a href="http://stackoverflow.com/a/32940275/85785">behind small, re-usable, well-defined facades</a>.</p>

<p>The ServiceGateway and its Services Discovery ecosystem together with ServiceStack's recommended use of 
impl-free reusable POCO DTO's and its ability to 
<a href="https://github.com/ServiceStack/ServiceStack/wiki/Modularizing-services">modularize Service implementations across multiple projects</a>
naturally promote a microservices-ready architecture where Service interactions are loosely-coupled behind 
well-defined, reusable, coarse-grained messages. Designing systems in this way later allows the isolated
Service Implementation .dll to be extracted from the main System and wrapped into its own AppHost. Together 
with an agreed Service Discovery solution, allows you to spawn multiple instances of the new Service -
letting you scale, deploy and maintain it independently from the rest of the system.</p>
