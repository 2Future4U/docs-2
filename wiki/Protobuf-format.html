<p><a href="http://code.google.com/p/protobuf/">Protocol Buffers</a> is a high-performance, compact binary wire format invented by Google who use it internally so they can communicate with their internal network services at very high speed.</p>

<p>For .NET <a href="http://twitter.com/marcgravell">@marcgravell</a> has developed <strong><a href="http://code.google.com/p/protobuf-net/">protobuf-net</a></strong> - a robust implementation of the Protocol Buffers wire format that provides the <a href="http://www.servicestack.net/benchmarks/#northwind-serializer">fastest serialization</a> option available for .NET.</p>

<p>ProtoBuf is a great addition to your ServiceStack's web services as it provides the <strong>fastest binary serializer</strong> to go along with the <strong>2 fastest text serializers</strong> for .NET in <a href="http://www.servicestack.net/mythz_blog/?p=344">JSON</a> and <a href="http://www.servicestack.net/mythz_blog/?p=176">JSV</a> formats (already included by default). </p>

<p><em>Note: Until we can get marcgravell to succumb to internal pressure and add support for attribute-less POCOs you will need to add unique custom indexes for each property on your DTOs e.g: <code>[DataMember(Order=N)]</code>.</em></p>

<p>Otherwise another fast binary serializer that supports attribute-less POCOs is the new [[MessagePack Format]].</p>

<h2>
<a id="user-content-installing-via-nuget" class="anchor" href="#installing-via-nuget" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Installing via NuGet</h2>

<p>As it requires an external <strong>protobuf-net.dll</strong> dependency ProtoBuf support is not automatically bundled inside ServiceStack, but it is easily installed with the <a href="https://nuget.org/packages/ServiceStack.ProtoBuf">ServiceStack.ProtoBuf</a> NuGet package:</p>

<h3>
<a id="user-content-install-package-servicestackprotobuf" class="anchor" href="#install-package-servicestackprotobuf" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Install-Package <a href="https://nuget.org/packages/ServiceStack.ProtoBuf">ServiceStack.ProtoBuf</a>
</h3>

<p>After the NuGet Package is added to your Project, enable the ProtoBuf format with:</p>

<pre><code>Plugins.Add(new ProtoBufFormat());
</code></pre>

<p>The NuGet plugin also includes the <strong>ProtoBufServiceClient</strong> client below so you can easily call it from any C# Client.</p>

<h2>
<a id="user-content-registering-protobuf-manually" class="anchor" href="#registering-protobuf-manually" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Registering ProtoBuf Manually</h2>

<p>The API for adding custom Formats and Content Types in ServiceStack is so easy we use it ourselves :) Where the CSV, HTML, Markdown and now ProtoBuf format are all registered in the same way by registering the new ContentType with your AppHost's <strong>ContentTypeFilters</strong>.</p>

<p>Adding support for ProtoBuf is equally simple.  It can be added by calling a single method:</p>

<pre><code>appHost.ContentTypeFilters.Register(ContentType.ProtoBuf,
    (reqCtx, res, stream) =&gt; ProtoBuf.Serializer.NonGeneric.Serialize(stream, res),
    ProtoBuf.Serializer.NonGeneric.Deserialize);
</code></pre>

<p>This makes the ProtoBuf format available in all of ServiceStack:</p>

<ul>
<li>A new <strong>X-PROTOBUF</strong> column added for all services on the metadata pages</li>
<li>New <code>/x-protobuf/syncreply/{Service}</code> and <code>/x-protobuf/asynconeway/{Service}</code> pre-defined routes</li>
<li>Clients can request it with <code>Accept: application/x-protobuf</code> HTTP Header or <strong>?format=x-protobuf</strong> query string</li>
</ul>

<h2>
<a id="user-content-end-to-end-happiness" class="anchor" href="#end-to-end-happiness" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>End to End happiness</h2>

<p>However simply registering ProtoBuf is not enough to ensure end-to-end happiness so we also make it easy to create your own generic strong-typed ProtoBuf ServiceClient with the following code:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">ProtoBufServiceClient</span> : <span class="pl-k">ServiceClientBase</span>
{
    <span class="pl-k">public</span> <span class="pl-en">ProtoBufServiceClient</span>(<span class="pl-k">string</span> <span class="pl-smi">baseUri</span>)
    {
        SetBaseUri(baseUri);
    }

    <span class="pl-k">public</span> <span class="pl-en">ProtoBufServiceClient</span>(<span class="pl-k">string</span> <span class="pl-smi">syncReplyBaseUri</span>, <span class="pl-k">string</span> <span class="pl-smi">asyncOneWayBaseUri</span>)
        : <span class="pl-c1">base</span>(syncReplyBaseUri, asyncOneWayBaseUri) {}

    <span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-k">void</span> <span class="pl-en">SerializeToStream</span>(<span class="pl-k">IRequestContext</span> <span class="pl-smi">requestContext</span>, <span class="pl-k">object</span> <span class="pl-smi">request</span>, <span class="pl-k">Stream</span> <span class="pl-smi">stream</span>)
    {
        Serializer.NonGeneric.Serialize(stream, request);
    }

    <span class="pl-k">public</span> <span class="pl-k">override</span> T DeserializeFromStream&lt;T&gt;(Stream stream)
    {
        <span class="pl-k">return</span> Serializer.Deserialize&lt;T&gt;(stream);
    }

    <span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-k">string</span> ContentType
    {
        <span class="pl-k">get</span> { <span class="pl-k">return</span> Common.Web.ContentType.ProtoBuf; }
    }

    <span class="pl-k">public</span> <span class="pl-k">override</span> StreamDeserializerDelegate StreamDeserializer
    {
        <span class="pl-k">get</span> { <span class="pl-k">return</span> Serializer.NonGeneric.Deserialize; }
    }

    <span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-k">string</span> Format
    {
        <span class="pl-k">get</span> { <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>x-protobuf<span class="pl-pds">"</span></span>; }
    }
}</pre></div>

<p>This now lets you call each of your services with a Strong Typed service client of your very own:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> client = <span class="pl-k">new</span> ProtoBufServiceClient(BaseUri);
<span class="pl-k">var</span> response = client.Send&lt;HelloResponse&gt;(<span class="pl-k">new</span> Hello { Name = <span class="pl-s"><span class="pl-pds">"</span>ProtoBuf<span class="pl-pds">"</span></span> });</pre></div>

<p>The above ProtoBufServiceClient works like all the other strong-typed ServiceClients in ServiceStack where it also implements <code>IServiceClient</code> and <code>IRestClient</code> interfaces so you can easily swap out your existing clients to take advantage of the performance boost offered by ProtoBuf with minimal effort!</p>

<h1>
<a id="user-content-community-resources" class="anchor" href="#community-resources" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Community Resources</h1>

<ul>
<li>
<a href="http://stevenhollidge.blogspot.com/2012/04/servicestack-rest-with-protobuf.html">REST with ProtoBuf - Web Services in 5 easy steps</a> by <a href="https://twitter.com/stevenhollidge">@stevenhollidge</a>
</li>
</ul>
