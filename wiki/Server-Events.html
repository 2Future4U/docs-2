<p><a href="http://www.html5rocks.com/en/tutorials/eventsource/basics/">Server Sent Events</a> (SSE) is an elegant <a href="http://dev.w3.org/html5/eventsource/">web technology</a> for efficiently receiving push notifications from any HTTP Server. It can be thought of as a mix between long polling and one-way WebSockets and contains many benefits over each:</p>

<ul>
<li>
<strong>Simple</strong> - Server Sent Events is just a single long-lived HTTP Request that any HTTP Server can support</li>
<li>
<strong>Efficient</strong> - Each client uses a single TCP connection and each message avoids the overhead of HTTP Connections and Headers that's <a href="http://matthiasnehlsen.com/blog/2013/05/01/server-sent-events-vs-websockets/">often faster than Web Sockets</a>.</li>
<li>
<strong>Resilient</strong> - Browsers automatically detect when a connection is broken and automatically reconnects</li>
<li>
<strong>Interoperable</strong> - As it's just plain-old HTTP, it's introspectable with your favorite HTTP Tools and even works through HTTP proxies (with buffering and <a href="http://www.w3.org/TR/2011/WD-eventsource-20111020/#notes">chunked-encoding turned off</a>).</li>
<li>
<strong>Well Supported</strong> - As a Web Standard it's supported in all major browsers except for IE which <a href="http://html5doctor.com/server-sent-events/#yaffle">can be enabled with polyfills</a> - see <a href="https://github.com/ServiceStackApps/Chat/blob/master/src/Chat/default_ieshim.cshtml">default_ieshim.cshtml</a> and its <a href="http://chat.servicestack.net/default_ieshim">Live Chat Example</a>.</li>
</ul>

<p>We've chosen to adopt Server Sent Events for Server Notifications as it's a beautifully simple and elegant <a href="http://dev.w3.org/html5/eventsource/">Web Standard</a> with better HTTP fidelity than <strong>WebSockets</strong>, that's perfect fit for Server Push Communications that works in both ServiceStack' ASP.NET and SelfHosts without requiring any extra .NET dependencies or <a href="http://stackoverflow.com/a/12073593/85785">require the host Windows Server have WebSockets support</a> to use. </p>

<h3>
<a id="user-content-server-event-clients" class="anchor" href="#server-event-clients" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Server Event Clients</h3>

<ul>
<li><a href="https://github.com/ServiceStack/ServiceStack/wiki/JavaScript-Server-Events-Client">JavaScript Client</a></li>
<li><a href="https://github.com/ServiceStack/ServiceStack/wiki/C%23-Server-Events-Client">C# Client</a></li>
</ul>

<h3>
<a id="user-content-server-event-providers" class="anchor" href="#server-event-providers" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Server Event Providers</h3>

<ul>
<li>Memory Server Events (default)</li>
<li><a href="https://github.com/ServiceStack/ServiceStack/wiki/Redis-Server-Events">Redis Server Events</a></li>
</ul>

<h2>
<a id="user-content-registering" class="anchor" href="#registering" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Registering</h2>

<p>Like most other <a href="https://github.com/ServiceStack/ServiceStack/wiki/Plugins">modular functionality</a> in ServiceStack, Server Sent Events is encapsulated in a single Plugin that can be registered in your AppHost with:</p>

<div class="highlight highlight-source-cs"><pre>Plugins.Add(<span class="pl-k">new</span> ServerEventsFeature());</pre></div>

<p>The registration above is all that's needed for most use-cases which just uses the defaults below:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">class</span> <span class="pl-en">ServerEventsFeature</span>
{
    StreamPath = <span class="pl-s"><span class="pl-pds">"</span>/event-stream<span class="pl-pds">"</span></span>;            <span class="pl-c">// The entry-point for Server Sent Events</span>
    HeartbeatPath = <span class="pl-s"><span class="pl-pds">"</span>/event-heartbeat<span class="pl-pds">"</span></span>;      <span class="pl-c">// Where to send heartbeat pulses</span>
    UnRegisterPath = <span class="pl-s"><span class="pl-pds">"</span>/event-unregister<span class="pl-pds">"</span></span>;    <span class="pl-c">// Where to unregister your subscription</span>
    SubscribersPath = <span class="pl-s"><span class="pl-pds">"</span>/event-subscribers<span class="pl-pds">"</span></span>;  <span class="pl-c">// View public info of channel subscribers </span>

    <span class="pl-c">// Return `401 Unauthorized` to non-authenticated clients</span>
    LimitToAuthenticatedUsers = <span class="pl-c1">false</span>;

    <span class="pl-c">// How long to wait for heartbeat before unsubscribing</span>
    IdleTimeout = TimeSpan.FromSeconds(<span class="pl-c1">30</span>);  

    <span class="pl-c">// Client Interval for sending heartbeat messages</span>
    HeartbeatInterval = TimeSpan.FromSeconds(<span class="pl-c1">10</span>);

    <span class="pl-c">// Send notifications when subscribers join/leave</span>
    NotifyChannelOfSubscriptions = <span class="pl-c1">true</span>;
}</pre></div>

<blockquote>
<p>The paths allow you to customize the routes for the built-in Server Events API's, whilst setting either path to <code>null</code> disables that feature. </p>
</blockquote>

<p>There are also a number of hooks available providing entry points where custom logic can be added to modify or enhance existing behavior:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">class</span> <span class="pl-en">ServerEventsFeature</span>
{
     <span class="pl-c">//Filter OnConnect messages</span>
    Action&lt;IEventSubscription, Dictionary&lt;<span class="pl-k">string</span>, <span class="pl-k">string</span>&gt;&gt; OnConnect;

    <span class="pl-c">// Events fired when </span>
    Action&lt;IEventSubscription, IRequest&gt; OnCreated;  <span class="pl-c">// Subscription is created</span>
    Action&lt;IEventSubscription&gt; OnSubscribe;          <span class="pl-c">// Subscription is registered </span>
    Action&lt;IEventSubscription&gt; OnUnsubscribe;        <span class="pl-c">// Subscription is unregistered</span>
}</pre></div>

<h2>
<a id="user-content-sending-server-events" class="anchor" href="#sending-server-events" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Sending Server Events</h2>

<p>The way your Services send notifications is via the <code>IServerEvents</code> API which defaults to an in-memory <code>MemoryServerEvents</code> implementation which keeps a record of all subscriptions and connections in memory:</p>

<blockquote>
<p>Server Events can also be configured to use a <a href="https://github.com/ServiceStack/ServiceStack/wiki/Redis-Server-Events">distributed Redis backend</a> which allows Server Events to work across load-balanced app servers.</p>
</blockquote>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">interface</span> <span class="pl-en">IServerEvents</span> : <span class="pl-k">IDisposable</span>
{
    <span class="pl-c">// External API's</span>
    <span class="pl-k">void</span> <span class="pl-en">NotifyAll</span>(<span class="pl-k">string</span> <span class="pl-smi">selector</span>, <span class="pl-k">object</span> <span class="pl-smi">message</span>);
    <span class="pl-k">void</span> <span class="pl-en">NotifyChannel</span>(<span class="pl-k">string</span> <span class="pl-smi">channel</span>, <span class="pl-k">string</span> <span class="pl-smi">selector</span>, <span class="pl-k">object</span> <span class="pl-smi">message</span>);
    <span class="pl-k">void</span> <span class="pl-en">NotifySubscription</span>(<span class="pl-k">string</span> <span class="pl-smi">subscriptionId</span>, <span class="pl-k">string</span> <span class="pl-smi">selector</span>, <span class="pl-k">object</span> <span class="pl-smi">message</span>, <span class="pl-k">string</span> <span class="pl-smi">channel</span> <span class="pl-k">=</span> <span class="pl-c1">null</span>);
    <span class="pl-k">void</span> <span class="pl-en">NotifyUserId</span>(<span class="pl-k">string</span> <span class="pl-smi">userId</span>, <span class="pl-k">string</span> <span class="pl-smi">selector</span>, <span class="pl-k">object</span> <span class="pl-smi">message</span>, <span class="pl-k">string</span> <span class="pl-smi">channel</span> <span class="pl-k">=</span> <span class="pl-c1">null</span>);
    <span class="pl-k">void</span> <span class="pl-en">NotifyUserName</span>(<span class="pl-k">string</span> <span class="pl-smi">userName</span>, <span class="pl-k">string</span> <span class="pl-smi">selector</span>, <span class="pl-k">object</span> <span class="pl-smi">message</span>, <span class="pl-k">string</span> <span class="pl-smi">channel</span> <span class="pl-k">=</span> <span class="pl-c1">null</span>);
    <span class="pl-k">void</span> <span class="pl-en">NotifySession</span>(<span class="pl-k">string</span> <span class="pl-smi">sspid</span>, <span class="pl-k">string</span> <span class="pl-smi">selector</span>, <span class="pl-k">object</span> <span class="pl-smi">message</span>, <span class="pl-k">string</span> <span class="pl-smi">channel</span> <span class="pl-k">=</span> <span class="pl-c1">null</span>);

    SubscriptionInfo <span class="pl-en">GetSubscriptionInfo</span>(<span class="pl-k">string</span> <span class="pl-smi">id</span>);
    List&lt;SubscriptionInfo&gt; <span class="pl-en">GetSubscriptionInfosByUserId</span>(<span class="pl-k">string</span> <span class="pl-smi">userId</span>);

    <span class="pl-c">// Admin API's</span>
    <span class="pl-k">void</span> <span class="pl-en">Register</span>(<span class="pl-k">IEventSubscription</span> <span class="pl-smi">subscription</span>, Dictionary&lt;string, string&gt; connectArgs = <span class="pl-c1">null</span>);
    <span class="pl-k">void</span> <span class="pl-en">UnRegister</span>(<span class="pl-k">string</span> <span class="pl-smi">subscriptionId</span>);

    <span class="pl-k">long</span> <span class="pl-en">GetNextSequence</span>(<span class="pl-k">string</span> <span class="pl-smi">sequenceId</span>);

    <span class="pl-k">int</span> <span class="pl-en">RemoveExpiredSubscriptions</span>();

    <span class="pl-k">void</span> <span class="pl-en">SubscribeToChannels</span>(<span class="pl-k">string</span> <span class="pl-smi">subscriptionId</span>, <span class="pl-k">string[]</span> <span class="pl-smi">channels</span>);
    <span class="pl-k">void</span> <span class="pl-en">UnsubscribeFromChannels</span>(<span class="pl-k">string</span> <span class="pl-smi">subscriptionId</span>, <span class="pl-k">string[]</span> <span class="pl-smi">channels</span>);

    <span class="pl-c">// Client API's</span>
    List&lt;Dictionary&lt;<span class="pl-k">string</span>, <span class="pl-k">string</span>&gt;&gt; <span class="pl-en">GetSubscriptionsDetails</span>(<span class="pl-k">params</span> <span class="pl-k">string[]</span> <span class="pl-smi">channels</span>);
    List&lt;Dictionary&lt;<span class="pl-k">string</span>, <span class="pl-k">string</span>&gt;&gt; <span class="pl-en">GetAllSubscriptionsDetails</span>();
    <span class="pl-k">bool</span> <span class="pl-en">Pulse</span>(<span class="pl-k">string</span> <span class="pl-smi">subscriptionId</span>);

    <span class="pl-c">// Clear all Registrations</span>
    <span class="pl-k">void</span> <span class="pl-en">Reset</span>();
    <span class="pl-k">void</span> <span class="pl-en">Start</span>();
    <span class="pl-k">void</span> <span class="pl-en">Stop</span>();
}</pre></div>

<p>The API's your Services predominantly deal with are the <strong>External API's</strong> which allow sending of messages at different levels of granularity. As Server Events have deep integration with ServiceStack's <a href="https://github.com/ServiceStack/ServiceStack/wiki/Sessions">Sessions</a> and <a href="https://github.com/ServiceStack/ServiceStack/wiki/Authentication-and-authorization">Authentication Providers</a> you're also able to notify specific users by either:</p>

<div class="highlight highlight-source-cs"><pre>NotifyUserId()   <span class="pl-c">// UserAuthId</span>
NotifyUserName() <span class="pl-c">// UserName</span>
NotifySession()  <span class="pl-c">// Permanent Session Id (ss-pid)</span></pre></div>

<p>Whilst these all provide different ways to send a message to a single authenticated user, any user can be connected to multiple subscriptions at any one time (e.g. by having multiple tabs open). Each one of these subscriptions is uniquely identified by a <code>subscriptionId</code> which you can send a message with using: </p>

<div class="highlight highlight-source-cs"><pre>NotifySubscription() <span class="pl-c">// Unique Subscription Id</span></pre></div>

<p>There are also API's to retrieve a users single event subscription as well as all subscriptions for a user:</p>

<div class="highlight highlight-source-cs"><pre>IEventSubscription GetSubscription(<span class="pl-k">string</span> id);

List&lt;IEventSubscription&gt; GetSubscriptionsByUserId(<span class="pl-k">string</span> userId);</pre></div>

<h2>
<a id="user-content-event-subscription" class="anchor" href="#event-subscription" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Event Subscription</h2>

<p>An Event Subscription allows you to inspect different metadata contained on each subscription as well as being able to <code>Publish()</code> messages directly to it, manually send a Heartbeat <code>Pulse()</code> (to keep the connection active) as well as <code>Unsubscribe()</code> to revoke the subscription and terminate the HTTP Connection.</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">interface</span> <span class="pl-en">IEventSubscription</span> : <span class="pl-k">IMeta</span>, <span class="pl-k">IDisposable</span>
{
    DateTime <span class="pl-en">CreatedAt</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    DateTime <span class="pl-en">LastPulseAt</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }

    <span class="pl-k">string</span> <span class="pl-en">Channel</span> { <span class="pl-k">get</span>; }
    <span class="pl-k">string</span> <span class="pl-en">UserId</span> { <span class="pl-k">get</span>; }
    <span class="pl-k">string</span> <span class="pl-en">UserName</span> { <span class="pl-k">get</span>; }
    <span class="pl-k">string</span> <span class="pl-en">DisplayName</span> { <span class="pl-k">get</span>; }
    <span class="pl-k">string</span> <span class="pl-en">SessionId</span> { <span class="pl-k">get</span>; }
    <span class="pl-k">string</span> <span class="pl-en">SubscriptionId</span> { <span class="pl-k">get</span>; }
    <span class="pl-k">bool</span> <span class="pl-en">IsAuthenticated</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }

    Action&lt;IEventSubscription&gt; <span class="pl-en">OnUnsubscribe</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">void</span> <span class="pl-en">Unsubscribe</span>();

    <span class="pl-k">void</span> <span class="pl-en">Publish</span>(<span class="pl-k">string</span> <span class="pl-smi">selector</span>, <span class="pl-k">object</span> <span class="pl-smi">message</span>);

    <span class="pl-k">void</span> <span class="pl-en">Pulse</span>();
}</pre></div>

<p>The <code>IServerEvents</code> API also offers an API to UnRegister a subscription with:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">void</span> UnRegister(IEventSubscription subscription);</pre></div>

<h2>
<a id="user-content-channels" class="anchor" href="#channels" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Channels</h2>

<p>Standard Publish / Subscribe patterns include the concept of a <strong>Channel</strong> upon which to subscribe and publish messages to. The channel in Server Events can be any arbitrary string which is declared on the fly when it's first used. </p>

<blockquote>
<p>As Request DTO names are unique in ServiceStack they also make good channel names which benefit from providing a typed API for free, e.g: <code>typeof(Request).Name</code>.</p>
</blockquote>

<p>The API to send a message to a specific channel is:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">void</span> NotifyChannel(<span class="pl-k">string</span> channel, <span class="pl-k">string</span> selector, <span class="pl-k">object</span> message);</pre></div>

<p>Which just includes the name of the <code>channel</code>, the <code>selector</code> you wish the message applies to and the <code>message</code> to send which can be any JSON serializable object.</p>

<p>Along with being able to send a message to everyone on a channel, each API also offers an optional <code>channel</code> filter which when supplied will limit messages only to that channel:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">void</span> NotifyUserId(<span class="pl-k">string</span> userId, <span class="pl-k">string</span> selector, <span class="pl-k">object</span> message, <span class="pl-k">string</span> channel = <span class="pl-c1">null</span>);</pre></div>

<h2>
<a id="user-content-order-of-events" class="anchor" href="#order-of-events" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Order of Events</h2>

<p>The following Server and Client callbacks are fired when a client first makes a Server Events Connection:</p>

<ol>
<li>
<code>ServerEventsFeature.OnInit()</code> - Fired when the server receives the initial HTTP connection. This callback can be used to customize any HTTP Headers that are sent back to the client</li>
<li>
<code>ServerEventsFeature.OnCreated()</code> - Fired when the server <code>IEventSubscription</code> is created but before it becomes Connected.</li>
<li>
<code>ServerEventsFeature.OnConnect()</code> - Fired when the <code>IEventSubscription</code> is about to be connected. This callback can be used to modify the connection info arguments the client receives</li>
<li>
<strong>(Client)</strong>  - The Client is then sent an <code>cmd.onConnect</code> message with the connection info arguments about the connection. </li>
<li>
<code>ServerEventsFeature.OnSubscribe()</code> - Fired after the subscription is registered. This callback can be used to send any custom messages to the client</li>
<li>
<strong>(Client)</strong> - If <code>ServerEventsFeature.NotifyChannelOfSubscriptions = true</code> every client in the same channel receives a <code>cmd.onJoin</code> message to notify them that a new subscription has joined the channel as well as a <code>cmd.onLeave</code> message when subscription leaves the channel</li>
</ol>

<blockquote>
<p>The <code>cmd.onConnect</code>, <code>cmd.onJoin</code> and <code>cmd.onLeave</code> messages can be handled with the <a href="https://github.com/ServiceStack/ServiceStack/wiki/JavaScript-Server-Events-Client#global-event-handlers">Global Event Handlers</a> on the JavaScript Client and the <a href="https://github.com/ServiceStack/ServiceStack/wiki/C%23-Server-Events-Client#message-event-handlers">Message Event Handlers</a> or the <a href="https://github.com/ServiceStack/ServiceStack/wiki/C%23-Server-Events-Client#the-global-receiver">Global Receiver</a> .NET ServerEventClient.</p>
</blockquote>

<h3>
<a id="user-content-heartbeats" class="anchor" href="#heartbeats" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Heartbeats</h3>

<p>Periodically whilst the client maintains a ServerEvents subscription with the server it will send periodic Heartbeats to the Server. This will fire the <code>ServerEventsFeature.OnHeartbeatInit()</code> server event which if the client is still connected will be sent a <code>cmd.onHeartbeat</code> message. If the subscription no longer exists, heartbeats will return a <code>404 - Subscription {id} does not exist</code> HTTP Response.</p>

<h2>
<a id="user-content-chat-features" class="anchor" href="#chat-features" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Chat Features</h2>

<p>The implementation of Chat is a great way to explore different Server Event features which make it easy to develop highly interactive and responsive web apps with very little effort. </p>

<h3>
<a id="user-content-active-subscribers" class="anchor" href="#active-subscribers" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Active Subscribers</h3>

<p>One feature common to chat clients is to get details of all the active subscribers in a channel which we can get from the built-in <code>/event-subscribers</code> route, e.g:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-smi">$</span>.<span class="pl-en">getJSON</span>(<span class="pl-s"><span class="pl-pds">"</span>/event-subscribers?channel=@channel<span class="pl-pds">"</span></span>, <span class="pl-k">function</span> (<span class="pl-smi">users</span>) {
    <span class="pl-smi">$</span>.<span class="pl-en">map</span>(users, <span class="pl-k">function</span>(<span class="pl-smi">user</span>) {
        usersMap[<span class="pl-smi">user</span>.<span class="pl-smi">userId</span>] <span class="pl-k">=</span> user;
        refCounter[<span class="pl-smi">user</span>.<span class="pl-smi">userId</span>] <span class="pl-k">=</span> (refCounter[<span class="pl-smi">user</span>.<span class="pl-smi">userId</span>] <span class="pl-k">||</span> <span class="pl-c1">0</span>) <span class="pl-k">+</span> <span class="pl-c1">1</span>;
    });
    <span class="pl-k">var</span> html <span class="pl-k">=</span> <span class="pl-smi">$</span>.<span class="pl-en">map</span>(usersMap, <span class="pl-k">function</span>(<span class="pl-smi">user</span>) { <span class="pl-k">return</span> <span class="pl-en">createUser</span>(user); }).<span class="pl-c1">join</span>(<span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>);
    <span class="pl-en">$</span>(<span class="pl-s"><span class="pl-pds">"</span>#users<span class="pl-pds">"</span></span>).<span class="pl-en">html</span>(html);
});</pre></div>

<p>As a single user can have multiple subscriptions (e.g. multiple tabs open) users are merged into a single <code>usersMap</code> so each user is only listed once in the users list and a <code>refCounter</code> is maintained with the number of subscriptions each user has, so we're able to tell when the user has no more active subscriptions and can remove them from the list.</p>

<h3>
<a id="user-content-chat-box" class="anchor" href="#chat-box" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Chat box</h3>

<p>Chat's text box provides a free-text entry input to try out different Server Event features where each text message is posted to a ServiceStack Service which uses the <code>IServerEvents</code> API to send notifications the channels subscribers. When a server event is received on the client, the ss-utils.js client bindings routes the message to the appropriate handler. As all messages go through this same process, the moment the log entry appears in your chat window is also when it appears for everyone else (i.e instant when running localhost).</p>

<p>Normal chat messages (i.e. that don't specify a selector) uses the default <code>cmd.chat</code> selector which is sent to the <code>chat</code> handler that just echoes the entry into the chat log with:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-en">chat</span><span class="pl-k">:</span> <span class="pl-k">function</span> (<span class="pl-smi">m</span>, <span class="pl-smi">e</span>) {
    <span class="pl-en">addEntry</span>({ id<span class="pl-k">:</span> <span class="pl-smi">m</span>.<span class="pl-c1">id</span>, userId<span class="pl-k">:</span> <span class="pl-smi">m</span>.<span class="pl-smi">fromUserId</span>, userName<span class="pl-k">:</span> <span class="pl-smi">m</span>.<span class="pl-smi">fromName</span>, msg<span class="pl-k">:</span> <span class="pl-smi">m</span>.<span class="pl-smi">message</span>, 
               cls<span class="pl-k">:</span> <span class="pl-smi">m</span>.<span class="pl-smi">private</span> <span class="pl-k">?</span> <span class="pl-s"><span class="pl-pds">'</span> private<span class="pl-pds">'</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span> });
}
</pre></div>

<h3>
<a id="user-content-specifying-a-selector" class="anchor" href="#specifying-a-selector" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Specifying a selector</h3>

<p>You can specify to use an alternative selector by prefixing the message with a <code>/{selector}</code>, e.g: </p>

<pre><code>/cmd.announce This is your captain speaking ...
</code></pre>

<p>When a selector is specified in Chat it routes the message to the <code>/channels/{Channel}/raw</code> Service which passes the raw message through as a string. Normal Chat entries are instead posted to the <code>/channels/{Channel}/chat</code> Service, adding additional metadata to the chat message with the user id and name of the sender so it can be displayed in the chat log. The Javascript code that calls both Services is simply: </p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">if</span> (msg[<span class="pl-c1">0</span>] <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>/<span class="pl-pds">"</span></span>) {
    parts <span class="pl-k">=</span> <span class="pl-smi">$</span>.<span class="pl-smi">ss</span>.<span class="pl-en">splitOnFirst</span>(msg, <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span>);
    <span class="pl-smi">$</span>.<span class="pl-en">post</span>(<span class="pl-s"><span class="pl-pds">"</span>/channels/@channel/raw<span class="pl-pds">"</span></span>, 
        { from<span class="pl-k">:</span> <span class="pl-smi">activeSub</span>.<span class="pl-c1">id</span>, toUserId<span class="pl-k">:</span> to, message<span class="pl-k">:</span> parts[<span class="pl-c1">1</span>], selector<span class="pl-k">:</span> parts[<span class="pl-c1">0</span>].<span class="pl-c1">substring</span>(<span class="pl-c1">1</span>) });
} <span class="pl-k">else</span> {
    <span class="pl-smi">$</span>.<span class="pl-en">post</span>(<span class="pl-s"><span class="pl-pds">"</span>/channels/@channel/chat<span class="pl-pds">"</span></span>, 
        { from<span class="pl-k">:</span> <span class="pl-smi">activeSub</span>.<span class="pl-c1">id</span>, toUserId<span class="pl-k">:</span> to, message<span class="pl-k">:</span> msg, selector<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>cmd.chat<span class="pl-pds">"</span></span> });
}</pre></div>

<h3>
<a id="user-content-sending-a-message-to-a-specific-user" class="anchor" href="#sending-a-message-to-a-specific-user" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Sending a message to a specific user</h3>

<p>Another special syntax supported in Chat is the ability to send messages to other users by prefixing it with <code>@</code> followed by the username, e.g:</p>

<pre><code>@mythz this is a private message
@mythz /tv.watch http://youtu.be/518XP8prwZo
</code></pre>

<p>There's also a special <code>@me</code> alias to send a message to yourself, e.g:</p>

<pre><code>@me /tv.watch http://youtu.be/518XP8prwZo
</code></pre>

<h2>
<a id="user-content-server-event-services" class="anchor" href="#server-event-services" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Server Event Services</h2>

<p>By default ServiceStack doesn't expose any Services that can send notifications to other users by default.  It's left up to your application as to what functionality and level of granularity should be enabled for your Application. Your Services can send notifications via the <code>IServerEvents</code> provider.</p>

<p>Below is the annotated implementation for both Web Services used by Chat. The <code>PostRawToChannel</code> is a simple implementation that just relays the message sent to all users in the channel or just a specific user if <code>ToUserId</code> parameter is specified.</p>

<p>The <code>PostChatToChannel</code> Service is used for sending Chat messages which sends a wrapped <code>ChatMessage</code> DTO instead that holds additional metadata about the message that the Chat UI requires:</p>

<div class="highlight highlight-source-cs"><pre>[Route(<span class="pl-s"><span class="pl-pds">"</span>/channels/{Channel}/chat<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">PostChatToChannel</span> : <span class="pl-k">IReturn</span>&lt;<span class="pl-k">ChatMessage</span>&gt;
{
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">From</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">ToUserId</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Channel</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Message</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Selector</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}

[Route(<span class="pl-s"><span class="pl-pds">"</span>/channels/{Channel}/raw<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">PostRawToChannel</span> : <span class="pl-k">IReturnVoid</span>
{
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">From</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">ToUserId</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Channel</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Message</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Selector</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">ServerEventsServices</span> : <span class="pl-k">Service</span>
{
    <span class="pl-k">public</span> IServerEvents <span class="pl-en">ServerEvents</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> IChatHistory <span class="pl-en">ChatHistory</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> IAppSettings <span class="pl-en">AppSettings</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Any</span>(<span class="pl-k">PostRawToChannel</span> <span class="pl-smi">request</span>)
    {
        <span class="pl-k">if</span> (!IsAuthenticated &amp;&amp; AppSettings.Get(<span class="pl-s"><span class="pl-pds">"</span>LimitRemoteControlToAuthenticatedUsers<span class="pl-pds">"</span></span>, <span class="pl-c1">false</span>))
            <span class="pl-k">throw</span> <span class="pl-k">new</span> HttpError(HttpStatusCode.Forbidden, <span class="pl-s"><span class="pl-pds">"</span>You must be authenticated to use remote control.<span class="pl-pds">"</span></span>);

        <span class="pl-c">// Ensure the subscription sending this notification is still active</span>
        <span class="pl-k">var</span> sub = ServerEvents.GetSubscriptionInfo(request.From);
        <span class="pl-k">if</span> (sub == <span class="pl-c1">null</span>)
            <span class="pl-k">throw</span> HttpError.NotFound(<span class="pl-s"><span class="pl-pds">"</span>Subscription {0} does not exist<span class="pl-pds">"</span></span>.Fmt(request.From));

        <span class="pl-c">// Check to see if this is a private message to a specific user</span>
        <span class="pl-k">if</span> (request.ToUserId != <span class="pl-c1">null</span>)
        {
            <span class="pl-c">// Only notify that specific user</span>
            ServerEvents.NotifyUserId(request.ToUserId, request.Selector, request.Message);
        }
        <span class="pl-k">else</span>
        {
            <span class="pl-c">// Notify everyone in the channel for public messages</span>
            ServerEvents.NotifyChannel(request.Channel, request.Selector, request.Message);
        }
    }

    <span class="pl-k">public</span> <span class="pl-k">object</span> <span class="pl-en">Any</span>(<span class="pl-k">PostChatToChannel</span> <span class="pl-smi">request</span>)
    {
        <span class="pl-c">// Ensure the subscription sending this notification is still active</span>
        <span class="pl-k">var</span> sub = ServerEvents.GetSubscriptionInfo(request.From);
        <span class="pl-k">if</span> (sub == <span class="pl-c1">null</span>)
            <span class="pl-k">throw</span> HttpError.NotFound(<span class="pl-s"><span class="pl-pds">"</span>Subscription {0} does not exist<span class="pl-pds">"</span></span>.Fmt(request.From));

        <span class="pl-k">var</span> channel = request.Channel;

        <span class="pl-c">// Create a DTO ChatMessage to hold all required info about this message</span>
        <span class="pl-k">var</span> msg = <span class="pl-k">new</span> ChatMessage
        {
            Id = ChatHistory.GetNextMessageId(channel),
            FromUserId = sub.UserId,
            FromName = sub.DisplayName,
            Message = request.Message,
        };

        <span class="pl-c">// Check to see if this is a private message to a specific user</span>
        <span class="pl-k">if</span> (request.ToUserId != <span class="pl-c1">null</span>)
        {
            <span class="pl-c">// Mark the message as private so it can be displayed differently in Chat</span>
            msg.Private = <span class="pl-c1">true</span>;
            <span class="pl-c">// Send the message to the specific user Id</span>
            ServerEvents.NotifyUserId(request.ToUserId, request.Selector, msg);

            <span class="pl-c">// Also provide UI feedback to the user sending the private message so they</span>
            <span class="pl-c">// can see what was sent. Relay it to all senders active subscriptions </span>
            <span class="pl-k">var</span> toSubs = ServerEvents.GetSubscriptionInfosByUserId(request.ToUserId);
            <span class="pl-k">foreach</span> (<span class="pl-k">var</span> toSub <span class="pl-k">in</span> toSubs)
            {
                <span class="pl-c">// Change the message format to contain who the private message was sent to</span>
                msg.Message = <span class="pl-s"><span class="pl-pds">"</span>@{0}: {1}<span class="pl-pds">"</span></span>.Fmt(toSub.DisplayName, msg.Message);
                ServerEvents.NotifySubscription(request.From, request.Selector, msg);
            }
        }
        <span class="pl-k">else</span>
        {
            <span class="pl-c">// Notify everyone in the channel for public messages</span>
            ServerEvents.NotifyChannel(request.Channel, request.Selector, msg);
        }

        <span class="pl-k">if</span> (!msg.Private)
            ChatHistory.Log(channel, msg);

        <span class="pl-k">return</span> msg;
    }
}</pre></div>

<h2>
<a id="user-content-updating-channels-on-live-subscriptions" class="anchor" href="#updating-channels-on-live-subscriptions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Updating Channels on Live Subscriptions</h2>

<p>You can update a live Server Events connection with Channels you want to Join or Leave using the 
built-in ServerEvents <code>UpdateEventSubscriber</code> Service:</p>

<div class="highlight highlight-source-cs"><pre>[Route(<span class="pl-s"><span class="pl-pds">"</span>/event-subscribers/{Id}<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>POST<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">UpdateEventSubscriber</span> : <span class="pl-k">IReturn</span>&lt;<span class="pl-k">UpdateEventSubscriberResponse</span>&gt;
{
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Id</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-k">string</span>[] <span class="pl-en">SubscribeChannels</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-k">string</span>[] <span class="pl-en">UnsubscribeChannels</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}</pre></div>

<p>This lets you modify your active subscription with channels you want to join or leave with a HTTP POST Request, e.g:</p>

<pre><code>POST /event-subscribers/{subId}
SubscribeChannels=chan1,chan2&amp;UnsubscribeChannels=chan3,chan4
</code></pre>

<h3>
<a id="user-content-onupdate-notification" class="anchor" href="#onupdate-notification" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>onUpdate Notification</h3>

<p>As this modifies the active subscription it also publishes a new <strong>onUpdate</strong> notification to all channel 
subscribers so they're able to maintain up-to-date info on each subscriber. </p>

<p>In C# <code>ServerEventsClient</code> this can be handled together with <strong>onJoin</strong> and <strong>onLeave</strong> events using <code>OnCommand</code>:</p>

<div class="highlight highlight-source-cs"><pre>client.OnCommand = msg =&gt; ...; <span class="pl-c">//= ServerEventJoin, ServerEventLeave or ServerEventUpdate</span></pre></div>

<p>In the ss-utils JavaScript Client this can be handled with a Global Event Handler, e.g:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-en">$</span>(source).<span class="pl-en">handleServerEvents</span>({
    handlers<span class="pl-k">:</span> {
        <span class="pl-en">onConnect</span><span class="pl-k">:</span> <span class="pl-smi">connectedUserInfo</span> <span class="pl-k">=&gt;</span> { <span class="pl-k">...</span> },
        <span class="pl-en">onJoin</span><span class="pl-k">:</span> <span class="pl-smi">userInfo</span> <span class="pl-k">=&gt;</span> { <span class="pl-k">...</span> },
        <span class="pl-en">onLeave</span><span class="pl-k">:</span> <span class="pl-smi">userInfo</span> <span class="pl-k">=&gt;</span> { <span class="pl-k">...</span> },
        <span class="pl-en">onUpdate</span><span class="pl-k">:</span> <span class="pl-smi">userInfo</span> <span class="pl-k">=&gt;</span> { <span class="pl-k">...</span> }
    }
});</pre></div>

<h3>
<a id="user-content-serverevents-update-channel-apis" class="anchor" href="#serverevents-update-channel-apis" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>ServerEvents Update Channel APIs</h3>

<p>Whilst internally, from within ServiceStack you can update a channel's subscription using the
<a href="https://github.com/ServiceStack/ServiceStack/blob/b9a33c34d0b0eedbcc6b3483257f1dc37bbf713f/src/ServiceStack/ServerEventsFeature.cs#L1004">IServerEvents</a> APIs:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">interface</span> <span class="pl-en">IServerEvents</span> 
{
    ...
    <span class="pl-k">void</span> <span class="pl-en">SubscribeToChannels</span>(<span class="pl-k">string</span> <span class="pl-smi">subscriptionId</span>, <span class="pl-k">string[]</span> <span class="pl-smi">channels</span>);
    <span class="pl-k">void</span> <span class="pl-en">UnsubscribeFromChannels</span>(<span class="pl-k">string</span> <span class="pl-smi">subscriptionId</span>, <span class="pl-k">string[]</span> <span class="pl-smi">channels</span>);
}</pre></div>

<h2>
<a id="user-content-troubleshooting" class="anchor" href="#troubleshooting" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Troubleshooting</h2>

<h3>
<a id="user-content-response-buffering-delaying-events" class="anchor" href="#response-buffering-delaying-events" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Response Buffering delaying events</h3>

<p>If your web server is configured to automatically buffer the response it will delay when the <a href="http://stackoverflow.com/a/25983774/85785">Server Events get sent to the client</a>. In IIS Express you can disable buffering by disabling compression for dynamic requests by adding this to your <strong>Web.config</strong>:</p>

<div class="highlight highlight-text-xml"><pre>&lt;<span class="pl-ent">system</span>.webServer&gt;
   &lt;<span class="pl-ent">urlCompression</span> <span class="pl-e">doStaticCompression</span>=<span class="pl-s"><span class="pl-pds">"</span>true<span class="pl-pds">"</span></span> <span class="pl-e">doDynamicCompression</span>=<span class="pl-s"><span class="pl-pds">"</span>false<span class="pl-pds">"</span></span> /&gt;
&lt;/<span class="pl-ent">system</span>.webServer&gt;</pre></div>

<p>Alternatively you can switch to use Visual Studio Development Server which doesn't buffer by default.</p>

<h1>
<a id="user-content-serverevent-examples" class="anchor" href="#serverevent-examples" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>ServerEvent Examples</h1>

<h2>
<a id="user-content-react-chat" class="anchor" href="#react-chat" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a href="https://github.com/ServiceStackApps/ReactChat">React Chat</a>
</h2>

<p>React Chat is a port of <a href="https://github.com/ServiceStackApps/Chat">ServiceStack Chat</a> ES5, jQuery Server Events 
demo into a <a href="http://www.typescriptlang.org/">TypeScript</a>, <a href="http://facebook.github.io/react/">React</a> and 
<a href="https://github.com/reactjs/redux">Redux</a> App:</p>

<p><a href="http://react-chat.servicestack.net/"><img src="https://raw.githubusercontent.com/ServiceStack/Assets/master/img/livedemos/chat-react/screenshot.png" alt="" style="max-width:100%;"></a></p>

<h2>
<a id="user-content-xamarinandroid-chat" class="anchor" href="#xamarinandroid-chat" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a href="https://github.com/ServiceStackApps/AndroidXamarinChat">Xamarin.Android Chat</a>
</h2>

<p>Xamarin.Android Chat utilizes the 
<a href="https://github.com/ServiceStack/ServiceStack/wiki/C%23-Server-Events-Client">.NET PCL Server Events Client</a>
to create an Android Chat App connecting to the existing 
<a href="http://chat.servicestack.net/">chat.servicestack.net</a> Server Events back-end where it's able to communicate 
with existing Ajax clients and other connected Android Chat Apps. </p>

<p><a href="https://www.youtube.com/watch?v=tImAm2LURu0"><img src="https://raw.githubusercontent.com/ServiceStack/Assets/master/img/livedemos/xamarin-android-server-events.png" alt="" style="max-width:100%;"></a></p>

<blockquote>
<p><a href="https://www.youtube.com/watch?v=tImAm2LURu0">YouTube Video</a> and <a href="https://github.com/ServiceStackApps/AndroidXamarinChat">AndroidXamarinChat Repo</a></p>
</blockquote>

<h2>
<a id="user-content-networked-time-traveller-shape-creator" class="anchor" href="#networked-time-traveller-shape-creator" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a href="https://github.com/ServiceStackApps/typescript-redux#example-9---real-time-networked-time-traveller">Networked Time Traveller Shape Creator</a>
</h2>

<p>A network-enhanced version of the
<a href="https://github.com/ServiceStackApps/typescript-redux#example-8---time-travelling-using-state-snapshots">stand-alone Time Traveller Shape Creator</a>
that allows users to <strong>connect to</strong> and <strong>watch</strong> other users using the App in real-time similar 
to how users can use Remote Desktop to watch another computer's screen: </p>

<p><a href="http://redux.servicestack.net"><img src="https://raw.githubusercontent.com/ServiceStack/Assets/master/img/livedemos/redux-chrome-safari.png" alt="" style="max-width:100%;"></a></p>

<blockquote>
<p>Live demo: <a href="http://redux.servicestack.net">http://redux.servicestack.net</a></p>
</blockquote>

<h2>
<a id="user-content-chat" class="anchor" href="#chat" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a href="https://github.com/ServiceStackApps/Chat">Chat</a>
</h2>

<blockquote>
<p>Feature-rich Single Page Chat App, showcasing Server Events support in 170 lines of JavaScript!</p>
</blockquote>

<p><a href="http://chat.servicestack.net"><img src="https://raw.githubusercontent.com/ServiceStack/Assets/master/img/livedemos/chat.png" alt="" style="max-width:100%;"></a></p>

<h2>
<a id="user-content-react-chat-desktop" class="anchor" href="#react-chat-desktop" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a href="https://github.com/ServiceStackApps/ReactChatApps">React Chat Desktop</a>
</h2>

<blockquote>
<p>Built with <a href="https://github.com/ServiceStackApps/ReactDesktopApps">React Desktop Apps</a>
VS.NET template and packaged into a native Desktop App for Windows and OSX - showcasing synchronized 
real-time control of multiple Windows Apps:</p>
</blockquote>

<p><a href="https://youtu.be/-9kVqdPbqOM"><img src="https://raw.githubusercontent.com/ServiceStack/Assets/master/img/livedemos/react-desktop-apps/dancing-windows.png" alt="" style="max-width:100%;"></a></p>

<blockquote>
<p>Downloads for <a href="https://github.com/ServiceStackApps/ReactChatApps#downloads">Windows, OSX, Linux and Web</a></p>
</blockquote>
