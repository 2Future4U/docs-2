<p><a href="https://raw.githubusercontent.com/ServiceStack/Assets/master/img/release-notes/swift-logo-banner.jpg" target="_blank"><img src="https://raw.githubusercontent.com/ServiceStack/Assets/master/img/release-notes/swift-logo-banner.jpg" alt="Swift iOS, XCode and OSX Banner" style="max-width:100%;"></a></p>

<h2>
<a id="user-content-swift-20--xcode-7" class="anchor" href="#swift-20--xcode-7" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Swift 2.0 / Xcode 7</h2>

<p>ServiceStack's <strong>Add ServiceStack Reference</strong> feature lets iOS/OSX developers generate an native typed Swift 2.0 API for your ServiceStack Services directly from within XCode using the new <a href="https://github.com/ServiceStack/ServiceStack.Swift/raw/master/dist/ServiceStackXcode.dmg">ServiceStack XCode Plugin</a> - providing a simpler, cleaner and more versatile alternative to WCF's Add Service Reference feature that reduces the burden and effort required for consuming ServiceStack Services whilst benefiting from Swift's strong-typing feedback: </p>

<h2>
<a id="user-content-download-servicestack-xcode-7-plugin" class="anchor" href="#download-servicestack-xcode-7-plugin" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Download ServiceStack Xcode 7 Plugin</h2>

<p><a href="https://github.com/ServiceStack/ServiceStack.Swift/raw/master/dist/ServiceStackXcode.dmg"><img src="https://raw.githubusercontent.com/ServiceStack/Assets/master/img/release-notes/servicestackxcode-dmg.png" alt="ServiceStackXCode.dmg download" style="max-width:100%;"></a></p>

<p>The ServiceStack XCode Plugin can be installed by dragging it to the XCode Plugins directory:</p>

<p><a href="https://raw.githubusercontent.com/ServiceStack/Assets/master/img/release-notes/servicestackxcode-installer.png" target="_blank"><img src="https://raw.githubusercontent.com/ServiceStack/Assets/master/img/release-notes/servicestackxcode-installer.png" alt="ServiceStackXCode.dmg Installer" style="max-width:100%;"></a></p>

<p>Once installed, developers can easily add a reference to a remote ServiceStack instance and update its typed DTO's using the new Menu options in XCode's Main Menu:</p>

<h3>
<a id="user-content-add-servicestack-reference" class="anchor" href="#add-servicestack-reference" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>[[Add ServiceStack Reference]]</h3>

<p><a href="https://raw.githubusercontent.com/ServiceStack/Assets/master/img/release-notes/xcode-add-reference.png" target="_blank"><img src="https://raw.githubusercontent.com/ServiceStack/Assets/master/img/release-notes/xcode-add-reference.png" alt="XCode Add Reference" style="max-width:100%;"></a></p>

<p>Use the <strong>Add ServiceStack Reference</strong> Menu option to bring up the Add Reference XCode UI Sheet, which just like the Popup Window in VS.NET just needs the Url for your remote ServiceStack instance and the name of the file the generated Swift DTO's should be saved to:</p>

<p><a href="https://raw.githubusercontent.com/ServiceStack/Assets/master/img/release-notes/xcode-add-reference-sheet.png" target="_blank"><img src="https://raw.githubusercontent.com/ServiceStack/Assets/master/img/release-notes/xcode-add-reference-sheet.png" alt="XCode Add Reference Sheet" style="max-width:100%;"></a></p>

<p>After clicking <strong>Add Reference</strong>, 2 files will be added to your XCode project yielding an instant typed API:</p>

<ul>
<li>
<code>JsonServiceClient.swift</code> - A Swift JSON ServiceClient with API's based on that of <a href="https://github.com/ServiceStack/ServiceStack/wiki/C%23-client">the .NET JsonServiceClient</a>
</li>
<li>
<code>{FileName}.dtos.swift</code> - Your Services DTO Types converted in Swift</li>
</ul>

<h3>
<a id="user-content-update-servicestack-reference" class="anchor" href="#update-servicestack-reference" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Update ServiceStack Reference</h3>

<p>You can also customize how the Swift types are generated by uncommenting the desired option with the behavior you want, then click the <strong>Update ServiceStack Reference</strong> Main Menu item to fetch the latest DTO's with the updated options as seen below:</p>

<p><a href="https://raw.githubusercontent.com/ServiceStack/Assets/master/img/release-notes/xcode-update-reference.png" target="_blank"><img src="https://raw.githubusercontent.com/ServiceStack/Assets/master/img/release-notes/xcode-update-reference.png" alt="XCode Update Reference" style="max-width:100%;"></a></p>

<h3>
<a id="user-content-change-default-server-configuration" class="anchor" href="#change-default-server-configuration" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Change Default Server Configuration</h3>

<p>The above defaults are also overridable on the ServiceStack Server by modifying the default config on the <code>NativeTypesFeature</code> Plugin, e.g:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> typesConfig = <span class="pl-c1">this</span>.GetPlugin&lt;NativeTypesFeature&gt;().MetadataTypesConfig;
typesConfig.AddResponseStatus = <span class="pl-c1">true</span>;</pre></div>

<p>More Swift-specific configuration is available on the <code>SwiftGenerator</code> class itself, e.g:</p>

<div class="highlight highlight-source-cs"><pre>SwiftGenerator.DefaultImports.Add(<span class="pl-s"><span class="pl-pds">"</span>UIKit<span class="pl-pds">"</span></span>);</pre></div>

<h2>
<a id="user-content-swift-configuration" class="anchor" href="#swift-configuration" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Swift Configuration</h2>

<p>The header comments in the generated DTO's allows for further customization of how the DTO's are generated which can then be updated with any custom Options provided using the <strong>Update ServiceStack Reference</strong> Menu Item in XCode. Options that are preceded by a Swift single line comment <code>//</code> are defaults from the server that can be overridden, e.g:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">/* Options:</span>
<span class="pl-c">Date: 2015-02-22 13:52:26</span>
<span class="pl-c">Version: 1</span>
<span class="pl-c">BaseUrl: http://techstacks.io</span>
<span class="pl-c"></span>
<span class="pl-c">//BaseClass: </span>
<span class="pl-c">//AddModelExtensions: True</span>
<span class="pl-c">//AddServiceStackTypes: True</span>
<span class="pl-c">//IncludeTypes: </span>
<span class="pl-c">//ExcludeTypes: </span>
<span class="pl-c">//ExcludeGenericBaseTypes: True</span>
<span class="pl-c">//AddResponseStatus: False</span>
<span class="pl-c">//AddImplicitVersion: </span>
<span class="pl-c">//InitializeCollections: True</span>
<span class="pl-c">//DefaultImports: Foundation</span>
<span class="pl-c">*/</span></pre></div>

<p>To override a value, remove the <code>//</code> and specify the value to the right of the <code>:</code>. Any value uncommented will be sent to the server to override any server defaults.</p>

<p>We'll go through and cover each of the above options to see how they affect the generated DTO's:</p>

<h3>
<a id="user-content-baseclass" class="anchor" href="#baseclass" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>BaseClass</h3>

<p>Specify a base class that's inherited by all Swift DTO's, e.g. to enable <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html">Key-Value Observing (KVO)</a> in the generated DTO models have all types inherit from <code>NSObject</code>:</p>

<pre><code>/* Options:
BaseClass: NSObject
</code></pre>

<p>Will change all DTO types to inherit from <code>NSObject</code>:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> UserInfo <span class="pl-k">:</span> NSObject { <span class="pl-k">...</span> }</pre></div>

<h3>
<a id="user-content-addmodelextensions" class="anchor" href="#addmodelextensions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>AddModelExtensions</h3>

<p>Remove the the code-generated type extensions required to support typed JSON serialization of the Swift types and leave only the clean Swift DTO Type definitions.</p>

<pre><code>/* Options:
AddModelExtensions: False
</code></pre>

<h3>
<a id="user-content-addservicestacktypes" class="anchor" href="#addservicestacktypes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>AddServiceStackTypes</h3>

<p>Don't generate the types for built-in ServiceStack classes and Services like <code>ResponseStatus</code> and <code>Authenticate</code>, etc.</p>

<pre><code>/* Options:
AddServiceStackTypes: False
</code></pre>

<h3>
<a id="user-content-includetypes" class="anchor" href="#includetypes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>IncludeTypes</h3>

<p>Is used as a Whitelist that can be used to specify only the types you would like to have code-generated:</p>

<pre><code>/* Options:
IncludeTypes: GetTechnology,GetTechnologyResponse
</code></pre>

<p>Will only generate <code>GetTechnology</code> and <code>GetTechnologyResponse</code> DTO's:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> GetTechnology { <span class="pl-k">...</span> }
<span class="pl-k">public</span> <span class="pl-k">class</span> GetTechnologyResponse { <span class="pl-k">...</span> }</pre></div>

<h3>
<a id="user-content-excludetypes" class="anchor" href="#excludetypes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>ExcludeTypes</h3>

<p>Is used as a Blacklist where you can specify which types you would like to exclude from being generated:</p>

<pre><code>/* Options:
ExcludeTypes: GetTechnology,GetTechnologyResponse
</code></pre>

<p>Will exclude <code>GetTechnology</code> and <code>GetTechnologyResponse</code> DTO's from being generated.</p>

<h3>
<a id="user-content-excludegenericbasetypes" class="anchor" href="#excludegenericbasetypes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>ExcludeGenericBaseTypes</h3>

<p>Work around a <a href="https://github.com/ServiceStack/ServiceStack/blob/master/docs/2015/release-notes.md#swift-native-types-upgraded-to-swift-12">regression added in Swift 1.2</a> where the Swift compiler segfaults trying to compile Extensions to Types with a Generic Base Class. You can omit the problematic Generic Base Types from being generated with:</p>

<div class="highlight highlight-source-swift"><pre>ExcludeGenericBaseTypes: True</pre></div>

<p>Any types that were omitted from the generated DTO's will be emitted in comments, using the format:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">//Excluded: {TypeName}</span></pre></div>

<h3>
<a id="user-content-addresponsestatus" class="anchor" href="#addresponsestatus" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>AddResponseStatus</h3>

<p>Automatically add a <code>ResponseStatus</code> property on all Response DTO's, regardless if it wasn't already defined:</p>

<pre><code>/* Options:
AddResponseStatus: True
</code></pre>

<p>Will add a <code>ResponseStatus</code> property to all Response DTO's:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> GetAllTechnologiesResponse
{
    <span class="pl-k">...</span>
    <span class="pl-k">public</span> <span class="pl-k">var</span> responseStatus:ResponseStatus
}</pre></div>

<h3>
<a id="user-content-addimplicitversion" class="anchor" href="#addimplicitversion" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>AddImplicitVersion</h3>

<p>Lets you specify the Version number to be automatically populated in all Request DTO's sent from the client: </p>

<pre><code>/* Options:
AddImplicitVersion: 1
</code></pre>

<p>Will add an initialized <code>version</code> property to all Request DTO's:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> GetAllTechnologies <span class="pl-k">:</span> IReturn
{
    <span class="pl-k">...</span>
    <span class="pl-k">public</span> <span class="pl-k">var</span> version:<span class="pl-c1">Int</span> <span class="pl-k">=</span> <span class="pl-c1">1</span>
}</pre></div>

<p>This lets you know what Version of the Service Contract that existing clients are using making it easy to implement ServiceStack's <a href="http://stackoverflow.com/a/12413091/85785">recommended versioning strategy</a>. </p>

<h3>
<a id="user-content-initializecollections" class="anchor" href="#initializecollections" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>InitializeCollections</h3>

<p>Whether enumerables should be initialized with an empty collection (default) or changed to use an Optional type:</p>

<pre><code>/* Options:
InitializeCollections: False
</code></pre>

<p>Changes Collection Definitions to be declared as Optional Types instead of being initialized with an empty collection:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> ResponseStatus
{
    <span class="pl-k">public</span> <span class="pl-k">var</span> errors:[ResponseError]?
}</pre></div>

<h3>
<a id="user-content-defaultimports" class="anchor" href="#defaultimports" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>DefaultImports</h3>

<p>Add additional import statements to the generated DTO's:</p>

<pre><code>/* Options:
DefaultImports: UIKit,Foundation
</code></pre>

<p>Will import the <code>UIKit</code> and <code>Foundation</code> frameworks:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">import</span> <span class="pl-c1">UIKit</span>;
<span class="pl-k">import</span> <span class="pl-c1">Foundation</span>;</pre></div>

<h1>
<a id="user-content-swift-client-usage" class="anchor" href="#swift-client-usage" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Swift Client Usage</h1>

<h2>
<a id="user-content-jsonserviceclientswift" class="anchor" href="#jsonserviceclientswift" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a href="https://github.com/ServiceStack/ServiceStack.Swift/blob/master/dist/JsonServiceClient.swift">JsonServiceClient.swift</a>
</h2>

<p>The same ideal, high-level API available in <a href="https://github.com/ServiceStack/ServiceStack/wiki/C%23-client">.NET's ServiceClients</a> have been translated into idiomatic Swift as seen with its <code>ServiceClient</code> protocol definition below:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">public</span> <span class="pl-k">protocol</span> ServiceClient
{
    <span class="pl-k">func</span> <span class="pl-en">get</span>(request:T) throws <span class="pl-k">-&gt;</span> T.Return
    <span class="pl-k">func</span> <span class="pl-en">get</span>(request:T) throws <span class="pl-k">-&gt;</span> <span class="pl-c1">Void</span>
    <span class="pl-k">func</span> <span class="pl-en">get</span>(request:T, query:[<span class="pl-c1">String</span>:<span class="pl-c1">String</span>]) throws <span class="pl-k">-&gt;</span> T.Return
    <span class="pl-k">func</span> <span class="pl-en">get</span>(relativeUrl:<span class="pl-c1">String</span>) throws <span class="pl-k">-&gt;</span> T
    <span class="pl-k">func</span> <span class="pl-en">getAsync</span>(request:T) <span class="pl-k">-&gt;</span> Promise&lt;T.Return&gt;
    <span class="pl-k">func</span> <span class="pl-en">getAsync</span>(request:T) <span class="pl-k">-&gt;</span> Promise&lt;<span class="pl-c1">Void</span>&gt;
    <span class="pl-k">func</span> <span class="pl-en">getAsync</span>(request:T, query:[<span class="pl-c1">String</span>:<span class="pl-c1">String</span>]) <span class="pl-k">-&gt;</span> Promise&lt;T.Return&gt;
    <span class="pl-k">func</span> <span class="pl-en">getAsync</span>(relativeUrl:<span class="pl-c1">String</span>) <span class="pl-k">-&gt;</span> Promise&lt;T&gt;

    <span class="pl-k">func</span> <span class="pl-en">post</span>(request:T) throws <span class="pl-k">-&gt;</span> T.Return
    <span class="pl-k">func</span> <span class="pl-en">post</span>(request:T) throws <span class="pl-k">-&gt;</span> <span class="pl-c1">Void</span>
    <span class="pl-k">func</span> <span class="pl-en">post</span>(relativeUrl:<span class="pl-c1">String</span>, request:Request?) throws <span class="pl-k">-&gt;</span> Response
    <span class="pl-k">func</span> <span class="pl-en">postAsync</span>(request:T) <span class="pl-k">-&gt;</span> Promise&lt;T.Return&gt;
    <span class="pl-k">func</span> <span class="pl-en">postAsync</span>(request:T) <span class="pl-k">-&gt;</span> Promise&lt;<span class="pl-c1">Void</span>&gt;
    <span class="pl-k">func</span> <span class="pl-en">postAsync</span>(relativeUrl:<span class="pl-c1">String</span>, request:Request?) <span class="pl-k">-&gt;</span> Promise&lt;Response&gt;

    <span class="pl-k">func</span> <span class="pl-en">put</span>(request:T) throws <span class="pl-k">-&gt;</span> T.Return
    <span class="pl-k">func</span> <span class="pl-en">put</span>(request:T) throws <span class="pl-k">-&gt;</span> <span class="pl-c1">Void</span>
    <span class="pl-k">func</span> <span class="pl-en">put</span>(relativeUrl:<span class="pl-c1">String</span>, request:Request?) throws <span class="pl-k">-&gt;</span> Response
    <span class="pl-k">func</span> <span class="pl-en">putAsync</span>(request:T) <span class="pl-k">-&gt;</span> Promise&lt;T.Return&gt;
    <span class="pl-k">func</span> <span class="pl-en">putAsync</span>(request:T) <span class="pl-k">-&gt;</span> Promise&lt;<span class="pl-c1">Void</span>&gt;
    <span class="pl-k">func</span> <span class="pl-en">putAsync</span>(relativeUrl:<span class="pl-c1">String</span>, request:Request?) <span class="pl-k">-&gt;</span> Promise&lt;Response&gt;

    <span class="pl-k">func</span> <span class="pl-en">delete</span>(request:T) throws <span class="pl-k">-&gt;</span> T.Return
    <span class="pl-k">func</span> <span class="pl-en">delete</span>(request:T) throws <span class="pl-k">-&gt;</span> <span class="pl-c1">Void</span>
    <span class="pl-k">func</span> <span class="pl-en">delete</span>(request:T, query:[<span class="pl-c1">String</span>:<span class="pl-c1">String</span>]) throws <span class="pl-k">-&gt;</span> T.Return
    <span class="pl-k">func</span> <span class="pl-en">delete</span>(relativeUrl:<span class="pl-c1">String</span>) throws <span class="pl-k">-&gt;</span> T
    <span class="pl-k">func</span> <span class="pl-en">deleteAsync</span>(request:T) <span class="pl-k">-&gt;</span> Promise&lt;T.Return&gt;
    <span class="pl-k">func</span> <span class="pl-en">deleteAsync</span>(request:T) <span class="pl-k">-&gt;</span> Promise&lt;<span class="pl-c1">Void</span>&gt;
    <span class="pl-k">func</span> <span class="pl-en">deleteAsync</span>(request:T, query:[<span class="pl-c1">String</span>:<span class="pl-c1">String</span>]) <span class="pl-k">-&gt;</span> Promise&lt;T.Return&gt;
    <span class="pl-k">func</span> <span class="pl-en">deleteAsync</span>(relativeUrl:<span class="pl-c1">String</span>) <span class="pl-k">-&gt;</span> Promise&lt;T&gt;

    <span class="pl-k">func</span> <span class="pl-en">patch</span>(request:T) throws <span class="pl-k">-&gt;</span> T.Return
    <span class="pl-k">func</span> <span class="pl-en">patch</span>(request:T) throws <span class="pl-k">-&gt;</span> <span class="pl-c1">Void</span>
    <span class="pl-k">func</span> <span class="pl-en">patch</span>(relativeUrl:<span class="pl-c1">String</span>, request:Request?) throws <span class="pl-k">-&gt;</span> Response
    <span class="pl-k">func</span> <span class="pl-en">patchAsync</span>(request:T) <span class="pl-k">-&gt;</span> Promise&lt;T.Return&gt;
    <span class="pl-k">func</span> <span class="pl-en">patchAsync</span>(request:T) <span class="pl-k">-&gt;</span> Promise&lt;<span class="pl-c1">Void</span>&gt;
    <span class="pl-k">func</span> <span class="pl-en">patchAsync</span>(relativeUrl:<span class="pl-c1">String</span>, request:Request?) <span class="pl-k">-&gt;</span> Promise&lt;Response&gt;

    <span class="pl-k">func</span> <span class="pl-en">send</span>(request:T) throws <span class="pl-k">-&gt;</span> T.Return
    <span class="pl-k">func</span> <span class="pl-en">send</span>(request:T) throws <span class="pl-k">-&gt;</span> <span class="pl-c1">Void</span>
    <span class="pl-k">func</span> <span class="pl-en">send</span>(intoResponse:T, request:NSMutableURLRequest) throws <span class="pl-k">-&gt;</span> T
    <span class="pl-k">func</span> <span class="pl-en">sendAsync</span>(intoResponse:T, request:NSMutableURLRequest) <span class="pl-k">-&gt;</span> Promise&lt;T&gt;

    <span class="pl-k">func</span> <span class="pl-en">getData</span>(url:<span class="pl-c1">String</span>) throws <span class="pl-k">-&gt;</span> NSData
    <span class="pl-k">func</span> <span class="pl-en">getDataAsync</span>(url:<span class="pl-c1">String</span>) <span class="pl-k">-&gt;</span> Promise&lt;NSData&gt;
}</pre></div>

<blockquote>
<p>Generic type constraints omitted for readability</p>
</blockquote>

<p>The minor differences are primarily due to differences in Swift which instead of throwing Exceptions uses error codes and <code>Optional</code> return types and its lack of any asynchrony language support led us to embed a lightweight and <a href="http://promisekit.org/introduction/">well-documented Promises</a> implementation in <a href="https://github.com/mxcl/PromiseKit">PromiseKit</a> which closely matches the <code>Task&lt;T&gt;</code> type used in .NET Async API's.</p>

<h3>
<a id="user-content-jsonserviceclient-usage" class="anchor" href="#jsonserviceclient-usage" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>JsonServiceClient Usage</h3>

<p>If you've ever had to make HTTP requests using Objective-C's <code>NSURLConnection</code> or <code>NSURLSession</code> static classes in iOS or OSX, you'll appreciate the typing benefits and productivity offered by the higher-level API's in <code>JsonServiceClient</code> - which enable the same ideal client API's we've enjoyed in ServiceStack's .NET Clients, in Swift Apps! </p>

<blockquote>
<p>A nice benefit of using JsonServiceClient over static classes is that Service calls can be easily substituted and mocked with the above <code>ServiceClient</code> protocol, making it easy to test or stub out the external Gateway calls whilst the back-end is under development.</p>
</blockquote>

<p>To illustrate its usage we'll go through some client code to consume <a href="https://github.com/ServiceStackApps/TechStacks">TechStacks</a> Services after adding a <strong>ServiceStack Reference</strong> to <code>http://techstaks.io</code>:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">var</span> client <span class="pl-k">=</span> JsonServiceClient(baseUrl: <span class="pl-s"><span class="pl-pds">"</span>http://techstacks.io<span class="pl-pds">"</span></span>)
<span class="pl-k">var</span> response <span class="pl-k">=</span> client<span class="pl-k">.</span><span class="pl-k">get</span>(AppOverview())</pre></div>

<p>Essentially usage is the same as it is in .NET ServiceClients - where it just needs the <code>baseUrl</code> of the remote ServiceStack instance, which can then be used to consume remote Services by sending typed Request DTO's that respond in kind with the expected Response DTO.</p>

<h3>
<a id="user-content-async-api-usage" class="anchor" href="#async-api-usage" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Async API Usage</h3>

<p>Whilst the sync API's are easy to use their usage should be limited in background threads so they're not blocking the Apps UI whilst waiting for responses. Most of the time when calling services from the Main UI thread you'll want to use the non-blocking async API's, which for the same API looks like:</p>

<div class="highlight highlight-source-swift"><pre>client<span class="pl-k">.</span>getAsync(AppOverview())
    <span class="pl-k">.</span>then { 
        $<span class="pl-c1">0</span><span class="pl-k">.</span>topTechnologies<span class="pl-k">.</span><span class="pl-c1">count</span> <span class="pl-c">//= 100</span>
        <span class="pl-c">//... </span>
    }</pre></div>

<p>Swift 2.0 also lets you continue marking it up with explicit Type Information and optional syntax as preferred, e.g: </p>

<div class="highlight highlight-source-swift"><pre>client<span class="pl-k">.</span>getAsync(AppOverview())
    <span class="pl-k">.</span>then({ (r:AppOverviewResponse) <span class="pl-k">in</span>
        r<span class="pl-k">.</span>topTechnologies<span class="pl-k">.</span><span class="pl-c1">count</span> <span class="pl-c">//= 100</span>
        <span class="pl-c">//... </span>
    })</pre></div>

<p>Which is very similar to how we'd make async <code>Task&lt;T&gt;</code> calls in C# when not using its async/await language syntax sugar. </p>

<blockquote>
<p>Async callbacks are called back on the main thread, ideal for use in iOS Apps. This behavior is also configurable in the Promise's callback API.</p>
</blockquote>

<h3>
<a id="user-content-typed-error-handling" class="anchor" href="#typed-error-handling" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Typed Error Handling</h3>

<p>As Swift doesn't provide <code>try/catch</code> Exception Handling, Error handling is a little different in Swift which for most failable API's just returns a <code>nil</code> Optional to indicate when the operation didn't succeed. When more information about the error is required, API's will typically accept an additional <code>NSError</code> pointer argument to populate with more information about the error. Any additional metadata can be attached to NSError's <code>userInfo</code> Dictionary. We also follow this same approach to provide our structured error handling in <code>JsonServiceClient</code>.</p>

<p>To illustrate exception handling we'll connect to ServiceStack's Test Services and call the <code>ThrowType</code> Service to intentionally throw the error specified, e.g:</p>

<h4>
<a id="user-content-sync-error-handling" class="anchor" href="#sync-error-handling" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Sync Error Handling</h4>

<p>Handling a Single C# Exception:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">var</span> client <span class="pl-k">=</span> JsonServiceClient(baseUrl: <span class="pl-s"><span class="pl-pds">"</span>http://test.servicestack.net<span class="pl-pds">"</span></span>)

<span class="pl-k">var</span> request <span class="pl-k">=</span> ThrowType()
request<span class="pl-k">.</span>type <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>NotFound<span class="pl-pds">"</span></span>
request<span class="pl-k">.</span>message <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>custom message<span class="pl-pds">"</span></span>

<span class="pl-k">do</span> {
    <span class="pl-k">let</span> response <span class="pl-k">=</span> client<span class="pl-k">.</span>post(request)
} <span class="pl-k">catch</span> <span class="pl-k">var</span> error <span class="pl-k">as</span> NSError {
    error<span class="pl-k">.</span>code <span class="pl-c">//= 404</span>
    <span class="pl-c">//Convert into typed ResponseStatus</span>
    <span class="pl-k">var</span> status:ResponseStatus <span class="pl-k">=</span> error<span class="pl-k">.</span>convertUserInfo() 
    status<span class="pl-k">.</span>message <span class="pl-c">//= not here</span>
    status<span class="pl-k">.</span>stackTrace <span class="pl-c">//= Server Stack Trace</span>
}</pre></div>

<p>Handling a Validation Exception with multiple field validation errors:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> client <span class="pl-k">=</span> JsonServiceClient(baseUrl: <span class="pl-s"><span class="pl-pds">"</span>http://test.servicestack.net<span class="pl-pds">"</span></span>)

<span class="pl-k">let</span> request <span class="pl-k">=</span> ThrowValidation()
request<span class="pl-k">.</span>email <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>invalidemail<span class="pl-pds">"</span></span>

<span class="pl-k">do</span> {
    <span class="pl-k">let</span> response <span class="pl-k">=</span> <span class="pl-k">try</span> client<span class="pl-k">.</span>post(request)
} <span class="pl-k">catch</span> <span class="pl-k">let</span> responseError <span class="pl-k">as</span> NSError {    
    <span class="pl-k">let</span> status:ResponseStatus <span class="pl-k">=</span> responseError<span class="pl-k">.</span>convertUserInfo()<span class="pl-k">!</span>
    status<span class="pl-k">.</span>errors<span class="pl-k">.</span><span class="pl-c1">count</span> <span class="pl-c">//= 3</span>
    <span class="pl-k">let</span> field1 <span class="pl-k">=</span> status<span class="pl-k">.</span>errors[<span class="pl-c1">0</span>]

    field1<span class="pl-k">.</span>errorCode<span class="pl-k">!</span> <span class="pl-c">//= InclusiveBetween</span>
    field1<span class="pl-k">.</span>fieldName<span class="pl-k">!</span> <span class="pl-c">//= Age</span>
    field1<span class="pl-k">.</span>message<span class="pl-k">!</span>   <span class="pl-c">//= 'Age' must be between 1 and 120. You entered 0.</span>
}</pre></div>

<h4>
<a id="user-content-async-error-handling" class="anchor" href="#async-error-handling" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Async Error Handling</h4>

<p>To handle errors in Async API's we just add a callback on <code>.error()</code> API on the returned Promise, e.g:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> request <span class="pl-k">=</span> ThrowValidation()
request<span class="pl-k">.</span>email <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>invalidemail<span class="pl-pds">"</span></span>

client<span class="pl-k">.</span>postAsync(request)
    <span class="pl-k">.</span>error { responseError <span class="pl-k">in</span>
        <span class="pl-k">let</span> status:ResponseStatus <span class="pl-k">=</span> responseError<span class="pl-k">.</span>convertUserInfo()<span class="pl-k">!</span>
        status<span class="pl-k">.</span>errors<span class="pl-k">.</span><span class="pl-c1">count</span> <span class="pl-c">//= 3</span>
        <span class="pl-c">//...</span>
    }
</pre></div>

<h3>
<a id="user-content-jsonserviceclient-error-handlers" class="anchor" href="#jsonserviceclient-error-handlers" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>JsonServiceClient Error Handlers</h3>

<p>Just like in .NET, we can also attach Global or instance error handlers to be able to generically handle all Service Client errors with a custom handler, e.g:</p>

<div class="highlight highlight-source-swift"><pre>client<span class="pl-k">.</span>onError <span class="pl-k">=</span> {(e:NSError) <span class="pl-k">in</span> <span class="pl-k">...</span> }
JsonServiceClient<span class="pl-k">.</span>Global<span class="pl-k">.</span>onError <span class="pl-k">=</span> {(e:NSError) <span class="pl-k">in</span> <span class="pl-k">...</span> }</pre></div>

<h3>
<a id="user-content-swift-http-marker-interfaces" class="anchor" href="#swift-http-marker-interfaces" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Swift HTTP Marker Interfaces</h3>

<p>The new <code>send*</code> API's take advantage of the HTTP Verb Interface Markers described below to send the Request DTO using the 
annotated HTTP Method, e.g:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> HelloByGet <span class="pl-k">:</span> IReturn, IGet 
{
    <span class="pl-k">public</span> <span class="pl-k">typealias</span> Return <span class="pl-k">=</span> HelloResponse
    <span class="pl-k">public</span> <span class="pl-k">var</span> name:<span class="pl-c1">String</span>?
}
<span class="pl-k">public</span> <span class="pl-k">class</span> HelloByPut <span class="pl-k">:</span> IReturn, IPut 
{
    <span class="pl-k">public</span> <span class="pl-k">typealias</span> Return <span class="pl-k">=</span> HelloResponse
    <span class="pl-k">public</span> <span class="pl-k">var</span> name:<span class="pl-c1">String</span>?
}

<span class="pl-k">let</span> response <span class="pl-k">=</span> <span class="pl-k">try</span> client<span class="pl-k">.</span>send(HelloByGet())  <span class="pl-c">//GET</span>

client<span class="pl-k">.</span>sendAsync(HelloByPut())                <span class="pl-c">//PUT</span>
    <span class="pl-k">.</span>then { }</pre></div>

<h3>
<a id="user-content-custom-routes" class="anchor" href="#custom-routes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Custom Routes</h3>

<p>As Swift doesn't support Attributes any exported .NET Attributes are emitted in comments on the Request DTO they apply to, e.g:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">// @Route("/technology/{Slug}")</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> GetTechnology <span class="pl-k">:</span> IReturn { <span class="pl-k">...</span> }</pre></div>

<p>This also means that the Custom Routes aren't used when making Service Requests and instead just uses ServiceStack's built-in <a href="https://github.com/ServiceStack/ServiceStack/wiki/Routing#pre-defined-routes">pre-defined routes</a>. </p>

<p>But when preferred <code>JsonServiceClient</code> can also be used to call Services using Custom Routes, e.g:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">var</span> response:GetTechnologyResponse? <span class="pl-k">=</span> client<span class="pl-k">.</span><span class="pl-k">get</span>(<span class="pl-s"><span class="pl-pds">"</span>/technology/servicestack<span class="pl-pds">"</span></span>)</pre></div>

<blockquote>
<p>Note the explicit type definition on the return type is required here as Swift uses it as part of the generic method invocation.</p>
</blockquote>

<h3>
<a id="user-content-jsonserviceclient-options" class="anchor" href="#jsonserviceclient-options" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>JsonServiceClient Options</h3>

<p>Other options that can be configured on JsonServiceClient include:</p>

<div class="highlight highlight-source-swift"><pre>client<span class="pl-k">.</span>onError <span class="pl-k">=</span> {(e:NSError) <span class="pl-k">in</span> <span class="pl-k">...</span> }
client<span class="pl-k">.</span>timeout <span class="pl-k">=</span> <span class="pl-k">...</span>
client<span class="pl-k">.</span>cachePolicy <span class="pl-k">=</span> NSURLRequestCachePolicy<span class="pl-k">.</span>ReloadIgnoringLocalCacheData
client<span class="pl-k">.</span>requestFilter <span class="pl-k">=</span> {(req:NSMutableURLRequest) <span class="pl-k">in</span> <span class="pl-k">...</span> }
client<span class="pl-k">.</span>responseFilter <span class="pl-k">=</span> {(res:NSURLResponse) <span class="pl-k">in</span> <span class="pl-k">...</span> }

<span class="pl-c">//static Global configuration</span>
JsonServiceClient<span class="pl-k">.</span>Global<span class="pl-k">.</span>onError <span class="pl-k">=</span> {(e:NSError) <span class="pl-k">in</span> <span class="pl-k">...</span> }
JsonServiceClient<span class="pl-k">.</span>Global<span class="pl-k">.</span>requestFilter <span class="pl-k">=</span> {(req:NSMutableURLRequest) <span class="pl-k">in</span> <span class="pl-k">...</span> }
JsonServiceClient<span class="pl-k">.</span>Global<span class="pl-k">.</span>responseFilter <span class="pl-k">=</span> {(res:NSURLResponse) <span class="pl-k">in</span> <span class="pl-k">...</span> }</pre></div>

<h2>
<a id="user-content-techstacks-ios-app" class="anchor" href="#techstacks-ios-app" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>TechStacks iOS App</h2>

<p>To illustrate the ease-of-use and utility of ServiceStack's new Swift support you can checkout the TechStacks native iOS App for <a href="http://techstacks.io">http://techstacks.io</a> that has been recently published and is now available to download for free on the AppStore:</p>

<p><a href="https://itunes.apple.com/us/app/techstacks/id965680615?ls=1&amp;mt=8"><img src="https://raw.githubusercontent.com/ServiceStack/Assets/master/img/release-notes/techstacks-appstore.png" alt="TechStacks on AppStore" style="max-width:100%;"></a></p>

<p>The complete source code for the <a href="https://github.com/ServiceStackApps/TechStacks">TechStacks App is available on GitHub</a> - providing a good example on how easy it is to take advantage of ServiceStack's Swift support to quickly build a rich and responsive Services-heavy native iOS App. </p>

<p>All remote Service Calls used by the App are encapsulated into a single <a href="https://github.com/ServiceStackApps/TechStacksApp/blob/master/src/TechStacks/AppData.swift">AppData.swift</a> class and only uses JsonServiceClient's non-blocking Async API's to ensure a Responsive UI is maintained throughout the App.</p>

<h3>
<a id="user-content-mvc-and-key-value-observables-kvo" class="anchor" href="#mvc-and-key-value-observables-kvo" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>MVC and Key-Value Observables (KVO)</h3>

<p>If you've ever had to implement <code>INotifyPropertyChanged</code> in .NET, you'll find the built-in model binding capabilities in iOS/OSX a refreshing alternative thanks to Objective-C's underlying <code>NSObject</code> which automatically generates change notifications for its KV-compliant properties. UIKit and Cocoa frameworks both leverage this feature to enable its <a href="https://developer.apple.com/library/mac/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html">Model-View-Controller Pattern</a>. </p>

<p>As keeping UI's updated with Async API callbacks can get unwieldy, we wanted to go through how we're taking advantage of NSObject's KVO support in Service Responses to simplify maintaining dynamic UI's.</p>

<h3>
<a id="user-content-enable-key-value-observing-in-swift-dtos" class="anchor" href="#enable-key-value-observing-in-swift-dtos" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Enable Key-Value Observing in Swift DTO's</h3>

<p>Firstly to enable KVO in your Swift DTO's we'll want to have each DTO inherit from <code>NSObject</code> which can be done by uncommenting <code>BaseObject</code> option in the header comments as seen below:</p>

<pre><code>/* Options:
Date: 2015-02-19 22:43:04
Version: 1
BaseUrl: http://techstacks.io

BaseClass: NSObject
...
*/
</code></pre>

<p>and click the <strong>Update ServiceStack Reference</strong> Menu Option to fetch the updated DTO's.</p>

<p>Then to <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-XID_8">enable Key-Value Observing</a> just mark the response DTO variables with the <code>dynamic</code> modifier, e.g:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">public</span> <span class="pl-k">dynamic</span> <span class="pl-k">var</span> allTiers:[Option] <span class="pl-k">=</span> []
<span class="pl-k">public</span> <span class="pl-k">dynamic</span> <span class="pl-k">var</span> overview:AppOverviewResponse <span class="pl-k">=</span> AppOverviewResponse()
<span class="pl-k">public</span> <span class="pl-k">dynamic</span> <span class="pl-k">var</span> topTechnologies:[TechnologyInfo] <span class="pl-k">=</span> []
<span class="pl-k">public</span> <span class="pl-k">dynamic</span> <span class="pl-k">var</span> allTechnologies:[Technology] <span class="pl-k">=</span> []
<span class="pl-k">public</span> <span class="pl-k">dynamic</span> <span class="pl-k">var</span> allTechnologyStacks:[TechnologyStack] <span class="pl-k">=</span> []</pre></div>

<p>Which is all that's needed to allow properties to be observed as they'll automatically issue change notifications when they're populated in the Service response async callbacks, e.g:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">func</span> <span class="pl-en">loadOverview</span>() <span class="pl-k">-&gt;</span> Promise&lt;AppOverviewResponse&gt; {
    <span class="pl-k">return</span> client<span class="pl-k">.</span>getAsync(AppOverview())
        <span class="pl-k">.</span>then { r <span class="pl-k">in</span>
            <span class="pl-k">self</span><span class="pl-k">.</span>overview <span class="pl-k">=</span> r
            <span class="pl-k">self</span><span class="pl-k">.</span>allTiers <span class="pl-k">=</span> r<span class="pl-k">.</span>allTiers
            <span class="pl-k">self</span><span class="pl-k">.</span>topTechnologies <span class="pl-k">=</span> r<span class="pl-k">.</span>topTechnologies
            <span class="pl-k">return</span> r
        }
}

<span class="pl-k">func</span> <span class="pl-en">loadAllTechnologies</span>() <span class="pl-k">-&gt;</span> Promise&lt;GetAllTechnologiesResponse&gt; {
    <span class="pl-k">return</span> client<span class="pl-k">.</span>getAsync(GetAllTechnologies())
        <span class="pl-k">.</span>then { r <span class="pl-k">in</span>
            <span class="pl-k">self</span><span class="pl-k">.</span>allTechnologies <span class="pl-k">=</span> r<span class="pl-k">.</span>results
            <span class="pl-k">return</span> r
        }
}

<span class="pl-k">func</span> <span class="pl-en">loadAllTechStacks</span>() <span class="pl-k">-&gt;</span> Promise&lt;GetAllTechnologyStacksResponse&gt; {
    <span class="pl-k">return</span> client<span class="pl-k">.</span>getAsync(GetAllTechnologyStacks())
        <span class="pl-k">.</span>then { r <span class="pl-k">in</span>
            <span class="pl-k">self</span><span class="pl-k">.</span>allTechnologyStacks <span class="pl-k">=</span> r<span class="pl-k">.</span>results
            <span class="pl-k">return</span> r
        }
}</pre></div>

<h3>
<a id="user-content-observing-data-changes" class="anchor" href="#observing-data-changes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Observing Data Changes</h3>

<p>In your <a href="https://github.com/ServiceStackApps/TechStacksApp/blob/0fca564e8c06fd1b71f81faee93a2e04c70a219b/src/TechStacks/HomeViewController.swift">ViewController</a> have the datasources for your custom views binded to the desired data (which will initially be empty):</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">func</span> <span class="pl-en">pickerView</span>(pickerView: UIPickerView, <span class="pl-en">numberOfRowsInComponent</span> <span class="pl-smi">component</span>: <span class="pl-c1">Int</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">Int</span> {
    <span class="pl-k">return</span> appData<span class="pl-k">.</span>allTiers<span class="pl-k">.</span><span class="pl-c1">count</span>
}
<span class="pl-k">...</span>
<span class="pl-k">func</span> <span class="pl-en">tableView</span>(tableView: UITableView, <span class="pl-en">numberOfRowsInSection</span> <span class="pl-smi">section</span>: <span class="pl-c1">Int</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">Int</span> {
    <span class="pl-k">return</span> appData<span class="pl-k">.</span>topTechnologies<span class="pl-k">.</span><span class="pl-c1">count</span>
}</pre></div>

<p>Then in <code>viewDidLoad()</code> <a href="https://github.com/ServiceStack/ServiceStack.Swift/blob/67c5c092b92927702f33b6a0669e3aa1de0e2cdc/apps/TechStacks/TechStacks/HomeViewController.swift#L31">start observing the properties</a> your UI Controls are bound to, e.g:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">override</span> <span class="pl-k">func</span> <span class="pl-en">viewDidLoad</span>() {
    <span class="pl-k">...</span>
    <span class="pl-k">self</span><span class="pl-k">.</span>appData<span class="pl-k">.</span>observe(<span class="pl-k">self</span>, properties: [<span class="pl-s"><span class="pl-pds">"</span>topTechnologies<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>allTiers<span class="pl-pds">"</span></span>])
    <span class="pl-k">self</span><span class="pl-k">.</span>appData<span class="pl-k">.</span>loadOverview()
}
<span class="pl-k">deinit</span> { <span class="pl-k">self</span><span class="pl-k">.</span>appData<span class="pl-k">.</span>unobserve(<span class="pl-k">self</span>) }</pre></div>

<p>In the example code above we're using some custom <a href="https://github.com/ServiceStackApps/TechStacksApp/blob/0fca564e8c06fd1b71f81faee93a2e04c70a219b/src/TechStacks/AppData.swift#L159-L183">KVO helpers</a> to keep the code required to a minimum.</p>

<p>With the observable bindings in place, the change notifications of your observed properties can be handled by overriding <code>observeValueForKeyPath()</code> which passes the name of the property that's changed in the <code>keyPath</code> argument that can be used to determine the UI Controls to refresh, e.g:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">override</span> <span class="pl-k">func</span> <span class="pl-en">observeValueForKeyPath</span>(keyPath:<span class="pl-c1">String</span>, <span class="pl-en">ofObject</span> <span class="pl-smi">object</span>:<span class="pl-c1">AnyObject</span>, change:[NSObject:<span class="pl-c1">AnyObject</span>],
  context: <span class="pl-c1">UnsafeMutablePointer</span><span class="pl-k">&lt;</span><span class="pl-c1">Void</span><span class="pl-k">&gt;</span>) {
    <span class="pl-k">switch</span> keyPath {
    <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">"</span>allTiers<span class="pl-pds">"</span></span>:
        <span class="pl-k">self</span><span class="pl-k">.</span>technologyPicker<span class="pl-k">.</span>reloadAllComponents()
    <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">"</span>topTechnologies<span class="pl-pds">"</span></span>:
        <span class="pl-k">self</span><span class="pl-k">.</span>tblView<span class="pl-k">.</span>reloadData()
    <span class="pl-k">default</span>: <span class="pl-k">break</span>
    }
}</pre></div>

<p>Now that everything's configured, the observables provide an alternative to manually updating UI elements within async callbacks, instead you can now fire-and-forget your async API's and rely on the pre-configured bindings to automatically update the appropriate UI Controls when their bounded properties are updated, e.g:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">self</span><span class="pl-k">.</span>appData<span class="pl-k">.</span>loadOverview() <span class="pl-c">//Ignore response and use configured KVO Bindings</span></pre></div>

<h3>
<a id="user-content-images-and-custom-binary-requests" class="anchor" href="#images-and-custom-binary-requests" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Images and Custom Binary Requests</h3>

<p>In addition to greatly simplifying Web Service Requests, <code>JsonServiceClient</code> also makes it easy to fetch any custom HTTP response like Images and other Binary data using the generic <code>getData()</code> and <code>getDataAsync()</code> NSData API's. This is used in TechStacks to <a href="https://github.com/ServiceStackApps/TechStacksApp/blob/0fca564e8c06fd1b71f81faee93a2e04c70a219b/src/TechStacks/AppData.swift#L144">maintain a cache of all loaded images</a>, reducing number of HTTP requests and load times when navigating between screens:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">var</span> imageCache:[<span class="pl-c1">String</span>:UIImage] <span class="pl-k">=</span> [<span class="pl-k">:</span>]

<span class="pl-k">public</span> <span class="pl-k">func</span> <span class="pl-en">loadImageAsync</span>(url:<span class="pl-c1">String</span>) <span class="pl-k">-&gt;</span> Promise&lt;UIImage?&gt; {
    <span class="pl-k">if</span> <span class="pl-k">let</span> image <span class="pl-k">=</span> imageCache[url] {
        <span class="pl-k">return</span> Promise<span class="pl-k">&lt;</span>UIImage?<span class="pl-k">&gt;</span> { (complete, reject) <span class="pl-k">in</span> complete(image) }
    }

    <span class="pl-k">return</span> client<span class="pl-k">.</span>getDataAsync(url)
        <span class="pl-k">.</span>then { (data:NSData) <span class="pl-k">-&gt;</span> UIImage? <span class="pl-k">in</span>
            <span class="pl-k">if</span> <span class="pl-k">let</span> image <span class="pl-k">=</span> UIImage(data:data) {
                <span class="pl-k">self</span><span class="pl-k">.</span>imageCache[url] <span class="pl-k">=</span> image
                <span class="pl-k">return</span> image
            }
            <span class="pl-k">return</span> <span class="pl-c1">nil</span>
        }
}</pre></div>

<h2>
<a id="user-content-techstacks-osx-desktop-app" class="anchor" href="#techstacks-osx-desktop-app" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>TechStacks OSX Desktop App</h2>

<p>As <code>JsonServiceClient.swift</code> has no external dependencies and only relies on core <code>Foundation</code> classes it can be used anywhere Swift can including OSX Cocoa Desktop and Command Line Apps and Frameworks.</p>

<p>Most of the API's used in TechStacks iOS App are standard typed Web Services calls. There is also a TechStacks OSX Desktop available which showcases how easy it is to call ServiceStack's dynamic <a href="https://github.com/ServiceStack/ServiceStack/wiki/Auto-Query">AutoQuery Services</a> and how much auto-querying functionality they can provide for free.</p>

<p>E.g. The TechStacks Desktop app is essentially powered with these 2 AutoQuery Services:</p>

<div class="highlight highlight-source-cs"><pre>[Query(QueryTerm.Or)] <span class="pl-c">//change from filtering (default) to combinatory semantics</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">FindTechStacks</span> : <span class="pl-k">QueryBase</span>&lt;<span class="pl-k">TechnologyStack</span>&gt; {}

[Query(QueryTerm.Or)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">FindTechnologies</span> : <span class="pl-k">QueryBase</span>&lt;<span class="pl-k">Technology</span>&gt; {}</pre></div>

<p>Basically just a Request DTO telling AutoQuery what Table we want to Query and that we want to <a href="https://github.com/ServiceStack/ServiceStack/wiki/Auto-Query#changing-querying-behavior">change the default Search behavior</a> to have <strong>OR</strong> semantics. We don't need to specify which properties we can query as the <a href="https://github.com/ServiceStack/ServiceStack/wiki/Auto-Query#implicit-conventions">implicit conventions</a> automatically infer it from the table being queried.</p>

<p>The TechStacks Desktop UI is then built around these 2 AutoQuery Services allowing querying against each field and utilizing a subset of the implicit conventions supported:</p>

<h3>
<a id="user-content-querying-technology-stacks" class="anchor" href="#querying-technology-stacks" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Querying Technology Stacks</h3>

<p><a href="https://raw.githubusercontent.com/ServiceStack/Assets/master/img/release-notes/techstacks-desktop-field.png" target="_blank"><img src="https://raw.githubusercontent.com/ServiceStack/Assets/master/img/release-notes/techstacks-desktop-field.png" alt="TechStack Desktop Search Fields" style="max-width:100%;"></a></p>

<h3>
<a id="user-content-querying-technologies" class="anchor" href="#querying-technologies" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Querying Technologies</h3>

<p><a href="https://raw.githubusercontent.com/ServiceStack/Assets/master/img/release-notes/techstacks-desktop-type.png" target="_blank"><img src="https://raw.githubusercontent.com/ServiceStack/Assets/master/img/release-notes/techstacks-desktop-type.png" alt="TechStack Desktop Search Type" style="max-width:100%;"></a></p>

<p>Like the TechStacks iOS App all Service Calls are maintained in a single <a href="https://github.com/ServiceStackApps/TechStacksDesktopApp/blob/master/src/TechStacksDesktop/AppData.swift">AppData.swift</a> class and uses KVO bindings to update its UI which is populated from these 2 services below:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">func</span> <span class="pl-en">searchTechStacks</span>(query:<span class="pl-c1">String</span>, field:<span class="pl-c1">String</span>? <span class="pl-k">=</span> <span class="pl-c1">nil</span>, operand:<span class="pl-c1">String</span>? <span class="pl-k">=</span> <span class="pl-c1">nil</span>)
  <span class="pl-k">-&gt;</span> Promise<span class="pl-k">&lt;</span>QueryResponse<span class="pl-k">&lt;</span>TechnologyStack<span class="pl-k">&gt;&gt;</span> {
    <span class="pl-k">self</span><span class="pl-k">.</span>search <span class="pl-k">=</span> query

    <span class="pl-k">let</span> queryString <span class="pl-k">=</span> query<span class="pl-k">.</span><span class="pl-c1">count</span> <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> field <span class="pl-k">!=</span> <span class="pl-c1">nil</span> <span class="pl-k">&amp;&amp;</span> operand <span class="pl-k">!=</span> <span class="pl-c1">nil</span>
        <span class="pl-k">?</span> [createAutoQueryParam(field<span class="pl-k">!</span>, operand<span class="pl-k">!</span>): query]
        <span class="pl-k">:</span> [<span class="pl-s"><span class="pl-pds">"</span>NameContains<span class="pl-pds">"</span></span>:query, <span class="pl-s"><span class="pl-pds">"</span>DescriptionContains<span class="pl-pds">"</span></span>:query]

    <span class="pl-k">let</span> request <span class="pl-k">=</span> FindTechStacks<span class="pl-k">&lt;</span>TechnologyStack<span class="pl-k">&gt;</span>()
    <span class="pl-k">return</span> client<span class="pl-k">.</span>getAsync(request, query:queryString)
        <span class="pl-k">.</span>then { (r:QueryResponse<span class="pl-k">&lt;</span>TechnologyStack<span class="pl-k">&gt;</span>) <span class="pl-k">-&gt;</span> QueryResponse<span class="pl-k">&lt;</span>TechnologyStack<span class="pl-k">&gt;</span> <span class="pl-k">in</span>
            <span class="pl-k">self</span><span class="pl-k">.</span>filteredTechStacks <span class="pl-k">=</span> r<span class="pl-k">.</span>results
            <span class="pl-k">return</span> r
        }
}

<span class="pl-k">func</span> <span class="pl-en">searchTechnologies</span>(query:<span class="pl-c1">String</span>, field:<span class="pl-c1">String</span>? <span class="pl-k">=</span> <span class="pl-c1">nil</span>, operand:<span class="pl-c1">String</span>? <span class="pl-k">=</span> <span class="pl-c1">nil</span>)
  <span class="pl-k">-&gt;</span> Promise<span class="pl-k">&lt;</span>QueryResponse<span class="pl-k">&lt;</span>Technology<span class="pl-k">&gt;&gt;</span> {
    <span class="pl-k">self</span><span class="pl-k">.</span>search <span class="pl-k">=</span> query

    <span class="pl-k">let</span> queryString <span class="pl-k">=</span> query<span class="pl-k">.</span><span class="pl-c1">count</span> <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> field <span class="pl-k">!=</span> <span class="pl-c1">nil</span> <span class="pl-k">&amp;&amp;</span> operand <span class="pl-k">!=</span> <span class="pl-c1">nil</span>
        <span class="pl-k">?</span> [createAutoQueryParam(field<span class="pl-k">!</span>, operand<span class="pl-k">!</span>): query]
        <span class="pl-k">:</span> [<span class="pl-s"><span class="pl-pds">"</span>NameContains<span class="pl-pds">"</span></span>:query, <span class="pl-s"><span class="pl-pds">"</span>DescriptionContains<span class="pl-pds">"</span></span>:query]

    <span class="pl-k">let</span> request <span class="pl-k">=</span> FindTechnologies<span class="pl-k">&lt;</span>Technology<span class="pl-k">&gt;</span>()
    <span class="pl-k">return</span> client<span class="pl-k">.</span>getAsync(request, query:queryString)
        <span class="pl-k">.</span>then { (r:QueryResponse<span class="pl-k">&lt;</span>Technology<span class="pl-k">&gt;</span>) <span class="pl-k">-&gt;</span> QueryResponse<span class="pl-k">&lt;</span>Technology<span class="pl-k">&gt;</span> <span class="pl-k">in</span>
            <span class="pl-k">self</span><span class="pl-k">.</span>filteredTechnologies <span class="pl-k">=</span> r<span class="pl-k">.</span>results
            <span class="pl-k">return</span> r
        }
}

<span class="pl-k">func</span> <span class="pl-en">createAutoQueryParam</span>(field:<span class="pl-c1">String</span>, <span class="pl-en">_</span> <span class="pl-smi">operand</span>:<span class="pl-c1">String</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">String</span> {
    <span class="pl-k">let</span> template <span class="pl-k">=</span> autoQueryOperandsMap[operand]<span class="pl-k">!</span>
    <span class="pl-k">let</span> mergedField <span class="pl-k">=</span> template<span class="pl-k">.</span>replace(<span class="pl-s"><span class="pl-pds">"</span>%<span class="pl-pds">"</span></span>, withString:field)
    <span class="pl-k">return</span> mergedField
}</pre></div>

<p>Essentially employing the same strategy for both AutoQuery Services where it builds a query String parameter to send with the request. For incomplete queries, the default search queries both <code>NameContains</code> and <code>DescriptionContains</code> field conventions returning results where the Search Text is either in <code>Name</code> <strong>OR</strong> <code>Description</code> fields.</p>

<h2>
<a id="user-content-swift-generated-dto-types" class="anchor" href="#swift-generated-dto-types" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Swift Generated DTO Types</h2>

<p>With Swift support our goal was to ensure a high-fidelity, idiomatic translation within the constraints of Swift language and built-in libraries, where the .NET Server DTO's are translated into clean Swift POSO's (Plain Old Swift Objects :) having their .NET built-in types mapped to their equivalent Swift data type. </p>

<p>To see what this ended up looking like, we'll peel back behind the covers and look at a couple of the <a href="http://test.servicestack.net/types/swift">Generated Swift Test Models</a> to see how they're translated in Swift:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> AllTypes
{
    <span class="pl-k">required</span> <span class="pl-k">public</span> <span class="pl-k">init</span>(){}
    <span class="pl-k">public</span> <span class="pl-k">var</span> id:<span class="pl-c1">Int</span>?
    <span class="pl-k">public</span> <span class="pl-k">var</span> nullableId:<span class="pl-c1">Int</span>?
    <span class="pl-k">public</span> <span class="pl-k">var</span> byte:<span class="pl-c1">Int8</span>?
    <span class="pl-k">public</span> <span class="pl-k">var</span> short:<span class="pl-c1">Int16</span>?
    <span class="pl-k">public</span> <span class="pl-k">var</span> int:<span class="pl-c1">Int</span>?
    <span class="pl-k">public</span> <span class="pl-k">var</span> long:<span class="pl-c1">Int64</span>?
    <span class="pl-k">public</span> <span class="pl-k">var</span> uShort:<span class="pl-c1">UInt16</span>?
    <span class="pl-k">public</span> <span class="pl-k">var</span> uInt:<span class="pl-c1">UInt32</span>?
    <span class="pl-k">public</span> <span class="pl-k">var</span> uLong:<span class="pl-c1">UInt64</span>?
    <span class="pl-k">public</span> <span class="pl-k">var</span> float:<span class="pl-c1">Float</span>?
    <span class="pl-k">public</span> <span class="pl-k">var</span> double:<span class="pl-c1">Double</span>?
    <span class="pl-k">public</span> <span class="pl-k">var</span> decimal:<span class="pl-c1">Double</span>?
    <span class="pl-k">public</span> <span class="pl-k">var</span> string:<span class="pl-c1">String</span>?
    <span class="pl-k">public</span> <span class="pl-k">var</span> dateTime:NSDate?
    <span class="pl-k">public</span> <span class="pl-k">var</span> timeSpan:NSTimeInterval?
    <span class="pl-k">public</span> <span class="pl-k">var</span> dateTimeOffset:NSDate?
    <span class="pl-k">public</span> <span class="pl-k">var</span> guid:<span class="pl-c1">String</span>?
    <span class="pl-k">public</span> <span class="pl-k">var</span> char:<span class="pl-c1">Character</span>?
    <span class="pl-k">public</span> <span class="pl-k">var</span> nullableDateTime:NSDate?
    <span class="pl-k">public</span> <span class="pl-k">var</span> nullableTimeSpan:NSTimeInterval?
    <span class="pl-k">public</span> <span class="pl-k">var</span> stringList:[<span class="pl-c1">String</span>] <span class="pl-k">=</span> []
    <span class="pl-k">public</span> <span class="pl-k">var</span> stringArray:[<span class="pl-c1">String</span>] <span class="pl-k">=</span> []
    <span class="pl-k">public</span> <span class="pl-k">var</span> stringMap:[<span class="pl-c1">String</span>:<span class="pl-c1">String</span>] <span class="pl-k">=</span> [<span class="pl-k">:</span>]
    <span class="pl-k">public</span> <span class="pl-k">var</span> intStringMap:[<span class="pl-c1">Int</span>:<span class="pl-c1">String</span>] <span class="pl-k">=</span> [<span class="pl-k">:</span>]
    <span class="pl-k">public</span> <span class="pl-k">var</span> subType:SubType?
}

<span class="pl-k">public</span> <span class="pl-k">class</span> AllCollectionTypes
{
    <span class="pl-k">required</span> <span class="pl-k">public</span> <span class="pl-k">init</span>(){}
    <span class="pl-k">public</span> <span class="pl-k">var</span> intArray:[<span class="pl-c1">Int</span>] <span class="pl-k">=</span> []
    <span class="pl-k">public</span> <span class="pl-k">var</span> intList:[<span class="pl-c1">Int</span>] <span class="pl-k">=</span> []
    <span class="pl-k">public</span> <span class="pl-k">var</span> stringArray:[<span class="pl-c1">String</span>] <span class="pl-k">=</span> []
    <span class="pl-k">public</span> <span class="pl-k">var</span> stringList:[<span class="pl-c1">String</span>] <span class="pl-k">=</span> []
    <span class="pl-k">public</span> <span class="pl-k">var</span> pocoArray:[Poco] <span class="pl-k">=</span> []
    <span class="pl-k">public</span> <span class="pl-k">var</span> pocoList:[Poco] <span class="pl-k">=</span> []
    <span class="pl-k">public</span> <span class="pl-k">var</span> pocoLookup:[<span class="pl-c1">String</span>:[Poco]] <span class="pl-k">=</span> [<span class="pl-k">:</span>]
    <span class="pl-k">public</span> <span class="pl-k">var</span> pocoLookupMap:[<span class="pl-c1">String</span>:[<span class="pl-c1">String</span>:Poco]] <span class="pl-k">=</span> [<span class="pl-k">:</span>]
}

<span class="pl-k">public</span> <span class="pl-k">enum</span> EnumType <span class="pl-k">:</span> <span class="pl-c1">Int</span>
{
    <span class="pl-k">case</span> Value1
    <span class="pl-k">case</span> Value2
}</pre></div>

<p>As seen above, properties are essentially mapped to their optimal Swift equivalent. As DTO's can be partially complete all properties are <code>Optional</code> except for enumerables which default to an empty collection - making them easier to work with and despite their semantic differences, .NET enums are translated into typed Swift enums.</p>

<h3>
<a id="user-content-swift-code-generation" class="anchor" href="#swift-code-generation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Swift Code Generation</h3>

<p>As we were already using code-gen to generate the Swift types we could extend it without impacting the Developer UX has been expanded to also include what's essentially an <strong>explicit Reflection API</strong> for each type with API's to support serializing to and from JSON. Thanks to Swift's rich support for extending types we were able to leverage its Type extensions so the implementation details could remain disconnected from the clean Swift type definitions allowing improved readability when inspecting the remote DTO schema's.</p>

<p>We can look at <code>AllCollectionTypes</code> to see an example of the code-gen that's generated for each type, essentially emitting explicit readable/writable closures for each property: </p>

<div class="highlight highlight-source-swift"><pre><span class="pl-k">extension</span> AllCollectionTypes <span class="pl-k">:</span> JsonSerializable
{
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">var</span> typeName:<span class="pl-c1">String</span> { <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>AllCollectionTypes<span class="pl-pds">"</span></span> }
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">var</span> metadata <span class="pl-k">=</span> Metadata<span class="pl-k">.</span>create([
            <span class="pl-k">Type</span><span class="pl-k">&lt;</span>AllCollectionTypes<span class="pl-k">&gt;.</span>arrayProperty(<span class="pl-s"><span class="pl-pds">"</span>intArray<span class="pl-pds">"</span></span>, <span class="pl-k">get</span>: { $<span class="pl-c1">0</span><span class="pl-k">.</span>intArray }, <span class="pl-k">set</span>: { $<span class="pl-c1">0</span><span class="pl-k">.</span>intArray <span class="pl-k">=</span> $<span class="pl-c1">1</span> }),
            <span class="pl-k">Type</span><span class="pl-k">&lt;</span>AllCollectionTypes<span class="pl-k">&gt;.</span>arrayProperty(<span class="pl-s"><span class="pl-pds">"</span>intList<span class="pl-pds">"</span></span>, <span class="pl-k">get</span>: { $<span class="pl-c1">0</span><span class="pl-k">.</span>intList }, <span class="pl-k">set</span>: { $<span class="pl-c1">0</span><span class="pl-k">.</span>intList <span class="pl-k">=</span> $<span class="pl-c1">1</span> }),
            <span class="pl-k">Type</span><span class="pl-k">&lt;</span>AllCollectionTypes<span class="pl-k">&gt;.</span>arrayProperty(<span class="pl-s"><span class="pl-pds">"</span>stringArray<span class="pl-pds">"</span></span>, <span class="pl-k">get</span>: { $<span class="pl-c1">0</span><span class="pl-k">.</span>stringArray }, <span class="pl-k">set</span>: { $<span class="pl-c1">0</span><span class="pl-k">.</span>stringArray <span class="pl-k">=</span> $<span class="pl-c1">1</span> }),
            <span class="pl-k">Type</span><span class="pl-k">&lt;</span>AllCollectionTypes<span class="pl-k">&gt;.</span>arrayProperty(<span class="pl-s"><span class="pl-pds">"</span>stringList<span class="pl-pds">"</span></span>, <span class="pl-k">get</span>: { $<span class="pl-c1">0</span><span class="pl-k">.</span>stringList }, <span class="pl-k">set</span>: { $<span class="pl-c1">0</span><span class="pl-k">.</span>stringList <span class="pl-k">=</span> $<span class="pl-c1">1</span> }),
            <span class="pl-k">Type</span><span class="pl-k">&lt;</span>AllCollectionTypes<span class="pl-k">&gt;.</span>arrayProperty(<span class="pl-s"><span class="pl-pds">"</span>pocoArray<span class="pl-pds">"</span></span>, <span class="pl-k">get</span>: { $<span class="pl-c1">0</span><span class="pl-k">.</span>pocoArray }, <span class="pl-k">set</span>: { $<span class="pl-c1">0</span><span class="pl-k">.</span>pocoArray <span class="pl-k">=</span> $<span class="pl-c1">1</span> }),
            <span class="pl-k">Type</span><span class="pl-k">&lt;</span>AllCollectionTypes<span class="pl-k">&gt;.</span>arrayProperty(<span class="pl-s"><span class="pl-pds">"</span>pocoList<span class="pl-pds">"</span></span>, <span class="pl-k">get</span>: { $<span class="pl-c1">0</span><span class="pl-k">.</span>pocoList }, <span class="pl-k">set</span>: { $<span class="pl-c1">0</span><span class="pl-k">.</span>pocoList <span class="pl-k">=</span> $<span class="pl-c1">1</span> }),
            <span class="pl-k">Type</span><span class="pl-k">&lt;</span>AllCollectionTypes<span class="pl-k">&gt;.</span>objectProperty(<span class="pl-s"><span class="pl-pds">"</span>pocoLookup<span class="pl-pds">"</span></span>, <span class="pl-k">get</span>: { $<span class="pl-c1">0</span><span class="pl-k">.</span>pocoLookup }, <span class="pl-k">set</span>: { $<span class="pl-c1">0</span><span class="pl-k">.</span>pocoLookup <span class="pl-k">=</span> $<span class="pl-c1">1</span> }),
            <span class="pl-k">Type</span><span class="pl-k">&lt;</span>AllCollectionTypes<span class="pl-k">&gt;.</span>objectProperty(<span class="pl-s"><span class="pl-pds">"</span>pocoLookupMap<span class="pl-pds">"</span></span>, <span class="pl-k">get</span>: { $<span class="pl-c1">0</span><span class="pl-k">.</span>pocoLookupMap }, <span class="pl-k">set</span>: { $<span class="pl-c1">0</span><span class="pl-k">.</span>pocoLookupMap <span class="pl-k">=</span> $<span class="pl-c1">1</span> }),
        ])
}</pre></div>

<h3>
<a id="user-content-swift-native-types-limitations" class="anchor" href="#swift-native-types-limitations" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Swift Native Types Limitations</h3>

<p>Due to the semantic differences and limitations in Swift there are some limitations of what's not supported. Luckily these limitations are mostly <a href="http://stackoverflow.com/a/10759250/85785">highly-discouraged bad practices</a> which is another reason not to use them. Specifically what's not supported:</p>

<h4>
<a id="user-content-no-object-or-interface-properties" class="anchor" href="#no-object-or-interface-properties" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>No <code>object</code> or <code>Interface</code> properties</h4>

<p>When emitting code we'll generate a comment when ignoring these properties, e.g:</p>

<div class="highlight highlight-source-swift"><pre><span class="pl-c">//emptyInterface:IEmptyInterface ignored. Swift doesn't support interface properties</span></pre></div>

<h4>
<a id="user-content-base-types-must-be-marked-abstract" class="anchor" href="#base-types-must-be-marked-abstract" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Base types must be marked abstract</h4>

<p>As Swift doesn't support extension inheritance, when using inheritance in DTO's any Base types must be marked abstract.</p>

<h4>
<a id="user-content-all-dto-type-names-must-be-unique" class="anchor" href="#all-dto-type-names-must-be-unique" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>All DTO Type Names must be unique</h4>

<p>Required as there are no namespaces in Swift (Also required for F# and TypeScript). ServiceStack only requires Request DTO's to be unique, but our recommendation is for all DTO names to be unique.</p>

<h4>
<a id="user-content-ireturn-not-added-for-array-responses" class="anchor" href="#ireturn-not-added-for-array-responses" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>IReturn not added for Array Responses</h4>

<p>As Swift doesn't allow extending generic Arrays with public protocols, the <code>IReturn</code> marker that enables the typed ServiceClient API isn't available for Requests returning Array responses. You can workaround this limitation by wrapping the array in a Response DTO whilst we look at other solutions to support this in future.</p>
