<p>ServiceStack provides a number of ways of changing the database connection used at runtime based on an incoming Request. You can use a <a href="https://github.com/ServiceStack/ServiceStack/wiki/Request-and-response-filters#global-request-filters">Request Filter</a>, use the <code>[ConnectionInfo]</code> <a href="https://github.com/ServiceStack/ServiceStack/wiki/Filter-attributes#request-filter-attributes">Request Filter Attribute</a>, use the <code>[NamedConnection]</code> attribute on [[Auto Query]] Services, access named connections in Custom Service implementations or override <code>GetDbConnection(IRequest)</code> in your AppHost.</p>

<h3>
<a id="user-content-change-database-connection-at-runtime" class="anchor" href="#change-database-connection-at-runtime" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Change Database Connection at Runtime</h3>

<p>The default implementation of <code>IAppHost.GetDbConnection(IRequest)</code> includes an easy way to change the DB Connection that can be done by populating the 
<a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack/ConnectionInfo.cs">ConnectionInfo</a> 
POCO in any
<a href="https://github.com/ServiceStack/ServiceStack/wiki/Order-of-Operations">Request Filter in the Request Pipeline</a>:</p>

<div class="highlight highlight-source-cs"><pre>req.Items[Keywords.DbInfo] = <span class="pl-k">new</span> ConnectionInfo {
    NamedConnection  = ... <span class="pl-c">//Use a registered NamedConnection for this Request</span>
    ConnectionString = ... <span class="pl-c">//Use a different DB connection for this Request</span>
    ProviderName     = ... <span class="pl-c">//Use a different Dialect Provider for this Request</span>
};</pre></div>

<p>To illustrate how this works we'll go through a simple example showing how to create an AutoQuery Service 
that lets the user change which DB the Query is run on. We'll control which of the Services we want to allow 
the user to change the DB it's run on by having them implement the interface below:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">interface</span> <span class="pl-en">IChangeDb</span>
{
    <span class="pl-k">string</span> <span class="pl-en">NamedConnection</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">string</span> <span class="pl-en">ConnectionString</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">string</span> <span class="pl-en">ProviderName</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}</pre></div>

<p>We'll create one such AutoQuery Service, implementing the above interface:</p>

<div class="highlight highlight-source-cs"><pre>[Route(<span class="pl-s"><span class="pl-pds">"</span>/rockstars<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">QueryRockstars</span> : <span class="pl-k">QueryBase</span>&lt;<span class="pl-k">Rockstar</span>&gt;, <span class="pl-k">IChangeDb</span>
{
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">NamedConnection</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">ConnectionString</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">ProviderName</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}</pre></div>

<p>For this example we'll configure our Database to use a default <strong>SQL Server 2012</strong> database, 
register an optional named connection looking at a "Reporting" <strong>PostgreSQL</strong> database and 
register an alternative <strong>Sqlite</strong> RDBMS Dialect that we also want the user to be able to use:</p>

<h4>
<a id="user-content-changedb-apphost-registration" class="anchor" href="#changedb-apphost-registration" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>ChangeDB AppHost Registration</h4>

<div class="highlight highlight-source-cs"><pre>container.Register&lt;IDbConnectionFactory&gt;(c =&gt; 
    <span class="pl-k">new</span> OrmLiteConnectionFactory(defaultDbConn, SqlServer2012Dialect.Provider));

<span class="pl-k">var</span> dbFactory = container.Resolve&lt;IDbConnectionFactory&gt;();

<span class="pl-c">//Register NamedConnection</span>
dbFactory.RegisterConnection(<span class="pl-s"><span class="pl-pds">"</span>Reporting<span class="pl-pds">"</span></span>, ReportConnString, PostgreSqlDialect.Provider);

<span class="pl-c">//Register DialectProvider</span>
dbFactory.RegisterDialectProvider(<span class="pl-s"><span class="pl-pds">"</span>Sqlite<span class="pl-pds">"</span></span>, SqliteDialect.Provider);</pre></div>

<h4>
<a id="user-content-changedb-request-filter" class="anchor" href="#changedb-request-filter" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>ChangeDB Request Filter</h4>

<p>To enable this feature we just need to add a Request Filter that populates the <code>ConnectionInfo</code> with properties
from the Request DTO:</p>

<div class="highlight highlight-source-cs"><pre>GlobalRequestFilters.Add((req, res, dto) =&gt; {
   <span class="pl-k">var</span> changeDb = dto <span class="pl-k">as</span> IChangeDb;
   <span class="pl-k">if</span> (changeDb == <span class="pl-c1">null</span>) <span class="pl-k">return</span>;

   req.Items[Keywords.DbInfo] = <span class="pl-k">new</span> ConnectionInfo {
       NamedConnection = changeDb.NamedConnection,
       ConnectionString = changeDb.ConnectionString,
       ProviderName = changeDb.ProviderName,
   };
});</pre></div>

<p>Since our <code>IChangeDb</code> interface shares the same property names as <code>ConnectionInfo</code>, the above code can be 
further condensed using a 
<a href="https://github.com/ServiceStack/ServiceStack/wiki/Request-and-response-filters#typed-request-filters">Typed Request Filter</a>
and ServiceStack's built-in <a href="https://github.com/ServiceStack/ServiceStack/wiki/Auto-mapping">AutoMapping</a>
down to just:</p>

<div class="highlight highlight-source-cs"><pre>RegisterTypedRequestFilter&lt;IChangeDb&gt;((req, res, dto) =&gt;
    req.Items[Keywords.DbInfo] = dto.ConvertTo&lt;ConnectionInfo&gt;());</pre></div>

<h4>
<a id="user-content-change-databases-via-querystring" class="anchor" href="#change-databases-via-querystring" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Change Databases via QueryString</h4>

<p>With the above configuration the user can now change which database they want to execute the query on, e.g:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> response = client.Get(<span class="pl-k">new</span> QueryRockstars()); <span class="pl-c">//SQL Server</span>

<span class="pl-k">var</span> response = client.Get(<span class="pl-k">new</span> QueryRockstars {   <span class="pl-c">//Reporting PostgreSQL DB</span>
    NamedConnection = <span class="pl-s"><span class="pl-pds">"</span>Reporting<span class="pl-pds">"</span></span>
}); 

<span class="pl-k">var</span> response = client.Get(<span class="pl-k">new</span> QueryRockstars {   <span class="pl-c">//Alternative SQL Server Database</span>
    ConnectionString = <span class="pl-s"><span class="pl-pds">"</span>Server=alt-host;Database=Rockstars;User Id=test;Password=test;<span class="pl-pds">"</span></span>
}); 

<span class="pl-k">var</span> response = client.Get(<span class="pl-k">new</span> QueryRockstars {   <span class="pl-c">//Alternative SQLite Database</span>
    ConnectionString = <span class="pl-s"><span class="pl-pds">"</span>C:<span class="pl-cce">\b</span>ackups<span class="pl-cce">\2</span>016-01-01.sqlite<span class="pl-pds">"</span></span>,
    ProviderName = <span class="pl-s"><span class="pl-pds">"</span>Sqlite<span class="pl-pds">"</span></span>
}); </pre></div>

<h3>
<a id="user-content-connectioninfo-attribute" class="anchor" href="#connectioninfo-attribute" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>ConnectionInfo Attribute</h3>

<p>To make it even easier to use we've also wrapped this feature in a simple
<a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack/ConnectionInfoAttribute.cs">ConnectionInfoAttribute.cs</a>
which allows you to declaratively specify which database a Service should be configured to use, e.g we can
configure the <code>Db</code> connection in the Service below to use the PostgreSQL <strong>Reporting</strong> database with:</p>

<div class="highlight highlight-source-cs"><pre>[ConnectionInfo(NamedConnection = <span class="pl-s"><span class="pl-pds">"</span>Reporting<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">ReportingServices</span> : <span class="pl-k">Service</span>
{
    <span class="pl-k">public</span> <span class="pl-k">object</span> <span class="pl-en">Any</span>(<span class="pl-k">Sales</span> <span class="pl-smi">request</span>)
    {
        <span class="pl-k">return</span> <span class="pl-k">new</span> SalesResponse { Results = Db.Select&lt;Sales&gt;() };
    }
}</pre></div>

<h3>
<a id="user-content-auto-query-named-connection" class="anchor" href="#auto-query-named-connection" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a href="https://github.com/ServiceStack/ServiceStack/wiki/Auto-Query#named-connection">Auto Query Named Connection</a>
</h3>

<p>[[Auto Query]] can also easily be configured to query any number of different databases registered in your AppHost. </p>

<p>In the example below we configure our main RDBMS to use SQL Server and register a <strong>Named Connection</strong> 
to point to a <strong>Reporting</strong> PostgreSQL RDBMS:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> dbFactory = <span class="pl-k">new</span> OrmLiteConnectionFactory(connString, SqlServer2012Dialect.Provider);
container.Register&lt;IDbConnectionFactory&gt;(dbFactory);

dbFactory.RegisterConnection(<span class="pl-s"><span class="pl-pds">"</span>Reporting<span class="pl-pds">"</span></span>, pgConnString, PostgreSqlDialect.Provider);</pre></div>

<p>Any normal AutoQuery Services like <code>QueryOrders</code> will use the default SQL Server connection whilst 
<code>QuerySales</code> will execute its query on the PostgreSQL <code>Reporting</code> Database instead:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">QueryOrders</span> : <span class="pl-k">QueryBase</span>&lt;<span class="pl-k">Order</span>&gt; {}

[NamedConnection(<span class="pl-s"><span class="pl-pds">"</span>Reporting<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">QuerySales</span> : <span class="pl-k">QueryBase</span>&lt;<span class="pl-k">Sales</span>&gt; {}</pre></div>

<h3>
<a id="user-content-resolving-named-connections-in-services" class="anchor" href="#resolving-named-connections-in-services" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Resolving Named Connections in Services</h3>

<p>Whilst inside a Service you can change which DB connection to use by passing in the NamedConnection when opening a DB Connection. E.g. The example below allows the user to change which database to retrieve all sales records for otherwise fallbacks to "Reporting" database by default:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">SalesServices</span> : <span class="pl-k">Service</span>
{
   <span class="pl-k">public</span> IDbConnectionFactory <span class="pl-en">ConnectionFactory</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; } 

   <span class="pl-k">public</span> <span class="pl-k">object</span> <span class="pl-en">Any</span>(<span class="pl-k">GetAllSales</span> <span class="pl-smi">request</span>)
   {
       <span class="pl-k">var</span> namedConnection = request.NamedConnection ?? <span class="pl-s"><span class="pl-pds">"</span>Reporting<span class="pl-pds">"</span></span>;
       <span class="pl-k">using</span> (<span class="pl-k">var</span> db = ConnectionFactory.Open(namedConnection)) 
       {
           <span class="pl-k">return</span> db.Select&lt;Sales&gt;();
       }
   }
}</pre></div>

<h3>
<a id="user-content-override-connection-used-per-request-at-runtime" class="anchor" href="#override-connection-used-per-request-at-runtime" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Override Connection used per request at Runtime</h3>

<p>All built-in dependencies available from <code>Service</code> base class, AutoQuery, Razor View pages, etc are resolved 
from a central overridable location in your <code>AppHost</code>. This lets you control which pre-configured 
dependency gets used based on the incoming Request for each Service by overriding any of the <code>AppHost</code> methods below: </p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">virtual</span> IDbConnection Db
{
    <span class="pl-k">get</span> { <span class="pl-k">return</span> db ?? (db = HostContext.AppHost.GetDbConnection(Request)); }
}

<span class="pl-k">public</span> <span class="pl-k">virtual</span> ICacheClient Cache
{
    <span class="pl-k">get</span> { <span class="pl-k">return</span> cache ?? (cache = HostContext.AppHost.GetCacheClient(Request)); }
}

<span class="pl-k">public</span> <span class="pl-k">virtual</span> MemoryCacheClient LocalCache
{
    <span class="pl-k">get</span> { <span class="pl-k">return</span> localCache ?? 
              (localCache = HostContext.AppHost.GetMemoryCacheClient(Request)); }
}

<span class="pl-k">public</span> <span class="pl-k">virtual</span> IRedisClient Redis
{
    <span class="pl-k">get</span> { <span class="pl-k">return</span> redis ?? (redis = HostContext.AppHost.GetRedisClient(Request)); }
}

<span class="pl-k">public</span> <span class="pl-k">virtual</span> IMessageProducer MessageProducer
{
    <span class="pl-k">get</span> { <span class="pl-k">return</span> messageProducer ?? 
              (messageProducer = HostContext.AppHost.GetMessageProducer(Request)); }
}</pre></div>

<p>E.g. to change the DB Connection your Service uses you can override <code>GetDbConnection(IRequest)</code> in your <code>AppHost</code>.</p>

<h3>
<a id="user-content-multi-tenancy-example" class="anchor" href="#multi-tenancy-example" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a href="https://github.com/ServiceStack/ServiceStack/blob/master/tests/ServiceStack.WebHost.Endpoints.Tests/MultiTennantAppHostTests.cs">Multi Tenancy Example</a>
</h3>

<p>To show how easy it is to implement a Multi Tenancy Service with this feature we've added a stand-alone
<a href="https://github.com/ServiceStack/ServiceStack/blob/master/tests/ServiceStack.WebHost.Endpoints.Tests/MultiTennantAppHostTests.cs">Multi Tenancy AppHost Example</a> 
showing 2 different ways we can configure a Service to use different databases based on an incoming request.</p>

<p>In this example we've configured our AppHost to use the <strong>master.sqlite</strong> database as default and registered
3 different named connections referencing 3 different databases. Each database is then initialized with a 
different row in the <code>TenantConfig</code> table to identify the database that it's in.</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">MultiTenantChangeDbAppHost</span> : <span class="pl-k">AppSelfHostBase</span>
{
    <span class="pl-k">public</span> <span class="pl-en">MultiTenantChangeDbAppHost</span>()
        : <span class="pl-c1">base</span>("Multi Tennant Test", typeof (MultiTenantChangeDbAppHost).Assembly) {}

    <span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-k">void</span> <span class="pl-en">Configure</span>(<span class="pl-k">Container</span> <span class="pl-smi">container</span>)
    {
        container.Register&lt;IDbConnectionFactory&gt;(<span class="pl-k">new</span> OrmLiteConnectionFactory(
            <span class="pl-s"><span class="pl-pds">"</span>~/App_Data/master.sqlite<span class="pl-pds">"</span></span>.MapAbsolutePath(), SqliteDialect.Provider));

        <span class="pl-k">var</span> dbFactory = container.Resolve&lt;IDbConnectionFactory&gt;();

        <span class="pl-k">const</span> <span class="pl-k">int</span> noOfTennants = <span class="pl-c1">3</span>;

        <span class="pl-k">using</span> (<span class="pl-k">var</span> db = dbFactory.OpenDbConnection())
            InitDb(db, <span class="pl-s"><span class="pl-pds">"</span>MASTER<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Masters inc.<span class="pl-pds">"</span></span>);

        noOfTennants.Times(i =&gt;
        {
            <span class="pl-k">var</span> tenantId = <span class="pl-s"><span class="pl-pds">"</span>T0<span class="pl-pds">"</span></span> + (i + <span class="pl-c1">1</span>);
            <span class="pl-k">using</span> (<span class="pl-k">var</span> db = dbFactory.OpenDbConnectionString(GetTenantConnString(tenantId)))
                InitDb(db, tenantId, <span class="pl-s"><span class="pl-pds">"</span>ACME {0} inc.<span class="pl-pds">"</span></span>.Fmt(tenantId));
        });

        RegisterTypedRequestFilter&lt;IForTenant&gt;((req,res,dto) =&gt; 
            req.Items[Keywords.DbInfo] = <span class="pl-k">new</span> ConnectionInfo { ConnectionString = GetTenantConnString(dto.TenantId)});
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">InitDb</span>(<span class="pl-k">IDbConnection</span> <span class="pl-smi">db</span>, <span class="pl-k">string</span> <span class="pl-smi">tenantId</span>, <span class="pl-k">string</span> <span class="pl-smi">company</span>)
    {
        db.DropAndCreateTable&lt;TenantConfig&gt;();
        db.Insert(<span class="pl-k">new</span> TenantConfig { Id = tenantId, Company = company });
    }

    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">GetTenantConnString</span>(<span class="pl-k">string</span> <span class="pl-smi">tenantId</span>)
    {
        <span class="pl-k">return</span> tenantId != <span class="pl-c1">null</span> 
            ? <span class="pl-s"><span class="pl-pds">"</span>~/App_Data/tenant-{0}.sqlite<span class="pl-pds">"</span></span>.Fmt(tenantId).MapAbsolutePath()
            : <span class="pl-c1">null</span>;
    }
}</pre></div>

<p>This example uses only contains a single Service which returns the first result in the <code>TenantConfig</code> table:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">interface</span> <span class="pl-en">IForTenant</span>
{
    <span class="pl-k">string</span> <span class="pl-en">TenantId</span> { <span class="pl-k">get</span>; }
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">TenantConfig</span>
{
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Id</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Company</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">GetTenant</span> : <span class="pl-k">IForTenant</span>, <span class="pl-k">IReturn</span>&lt;<span class="pl-k">GetTenantResponse</span>&gt;
{
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">TenantId</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">GetTenantResponse</span>
{
    <span class="pl-k">public</span> TenantConfig <span class="pl-en">Config</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">MultiTenantService</span> : <span class="pl-k">Service</span>
{
    <span class="pl-k">public</span> <span class="pl-k">object</span> <span class="pl-en">Any</span>(<span class="pl-k">GetTenant</span> <span class="pl-smi">request</span>)
    {
        <span class="pl-k">return</span> <span class="pl-k">new</span> GetTenantResponse
        {
            Config = Db.Select&lt;TenantConfig&gt;().FirstOrDefault(),
        };
    }
}</pre></div>

<p>Calling this Service with a different <code>TenantId</code> value changes which database the Service is configured with:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> client = <span class="pl-k">new</span> JsonServiceClient(Config.AbsoluteBaseUri);

<span class="pl-k">var</span> response = client.Get(<span class="pl-k">new</span> GetTenant()); <span class="pl-c">//= Company: Masters inc. </span>

<span class="pl-k">var</span> response = client.Get(<span class="pl-k">new</span> GetTenant { TenantId = <span class="pl-s"><span class="pl-pds">"</span>T01<span class="pl-pds">"</span></span> }); <span class="pl-c">//= Company: ACME T01 inc.</span>

<span class="pl-k">var</span> response = client.Get(<span class="pl-k">new</span> GetTenant { TenantId = <span class="pl-s"><span class="pl-pds">"</span>T02<span class="pl-pds">"</span></span> }); <span class="pl-c">//= Company: ACME T02 inc.</span>

<span class="pl-k">var</span> response = client.Get(<span class="pl-k">new</span> GetTenant { TenantId = <span class="pl-s"><span class="pl-pds">"</span>T03<span class="pl-pds">"</span></span> }); <span class="pl-c">//= Compnay: ACME T03 inc.</span>

client.Get(<span class="pl-k">new</span> GetTenant { TenantId = <span class="pl-s"><span class="pl-pds">"</span>T04<span class="pl-pds">"</span></span> }); <span class="pl-c">// throws WebServiceException</span></pre></div>

<p>An alternative way to support Multitenancy using a Custom DB Factory is available in 
<a href="https://github.com/ServiceStack/ServiceStack/blob/e392265456e12077087c1cd014c918913f409bc9/tests/ServiceStack.WebHost.Endpoints.Tests/MultiTennantAppHostTests.cs#L132">MultiTennantAppHostTests.cs</a>.</p>
