<p>In order to access physical files in view engines from multiple sources, ServiceStack includes its own pluggable virtual file system API that lets it support multiple filesystem backends. </p>

<p>The virtual file system (VFS) is what allows ServiceStack to support view engines in a standard ASP.NET websites (e.g. serving directories from the root directory) as well in self-hosting stand-alone HttpListener websites and Windows Services serving from the output <code>/bin</code> directory as well as embedded resources inside .dlls, any combination of both and in future from remote datastores.</p>

<h2>
<a id="user-content-embedded-resources" class="anchor" href="#embedded-resources" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Embedded Resources</h2>

<p>To enable ServiceStack to serve embedded resources in your Website's compiled <code>.dll</code> Assembly you'll need to register either an <code>Assembly</code> or a <code>Type</code> in an Assembly that contains embedded resources, e.g:</p>

<div class="highlight highlight-source-cs"><pre>SetConfig(<span class="pl-k">new</span> HostConfig {
   EmbeddedResourceSources = { <span class="pl-k">typeof</span>(TypeInDllWithEmbeddedResources).Assembly },
   EmbeddedResourceBaseTypes = { <span class="pl-k">typeof</span>(TypeInDllWithEmbeddedResources) } 
});</pre></div>

<p>By default ServiceStack automatically includes the Assembly where your <code>AppHost</code> is defined which since it's typically the same top-level assembly where all your Website assets are maintained, no configuration is required to serve any embedded resources which are accessible from the same path as it's defined in your VS.NET project. E.g. if you have an embedded resource in your project at <code>/dir/file.js</code> it would be available from the same path where ServiceStack is mounted, e.g <code>http://localhost:1337/dir/file.js</code>.</p>

<h3>
<a id="user-content-servicestackgap" class="anchor" href="#servicestackgap" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a href="https://github.com/ServiceStack/ServiceStack.Gap">ServiceStack.Gap</a>
</h3>

<p>See the ServiceStack.Gap project for different examples of how to create single <strong>.exe</strong> ILMerged applications with Embedded Resources and Compiled Razor Views.</p>

<h3>
<a id="user-content-registering-additional-virtual-path-providers" class="anchor" href="#registering-additional-virtual-path-providers" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Registering additional Virtual Path Providers</h3>

<p>An easy way to register additional VirtualPath Providers in ServiceStack is to override the <code>GetVirtualFileSources()</code> method in your AppHost where you can add, remove, or re-order existing providers to change their priority. E.g. we can use this to provide an elegant solution for minifying static <code>.html</code>, <code>.css</code> and <code>.js</code> resources by simply pre-loading a new <strong>InMemory Virtual FileSystem</strong> with minified versions of existing files and giving the Memory FS a higher precedence so any matching requests serve up the minified version first with:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">override</span> List&lt;IVirtualPathProvider&gt; GetVirtualFileSources()
{
    <span class="pl-k">var</span> existingProviders = <span class="pl-c1">base</span>.GetVirtualFileSources();
    <span class="pl-k">var</span> memFs = <span class="pl-k">new</span> InMemoryVirtualPathProvider(<span class="pl-c1">this</span>);

    <span class="pl-c">//Get FileSystem Provider</span>
    <span class="pl-k">var</span> fs = existingProviders.First(x =&gt; x <span class="pl-k">is</span> FileSystemVirtualPathProvider);

    <span class="pl-c">//Process all .html files:</span>
    <span class="pl-k">foreach</span> (<span class="pl-k">var</span> file <span class="pl-k">in</span> fs.GetAllMatchingFiles(<span class="pl-s"><span class="pl-pds">"</span>*.html<span class="pl-pds">"</span></span>))
    {
        <span class="pl-k">var</span> contents = Minifiers.HtmlAdvanced.Compress(file.ReadAllText());
        memFs.WriteFile(file.VirtualPath, contents);
    }

    <span class="pl-c">//Process all .css files:</span>
    <span class="pl-k">foreach</span> (<span class="pl-k">var</span> file <span class="pl-k">in</span> fs.GetAllMatchingFiles(<span class="pl-s"><span class="pl-pds">"</span>*.css<span class="pl-pds">"</span></span>)
        .Where(file =&gt; !file.VirtualPath.EndsWith(<span class="pl-s"><span class="pl-pds">"</span>.min.css<span class="pl-pds">"</span></span>)))
    {
        <span class="pl-k">var</span> contents = Minifiers.Css.Compress(file.ReadAllText());
        memFs.WriteFile(file.VirtualPath, contents);
    }

    <span class="pl-c">//Process all .js files</span>
    <span class="pl-k">foreach</span> (<span class="pl-k">var</span> file <span class="pl-k">in</span> fs.GetAllMatchingFiles(<span class="pl-s"><span class="pl-pds">"</span>*.js<span class="pl-pds">"</span></span>)
        .Where(file =&gt; !file.VirtualPath.EndsWith(<span class="pl-s"><span class="pl-pds">"</span>.min.js<span class="pl-pds">"</span></span>)))
    {
        <span class="pl-k">try</span>
        {
            <span class="pl-k">var</span> js = file.ReadAllText();
            <span class="pl-k">var</span> contents = Minifiers.JavaScript.Compress(js);
            memFs.WriteFile(file.VirtualPath, contents);
        }
        <span class="pl-k">catch</span> (Exception ex)
        {
            <span class="pl-c">//Report any errors in StartUpErrors collection on ?debug=requestinfo</span>
            <span class="pl-c1">base</span>.OnStartupException(<span class="pl-k">new</span> Exception(
                <span class="pl-s"><span class="pl-pds">"</span>JSMin Error in {0}: {1}<span class="pl-pds">"</span></span>.Fmt(file.VirtualPath, ex.Message)));
        }
    }

    <span class="pl-c">//Give new Memory FS highest priority</span>
    existingProviders.Insert(<span class="pl-c1">0</span>, memFs);
    <span class="pl-k">return</span> existingProviders;
}</pre></div>

<h3>
<a id="user-content-using-a-different-virtual-path-provider" class="anchor" href="#using-a-different-virtual-path-provider" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Using a different Virtual Path Provider</h3>

<p>You can also globally replace the VFS used by setting it in your AppHost, e.g. If you only want to use an InMemory File System:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-c1">base</span>.VirtualPathProvider = <span class="pl-k">new</span> InMemoryVirtualPathProvider(<span class="pl-c1">this</span>);</pre></div>

<p>Fine-grained control on which VFS to use can also be specified on any <a href="https://github.com/ServiceStack/ServiceStack/wiki/Plugins">Plugins</a> requiring access to the FileSystem like ServiceStack's built-in HTML ViewEngines, here's how you could override the VFS used in ServiceStack's Razors support:</p>

<div class="highlight highlight-source-cs"><pre>Plugins.Add(<span class="pl-k">new</span> RazorFormat { 
  VirtualPathProvider = <span class="pl-k">new</span> InMemoryVirtualPathProvider(<span class="pl-c1">this</span>) 
});</pre></div>

<h3>
<a id="user-content-changing-physical-file-path" class="anchor" href="#changing-physical-file-path" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Changing Physical File Path</h3>

<p>You can change the physical root path from where ServiceStack serves your files from by changing <code>Config.WebHostPhysicalPath</code>, e.g. the current directory for self-hosts is where the <strong>.exe</strong> is run from, during development this is typically <code>\bin\Release</code>. You can change the self-host to serve files from your project folder with:</p>

<div class="highlight highlight-source-cs"><pre>SetConfig(<span class="pl-k">new</span> HostConfig {
    WebHostPhysicalPath = <span class="pl-s"><span class="pl-pds">"</span>~/<span class="pl-pds">"</span></span>.MapProjectPath()
});</pre></div>

<blockquote>
<p>Where <code>string.MapProjectPath()</code> is just an extension method that goes back 2 directories <code>~\..\..</code> - resolving the project folder from the Debug/Release bin folders.</p>
</blockquote>

<h2>
<a id="user-content-overriding-embedded-resources-with-static-files" class="anchor" href="#overriding-embedded-resources-with-static-files" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Overriding Embedded Resources with Static Files</h2>

<p>The VFS supports multiple file source locations where you can override embedded files by including your own custom files in the same location as the embedded files. We can see how this works by overriding the built-in templates used in metadata pages:</p>

<h3>
<a id="user-content-updating-html-and-metadata-page-templates" class="anchor" href="#updating-html-and-metadata-page-templates" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Updating HTML and Metadata Page Templates</h3>

<p>The HTML templates for the metadata pages are maintained as <a href="https://github.com/ServiceStack/ServiceStack/tree/master/src/ServiceStack/Templates">embedded html template resources</a>. </p>

<p>The VFS lets you replace built-in ServiceStack templates with your own by simply copying the metadata or <a href="http://bit.ly/164YbrQ">HtmlFormat Template files</a> you want to customize and placing them in your Website Directory at:</p>

<pre><code>/Templates/HtmlFormat.html        // The auto HtmlFormat template
/Templates/IndexOperations.html   // The /metadata template
/Templates/OperationControl.html  // Individual operation template
</code></pre>

<p>Which you can customize locally that ServiceStack will pick up and use instead.</p>

<h2>
<a id="user-content-writable-virtual-file-system" class="anchor" href="#writable-virtual-file-system" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Writable Virtual File System</h2>

<p>The Virtual File System extended <code>IVirtualFiles</code> interface extends the read-only <code>IVirtualPathProvider</code> interface to offer a read/write API:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">interface</span> <span class="pl-en">IVirtualFiles</span> : <span class="pl-k">IVirtualPathProvider</span>
{
  <span class="pl-k">void</span> <span class="pl-en">WriteFile</span>(<span class="pl-k">string</span> <span class="pl-smi">filePath</span>, <span class="pl-k">string</span> <span class="pl-smi">textContents</span>);
  <span class="pl-k">void</span> <span class="pl-en">WriteFile</span>(<span class="pl-k">string</span> <span class="pl-smi">filePath</span>, <span class="pl-k">Stream</span> <span class="pl-smi">stream</span>);
  <span class="pl-k">void</span> <span class="pl-en">WriteFiles</span>(IEnumerable&lt;IVirtualFile&gt; files,Func&lt;IVirtualFile,string&gt; toPath=<span class="pl-c1">null</span>);
  <span class="pl-k">void</span> <span class="pl-en">AppendFile</span>(<span class="pl-k">string</span> <span class="pl-smi">filePath</span>, <span class="pl-k">string</span> <span class="pl-smi">textContents</span>);
  <span class="pl-k">void</span> <span class="pl-en">AppendFile</span>(<span class="pl-k">string</span> <span class="pl-smi">filePath</span>, <span class="pl-k">Stream</span> <span class="pl-smi">stream</span>);
  <span class="pl-k">void</span> <span class="pl-en">DeleteFile</span>(<span class="pl-k">string</span> <span class="pl-smi">filePath</span>);
  <span class="pl-k">void</span> <span class="pl-en">DeleteFiles</span>(IEnumerable&lt;string&gt; filePaths);
  <span class="pl-k">void</span> <span class="pl-en">DeleteFolder</span>(<span class="pl-k">string</span> <span class="pl-smi">dirPath</span>);
}</pre></div>

<blockquote>
<p>Folders are implicitly created when writing a file to folders that don't exist</p>
</blockquote>

<p>The new <code>IVirtualFiles</code> API is available in local FileSystem, In Memory and S3 Virtual path providers:</p>

<ul>
<li>FileSystemVirtualPathProvider</li>
<li>InMemoryVirtualPathProvider</li>
<li>S3VirtualPathProvider</li>
</ul>

<p>All <code>IVirtualFiles</code> providers share the same 
<a href="https://github.com/ServiceStack/ServiceStack.Aws/blob/master/tests/ServiceStack.Aws.Tests/S3/VirtualPathProviderTests.cs">VirtualPathProviderTests</a>
ensuring a consistent behavior where it's now possible to swap between different file storage backends with simple
configuration as seen in the <a href="#imgur">Imgur</a> and <a href="#restfiles">REST Files</a> examples.</p>

<h3>
<a id="user-content-virtualfiles-vs-virtualfilesources" class="anchor" href="#virtualfiles-vs-virtualfilesources" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>VirtualFiles vs VirtualFileSources</h3>

<p>As typically when saving uploaded files you'd only want files written to a single explicit File Storage provider,
ServiceStack keeps a distinction between the existing read-only Virtual File Sources it uses internally whenever a 
static file is requested and the new <code>IVirtualFiles</code> which is maintained in a separate <code>VirtualFiles</code> property on 
<code>IAppHost</code> and <code>Service</code> base class for easy accessibility:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">IAppHost</span>
{
    <span class="pl-c">// Read/Write Virtual FileSystem. Defaults to Local FileSystem.</span>
    IVirtualFiles <span class="pl-en">VirtualFiles</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }

    <span class="pl-c">// Cascading file sources, inc. Embedded Resources, File System, In Memory, S3.</span>
    IVirtualPathProvider <span class="pl-en">VirtualFileSources</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Service</span> : <span class="pl-k">IService</span> //<span class="pl-k">ServiceStack</span>'<span class="pl-k">s</span> <span class="pl-k">convenient</span> <span class="pl-k">concrete</span> <span class="pl-k">base</span> <span class="pl-k">class</span>
{
    <span class="pl-c">//...</span>
    <span class="pl-k">public</span> IVirtualPathProvider <span class="pl-en">VirtualFiles</span> { <span class="pl-k">get</span>; }
    <span class="pl-k">public</span> IVirtualPathProvider <span class="pl-en">VirtualFileSources</span> { <span class="pl-k">get</span>; }
}</pre></div>

<p>Internally ServiceStack only uses <code>VirtualFileSources</code> itself to serve static file requests. 
The new <code>IVirtualFiles</code> is a clean abstraction your Services can bind to when saving uploaded files which can be easily
substituted when you want to change file storage backends. If not specified, <code>VirtualFiles</code> defaults to your local 
filesystem at your host project's root directory.</p>

<h3>
<a id="user-content-examples" class="anchor" href="#examples" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Examples</h3>

<ul>
<li>
<a href="https://github.com/ServiceStack/ServiceStack.Aws#maintain-website-content-in-s3">AWS RazorRockstars</a> - Serving all Razor Views and Markdown Content from a S3 bucket</li>
<li>
<a href="https://github.com/ServiceStack/ServiceStack.Aws#aws-imgur">AWS Imgur and REST Files</a> - 1 line configuration switch between saving files to local files or S3 Bucket</li>
</ul>

<h2>
<a id="user-content-implementing-a-new-virtual-file-system" class="anchor" href="#implementing-a-new-virtual-file-system" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Implementing a new Virtual File System</h2>

<p>The VFS is designed to be implementation agnostic so can be changed to use any file repository, e.g. it could easily be made to support a Redis, RDBMS, embedded Sqlite or other NoSQL back-ends.</p>

<p>Like most of ServiceStack's substitutable API's, the interfaces for the VFS lives in the <strong>ServiceStack.Interfaces.dll</strong> under the <a href="https://github.com/ServiceStack/ServiceStack/tree/master/src/ServiceStack.Interfaces/IO">ServiceStack.IO</a> namespace.</p>

<p>These are the API's that are needed to be implemented in order to create a new VFS:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">interface</span> <span class="pl-en">IVirtualPathProvider</span>
{
    IVirtualDirectory <span class="pl-en">RootDirectory</span> { <span class="pl-k">get</span>; }
    <span class="pl-k">string</span> <span class="pl-en">VirtualPathSeparator</span> { <span class="pl-k">get</span>; }
    <span class="pl-k">string</span> <span class="pl-en">RealPathSeparator</span> { <span class="pl-k">get</span>; }

    <span class="pl-k">string</span> <span class="pl-en">CombineVirtualPath</span>(<span class="pl-k">string</span> <span class="pl-smi">basePath</span>, <span class="pl-k">string</span> <span class="pl-smi">relativePath</span>);

    <span class="pl-k">bool</span> <span class="pl-en">FileExists</span>(<span class="pl-k">string</span> <span class="pl-smi">virtualPath</span>);
    <span class="pl-k">bool</span> <span class="pl-en">DirectoryExists</span>(<span class="pl-k">string</span> <span class="pl-smi">virtualPath</span>);

    IVirtualFile <span class="pl-en">GetFile</span>(<span class="pl-k">string</span> <span class="pl-smi">virtualPath</span>);
    <span class="pl-k">string</span> <span class="pl-en">GetFileHash</span>(<span class="pl-k">string</span> <span class="pl-smi">virtualPath</span>);
    <span class="pl-k">string</span> <span class="pl-en">GetFileHash</span>(<span class="pl-k">IVirtualFile</span> <span class="pl-smi">virtualFile</span>);

    IVirtualDirectory <span class="pl-en">GetDirectory</span>(<span class="pl-k">string</span> <span class="pl-smi">virtualPath</span>);

    IEnumerable&lt;IVirtualFile&gt; <span class="pl-en">GetAllMatchingFiles</span>(
        <span class="pl-k">string</span> <span class="pl-smi">globPattern</span>, <span class="pl-k">int</span> <span class="pl-smi">maxDepth</span> <span class="pl-k">=</span> Int32.MaxValue);

    <span class="pl-k">bool</span> <span class="pl-en">IsSharedFile</span>(<span class="pl-k">IVirtualFile</span> <span class="pl-smi">virtualFile</span>);
    <span class="pl-k">bool</span> <span class="pl-en">IsViewFile</span>(<span class="pl-k">IVirtualFile</span> <span class="pl-smi">virtualFile</span>);
}

<span class="pl-k">public</span> <span class="pl-k">interface</span> <span class="pl-en">IVirtualNode</span>
{
    IVirtualDirectory <span class="pl-en">Directory</span> { <span class="pl-k">get</span>; }
    <span class="pl-k">string</span> <span class="pl-en">Name</span> { <span class="pl-k">get</span>; }
    <span class="pl-k">string</span> <span class="pl-en">VirtualPath</span> { <span class="pl-k">get</span>; }
    <span class="pl-k">string</span> <span class="pl-en">RealPath</span> { <span class="pl-k">get</span>; }
    <span class="pl-k">bool</span> <span class="pl-en">IsDirectory</span> { <span class="pl-k">get</span>; }
    DateTime <span class="pl-en">LastModified</span> { <span class="pl-k">get</span>; }
}

<span class="pl-k">public</span> <span class="pl-k">interface</span> <span class="pl-en">IVirtualFile</span> : <span class="pl-k">IVirtualNode</span>
{
    IVirtualPathProvider <span class="pl-en">VirtualPathProvider</span> { <span class="pl-k">get</span>; }
    <span class="pl-k">string</span> <span class="pl-en">Extension</span> { <span class="pl-k">get</span>; }
    <span class="pl-k">string</span> <span class="pl-en">GetFileHash</span>();
    Stream <span class="pl-en">OpenRead</span>();
    StreamReader <span class="pl-en">OpenText</span>();
    <span class="pl-k">string</span> <span class="pl-en">ReadAllText</span>();
}

<span class="pl-k">public</span> <span class="pl-k">interface</span> <span class="pl-en">IVirtualDirectory</span> : <span class="pl-k">IVirtualNode</span>, <span class="pl-k">IEnumerable</span>&lt;<span class="pl-k">IVirtualNode</span>&gt;
{
    <span class="pl-k">bool</span> <span class="pl-en">IsRoot</span> { <span class="pl-k">get</span>; }
    IVirtualDirectory <span class="pl-en">ParentDirectory</span> { <span class="pl-k">get</span>; }

    IEnumerable&lt;IVirtualFile&gt; <span class="pl-en">Files</span> { <span class="pl-k">get</span>; }
    IEnumerable&lt;IVirtualDirectory&gt; <span class="pl-en">Directories</span> { <span class="pl-k">get</span>; }

    IVirtualFile <span class="pl-en">GetFile</span>(<span class="pl-k">string</span> <span class="pl-smi">virtualPath</span>);
    IVirtualFile <span class="pl-en">GetFile</span>(Stack&lt;string&gt; virtualPath);

    IVirtualDirectory <span class="pl-en">GetDirectory</span>(<span class="pl-k">string</span> <span class="pl-smi">virtualPath</span>);
    IVirtualDirectory <span class="pl-en">GetDirectory</span>(Stack&lt;string&gt; virtualPath);

    IEnumerable&lt;IVirtualFile&gt; <span class="pl-en">GetAllMatchingFiles</span>(
        <span class="pl-k">string</span> <span class="pl-smi">globPattern</span>, <span class="pl-k">int</span> <span class="pl-smi">maxDepth</span> <span class="pl-k">=</span> Int32.MaxValue);
}</pre></div>
