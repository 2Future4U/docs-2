<p>The <code>[CacheResponse]</code> is a normal <a href="https://github.com/ServiceStack/ServiceStack/wiki/Filter-attributes">Request Filter Attribute</a>
which can be added at the top-level of your Service class in which case it will cache the response of 
<strong>All</strong> Service implementations for <strong>60 seconds</strong>, e.g:</p>

<div class="highlight highlight-source-cs"><pre>[CacheResponse(Duration = <span class="pl-c1">60</span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">CachedServices</span> : <span class="pl-k">Service</span> 
{ 
    <span class="pl-k">public</span> <span class="pl-k">object</span> <span class="pl-en">Any</span>(<span class="pl-k">GetCustomer</span> <span class="pl-smi">request</span>) { ... }

    <span class="pl-k">public</span> <span class="pl-k">object</span> <span class="pl-en">Any</span>(<span class="pl-k">GetCustomerOrders</span> <span class="pl-smi">request</span>) { ... }
}</pre></div>

<p>It can also be applied individually on a single Service implementation:</p>

<div class="highlight highlight-source-cs"><pre>[CacheResponse(Duration = <span class="pl-c1">60</span>)]
<span class="pl-k">public</span> <span class="pl-k">object</span> Any(GetCustomer request)
{
    <span class="pl-k">return</span> Db.SingleById&lt;Customer&gt;(request.Id);
}</pre></div>

<p>Or on Request DTO's, as we saw earlier on the <code>QueryRockstarAlbums</code> AutoQuery DynamoDB Request DTO:</p>

<div class="highlight highlight-source-cs"><pre>[CacheResponse(Duration = <span class="pl-c1">60</span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">QueryRockstarAlbums</span> : <span class="pl-k">QueryData</span>&lt;<span class="pl-k">RockstarAlbum</span>&gt; { ... }</pre></div>

<p>However adding Request Filter Attributes <strong>on Request DTO's</strong> goes against our recommendation for keeping 
your DTO's in a separate implementation and dependency-free <strong>ServiceModel.dll</strong> as it would require a 
dependency on the non-PCL <strong>ServiceStack.dll</strong> which would prohibit being able to reuse your existing 
DTO .dll in PCL libraries, limiting their potential re-use.</p>

<p>You can still take advantage of the <code>[CacheResponse]</code> attribute on AutoQuery Services by defining
a custom implementation, at which point adding the <code>[CacheResponse]</code> attribute behaves as normal and 
applies caching to your Service implementations. E.g. you can enable caching for multiple AutoQuery 
Services with:</p>

<div class="highlight highlight-source-cs"><pre>[CacheResponse(Duration = <span class="pl-c1">60</span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">MyCachedAutoQueryServices</span> : <span class="pl-k">Service</span> 
{
    <span class="pl-k">public</span> IAutoQueryData <span class="pl-en">AutoQuery</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }

    <span class="pl-k">public</span> <span class="pl-k">object</span> <span class="pl-en">Any</span>(<span class="pl-k">QueryRockstars</span> <span class="pl-smi">query</span>) =&gt;
        <span class="pl-en">AutoQuery.Execute</span>(query, AutoQuery.CreateQuery(query, Request));

    <span class="pl-k">public</span> <span class="pl-k">object</span> <span class="pl-en">Any</span>(<span class="pl-k">QueryRockstarAlbums</span> <span class="pl-smi">query</span>) =&gt;
        <span class="pl-en">AutoQuery.Execute</span>(query, AutoQuery.CreateQuery(query, Request));
}</pre></div>

<h4>
<a id="user-content-server-cached-and-http-caching-enabled-responses" class="anchor" href="#server-cached-and-http-caching-enabled-responses" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Server Cached and HTTP Caching enabled responses</h4>

<p>When only specifying a <code>Duration=60</code> ServiceStack only <strong>caches the Server Response</strong> so it behaves similar
to using the existing <code>ToOptimizedResult()</code> API, e.g:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">object</span> Any(GetCustomer request)
{
    <span class="pl-k">return</span> Request.ToOptimizedResultUsingCache(Cache, 
        Request.RawUrl, TimeSpan.FromSeconds(<span class="pl-c1">60</span>), 
        () =&gt; Db.SingleById&lt;Customer&gt;(request.Id));
}</pre></div>

<p>To also enable <strong>HTTP Caching</strong> features you'll need to opt-in by specifying an additional HTTP Caching directive. 
E.g. including a <code>MaxAge</code> instructs ServiceStack to apply <strong>HTTP Caching</strong> logic and return the appropriate headers:</p>

<div class="highlight highlight-source-cs"><pre>[CacheResponse(Duration=<span class="pl-c1">60</span>, MaxAge=<span class="pl-c1">30</span>)]
<span class="pl-k">public</span> <span class="pl-k">object</span> Any(GetCustomer request) =&gt; Db.SingleById&lt;Customer&gt;(request.Id);</pre></div>

<p>Where subsequent identical requests from a <strong>cache-aware client</strong> will return their locally cached version 
within the first <strong>30 seconds</strong>, between <strong>30-60 seconds</strong> the client will re-validate the request with the 
Server who will return a <strong>304 NotModified</strong> Response with an <strong>Empty Body</strong>, after <strong>60 seconds</strong> the cache 
expires and the next request will <strong>re-execute the Service</strong> and populate the cache with a new response.</p>

<h4>
<a id="user-content-cacheresponse-properties" class="anchor" href="#cacheresponse-properties" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>CacheResponse Properties</h4>

<p>The Caching behavior of the <code>[CacheResponse]</code> attribute can be further customized using any of the 
additional properties below:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">int</span> Duration              <span class="pl-c">// Cache expiry in seconds</span>
<span class="pl-k">int</span> MaxAge                <span class="pl-c">// MaxAge in seconds</span>
CacheControl CacheControl <span class="pl-c">// Customize Cache-Control HTTP Headers</span>
<span class="pl-k">bool</span> VaryByUser           <span class="pl-c">// Vary cache per user</span>
<span class="pl-k">string</span>[] VaryByRoles      <span class="pl-c">// Vary cache for users in these roles</span>
<span class="pl-k">bool</span> LocalCache           <span class="pl-c">// Use In Memory HostContext.LocalCache or HostContext.Cache</span></pre></div>

<p>Using any of the other HTTP Cache properties will also trigger the HTTP Caching features. 
When a <code>MaxAge</code> isn't specified, i.e:</p>

<div class="highlight highlight-source-cs"><pre>[CacheResponse(Duration = <span class="pl-c1">10</span>, VaryByUser = <span class="pl-c1">true</span>)]
<span class="pl-k">public</span> <span class="pl-k">object</span> Any(GetUserActivity request) { ... }</pre></div>

<p>ServiceStack falls back to use the <code>HttpCacheFeature.DefaultMaxAge</code> which defaults to <strong>10 minutes</strong>, 
in addition to the <code>VaryByUser</code> flag will construct a unique cache key for each user and return an additional 
<code>Vary: Cookie</code> HTTP Response Header.</p>

<h3>
<a id="user-content-advanced-cacheinfo-customization" class="anchor" href="#advanced-cacheinfo-customization" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Advanced CacheInfo Customization</h3>

<p>One limitation of using a .NET Attribute to specify caching behavior is that we're limited to using 
.NET constant primitives prohibiting the use of allowing custom lambda's to capture custom behavior. 
This is also the reason why we need to use <code>int</code> for <code>Duration</code> and <code>MaxAge</code> instead of a more appropriate 
<code>TimeSpan</code>.</p>

<p>But we can still intercept the way the <code>[CacheResponse]</code> attribute works behind-the-scenes and programmatically 
enhance it with custom logic. 
<a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack/CacheResponseAttribute.cs">CacheResponseAttribute</a>
is just a wrapper around initializing a populated 
<a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack/CacheInfo.cs">CacheInfo</a> POCO
that it drops into the <code>IRequest.Items</code> dictionary where it's visible to your Service and any remaining Filters 
in ServiceStack's <a href="https://github.com/ServiceStack/ServiceStack/wiki/Order-of-Operations">Request Pipeline</a>. 
Essentially it's just doing this:</p>

<div class="highlight highlight-source-cs"><pre>req.Items[Keywords.CacheInfo] = <span class="pl-k">new</span> CacheInfo { ... };</pre></div>

<p>The actual validation logic for processing the <code>CacheInfo</code> is encapsulated within the <code>HttpCacheFeature</code> 
Response Filter. This gives our Service a chance to modify it's behavior, e.g. in order to generically
handle all Service responses the <code>[CacheResponse]</code> attribute uses the <code>IRequest.RawUrl</code> 
(the URL minus the domain) for the base CacheKey. Whilst using a RawUrl is suitable in uniquely identifying 
most requests, if QueryString params were sent in a different case or in a different order it would generate 
a different url and multiple caches for essentially the same request. We can remedy this behavior by changing 
the base CacheKey used which is just a matter retrieving the populated the <code>CacheInfo</code> and change the 
<code>KeyBase</code> to use the predictable <a href="https://github.com/ServiceStack/ServiceStack/wiki/Routing#reverse-routing">Reverse Routing</a>
<code>ToGetUrl()</code> API instead, e.g:</p>

<div class="highlight highlight-source-cs"><pre>[CacheResponse(Duration = <span class="pl-c1">60</span>)]
<span class="pl-k">public</span> <span class="pl-k">object</span> Get(MyRequest request)
{
    <span class="pl-k">var</span> cacheInfo = (CacheInfo)<span class="pl-c1">base</span>.Request.GetItem(Keywords.CacheInfo);
    cacheInfo.KeyBase = request.ToGetUrl(); <span class="pl-c">//custom cache key</span>
    <span class="pl-k">if</span> (Request.HandleValidCache(cacheInfo))
        <span class="pl-k">return</span> <span class="pl-c1">null</span>;
    ...

    <span class="pl-k">return</span> response;
}</pre></div>

<p><code>HandleValidCache()</code> is used to re-validate the client's request with the new Cache Key and if it's determined
the Client has a valid cache, will short-circuit the Service and return a <strong>304 NotModified</strong> Response.</p>
