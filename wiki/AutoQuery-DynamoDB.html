<p>AutoQuery Data's <code>DynamoDbSource</code> provides the most productive development experience for effortlessly creating rich, queryable and optimized Services for <a href="https://aws.amazon.com/dynamodb/">DynamoDB data stores</a>.</p>

<p><a href="https://github.com/ServiceStack/PocoDynamo"><img src="https://raw.githubusercontent.com/ServiceStack/Assets/master/img/release-notes/dynamodb-banner.png" alt="" style="max-width:100%;"></a></p>

<p>DynamoDB is the near perfect solution if you're on AWS and in need of a managed NoSQL data storage solution 
that can achieve near-infinite scale whilst maintaining constant single-digit millisecond performance. 
The primary issue with DynamoDB however is working with it's unstructured schema and API's which is reflected 
in the official .NET DynamoDB client providing a flexible but low-level and cumbersome development experience 
to work with directly. Most of these shortcomings are resolved with our POCO-friendly 
<a href="https://github.com/ServiceStack/PocoDynamo">PocoDynamo</a> client which provides an intuitive and idiomatic 
Typed .NET API that lets you reuse your DTO's and OrmLite POCO Data Models for persistence in DynamoDB.</p>

<p>Querying in DynamoDB is even more cumbersome, unlike an RDBMS which can process ad hoc queries on non-indexed 
fields with decent performance, every query in DynamoDB needs to be performed on an index defined ahead-of-time. 
Any queries not on an index needs to be sent as a Filter Expression and even more limiting is that queries 
can only be executed against rows containing the same hash id. If you need to query data spanning across 
multiple hash ids you either need to create a separate 
<a href="http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GSI.html">Global Index</a> 
or perform a full 
<a href="http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html#QueryAndScan.Scan">SCAN operation</a> 
which is even slower than full table scans on an RDBMS as they need to be performed on all underlying sharded 
nodes which can quickly eat up your reserved provisioned throughput allotted to your DynamoDB table.</p>

<h3>
<a id="user-content-optimal-dynamodb-queries" class="anchor" href="#optimal-dynamodb-queries" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Optimal DynamoDB Queries</h3>

<p>With AutoQuery's <code>DynamoDbSource</code> a lot of these nuances are transparently handled where it will automatically 
create the most optimal DynamoDB Query based on the fields populated on the incoming AutoQuery Request DTO. 
E.g. it will perform a 
<a href="http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html#QueryAndScan.Query">DynamoDB Query</a>
when the <strong>Hash</strong> field is populated otherwise transparently falls back into a 
<a href="http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html#QueryAndScan.Scan">Scan Operation</a>. 
Any conditions that query an Index field are added to the 
<a href="http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html#QueryAndScan.Query">Key Condition</a>, 
starting first with the <strong>Range Key</strong> (if specified), otherwise uses any populated <strong>Local Indexes</strong> it can 
find before any of the remaining conditions are added to the 
<a href="http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html#FilteringResults">Filter Expression</a>.</p>

<p>Transparently adopting the most optimal queries dramatically reduces development time as it lets you quickly
create, change and delete DynamoDB Services without regard for Indexes where it will often fallback to 
<strong>SCAN</strong> operations (performance of which is unnoticeable during development). Then once you're project is 
ready to deploy to production, go back and analyze all remaining queries your System relies on at the end 
then re-create tables with the appropriate indexes so that all App queries are efficiently querying an index.</p>

<blockquote>
<p>When needed you can specify <code>.DynamoDbSource&lt;T&gt;(allowScans:false)</code> to disable anyone from executing SCAN 
requests when deployed to production.</p>
</blockquote>

<h3>
<a id="user-content-download" class="anchor" href="#download" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Download</h3>

<p>To Get Started Install <a href="https://github.com/ServiceStack/ServiceStack.Aws">ServiceStack's AWS Support package</a> from NuGet:</p>

<pre><code>PM&gt; Install-Package ServiceStack.Aws
</code></pre>

<h3>
<a id="user-content-simple-autoquery-data-example" class="anchor" href="#simple-autoquery-data-example" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Simple AutoQuery Data Example</h3>

<p>To illustrate how to use AutoQuery with DynamoDB we'll walk through a simple example of querying Rockstars Albums. 
For this example we'll specify
<a href="https://github.com/ServiceStack/ServiceStack/wiki/Auto-Query#explicit-conventions">explicit conventions</a>
so we can use ServiceStack's 
<a href="https://github.com/ServiceStack/ServiceStack/wiki/C%23-client">typed .NET Service Clients</a> 
to show which fields we're going to query and also lets us call the Service with a convenient typed API:</p>

<div class="highlight highlight-source-cs"><pre>[Route(<span class="pl-s"><span class="pl-pds">"</span>/rockstar-albums<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">QueryRockstarAlbums</span> : <span class="pl-k">QueryData</span>&lt;<span class="pl-k">RockstarAlbum</span>&gt;
{
    <span class="pl-k">public</span> <span class="pl-k">int</span>? <span class="pl-en">Id</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }         <span class="pl-c">// Primary Key | Range Key</span>
    <span class="pl-k">public</span> <span class="pl-k">int</span>? <span class="pl-en">RockstarId</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; } <span class="pl-c">// Foreign key | Hash Key</span>
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Name</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Genre</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-k">int</span>[] <span class="pl-en">IdBetween</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}</pre></div>

<p>Here we see that creating DynamoDB Queries is no different to any other AutoQuery Data Service, where the 
same definition is used irrespective if the data source was populated from a <code>MemorySource</code>, <code>ServiceSource</code> 
or <code>DynamoDbSource</code> and the only thing that would need to change to have it query an RDBMS instead is the 
<code>QueryDb&lt;T&gt;</code> base class.</p>

<p>The text in comments highlight that when the <code>RockstarAlbum</code> POCO is stored in an RDBMS 
<a href="https://github.com/ServiceStack/ServiceStack.OrmLite">OrmLite</a> 
creates the table with the <code>Id</code> as the Primary Key and <code>RockstarId</code> as a Foreign Key to the <code>Rockstar</code> table. 
This is different in DynamoDB where 
<a href="https://github.com/ServiceStack/PocoDynamo">PocoDynamo</a> behavior is to keep related records together so
they can be efficiently queried and will instead Create the <code>RockstarAlbum</code> DynamoDB Table with the 
<code>RockstarId</code> as the Hash Key and its unique <code>Id</code> as the Range Key.</p>

<h4>
<a id="user-content-register-dynamodbsource" class="anchor" href="#register-dynamodbsource" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Register DynamoDbSource</h4>

<p>To use DynamoDB AutoQuery's you need to first configure 
<a href="https://github.com/ServiceStack/PocoDynamo#download">PocoDynamo</a> 
which is just a matter of passing an an initialized <code>AmazonDynamoDBClient</code> and telling PocoDynamo which 
DynamoDB tables you intend to use:</p>

<div class="highlight highlight-source-cs"><pre>container.Register(c =&gt; <span class="pl-k">new</span> PocoDynamo(<span class="pl-k">new</span> AmazonDynamoDBClient(...))
    .RegisterTable&lt;Rockstar&gt;()
    .RegisterTable&lt;RockstarAlbum&gt;()
);</pre></div>

<p>Then before using PocoDynamo, call <code>InitSchema()</code> to tell it to automatically go through and create all 
DynamoDB Tables that were registered but don't yet exist in DynamoDB: </p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> dynamo = container.Resolve&lt;IPocoDynamo&gt;();
dynamo.InitSchema();</pre></div>

<p>So the first time <code>InitSchema()</code> is run it will create both <code>Rockstar</code> and <code>RockstarAlbum</code> tables but will 
no longer create any tables on any subsequent runs. After <code>InitSchema()</code> has completed we're assured that 
both <code>Rockstar</code> and <code>RockstarAlbum</code> tables exist so we can start using PocoDynamo's typed APIs to populate 
them with Data:</p>

<div class="highlight highlight-source-cs"><pre>dynamo.PutItems(<span class="pl-k">new</span> Rockstar[] { ... });
dynamo.PutItems(<span class="pl-k">new</span> RockstarAlbum[] { ... });</pre></div>

<blockquote>
<p>Behind the scenes PocoDynamo efficiently creates the minimum number of 
<a href="http://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_BatchWriteItem.html">BatchWriteItem</a>
requests as necessary to store all Rockstar and RockstarAlbum's.</p>
</blockquote>

<p>Now that we have data we can query we can register the AutoQuery Data plugin along with the <code>Rockstar</code> 
and <code>RockstarAlbum</code> DynamoDB Tables we want to be able to query: </p>

<div class="highlight highlight-source-cs"><pre>Plugins.Add(<span class="pl-k">new</span> AutoQueryDataFeature { MaxLimit = <span class="pl-c1">100</span> }
    .AddDataSource(ctx =&gt; ctx.DynamoDbSource&lt;Rockstar&gt;())
    .AddDataSource(ctx =&gt; ctx.DynamoDbSource&lt;RockstarAlbum&gt;())
);</pre></div>

<h4>
<a id="user-content-rockstaralbum-poco-table-definition" class="anchor" href="#rockstaralbum-poco-table-definition" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>RockstarAlbum POCO Table Definition</h4>

<p>Where <code>RockstarAlbum</code> is just a simple POCO and can be used as-is throughout all of ServiceStack's libraries
inc. OrmLite, Redis, Caching Providers, Serializers, etc:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">RockstarAlbum</span>
{
    [AutoIncrement]
    <span class="pl-k">public</span> <span class="pl-k">int</span> <span class="pl-en">Id</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }

    [References(typeof(Rockstar))]
    <span class="pl-k">public</span> <span class="pl-k">int</span> <span class="pl-en">RockstarId</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }

    [Index]
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Genre</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }

    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Name</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}</pre></div>

<p>PocoDynamo uses the same generic metadata attributes in <strong>ServiceStack.Interfaces</strong> as OrmLite. </p>

<p>When this POCO is created in OrmLite it creates: </p>

<ul>
<li>A <code>RockstarAlbum</code> table with an <code>Id</code> auto incrementing <strong>Primary Key</strong>
</li>
<li>The <code>RockstarId</code> as the <strong>Foreign Key</strong> for the <code>Rockstar</code> table </li>
<li>Adds an <strong>Index</strong> on the <code>Genre</code> column. </li>
</ul>

<p>Whereas in DynamoDB, PocoDynamo creates: </p>

<ul>
<li>The <code>RockstarAlbum</code> table with the <code>Id</code> as an auto incrementing <strong>Range Key</strong>
</li>
<li>The <code>RockstarId</code> as the <strong>Hash Key</strong> </li>
<li>Creates a <a href="http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LSI.html">Local Secondary Index</a> for the Genre attribute.</li>
</ul>

<h3>
<a id="user-content-typed-autoquery-dynamodb-queries" class="anchor" href="#typed-autoquery-dynamodb-queries" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Typed AutoQuery DynamoDB Queries</h3>

<p>Since the properties we want to query are explicitly typed we can make use of ServiceStack's nice typed 
Service Client API's to call this Service and fetch Kurt Cobains <strong>Grunge</strong> Albums out of the first 5 recorded:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> response = client.Get(<span class="pl-k">new</span> QueryRockstarAlbums { <span class="pl-c">//QUERY </span>
    RockstarId = kurtCobainId, <span class="pl-c">//Key Condition</span>
    IdBetween = <span class="pl-k">new</span>[]{ <span class="pl-c1">1</span>, <span class="pl-c1">5</span> }, <span class="pl-c">//Key Condition</span>
    Genre = <span class="pl-s"><span class="pl-pds">"</span>Grunge<span class="pl-pds">"</span></span>,          <span class="pl-c">//Filter Condition</span>
});

response.PrintDump(); <span class="pl-c">// Pretty print results to Console</span></pre></div>

<p>As illustrated in the comments, DynamoDB AutoQuery performs the most efficient DynamoDB Query required in 
order to satisfy this request where it will create a 
<a href="http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html#QueryAndScan.Query">Query Request</a>
with the <code>RockstarId</code> and <code>IdBetween</code> conditions added to the <strong>Key Condition</strong> and the remaining <code>Genre</code>
added as a <strong>Filter Expression</strong>.</p>

<p>If we instead wanted to fetch all of Kurt Cobains <strong>Grunge</strong> Albums where there was no longer a condition on 
the Album <code>Id</code> <strong>Range Key</strong>, i.e:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> response = client.Get(<span class="pl-k">new</span> QueryRockstarAlbums { <span class="pl-c">//QUERY</span>
    RockstarId = kurtCobainId, <span class="pl-c">//Key Condition</span>
    Genre = <span class="pl-s"><span class="pl-pds">"</span>Grunge<span class="pl-pds">"</span></span>,          <span class="pl-c">//Key Condition</span>
});</pre></div>

<p>It would instead create a <strong>Query Request</strong> configured to use the Genre <strong>Local Secondary Index</strong> and have
added both <code>RockstarId</code> Hash Key and index <code>Genre</code> to the <strong>Key Condition</strong>.</p>

<p>But if you instead wanted to view all Grunge Albums, i.e:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> response = client.Get(<span class="pl-k">new</span> QueryRockstarAlbums { <span class="pl-c">//SCAN</span>
    Genre = <span class="pl-s"><span class="pl-pds">"</span>Grunge<span class="pl-pds">"</span></span>            <span class="pl-c">//Filter Condition</span>
});</pre></div>

<p>As no Hash Key was specified it would instead create a <strong>SCAN Request</strong> where as there's no index, it adds 
all conditions to the <strong>Filter Expression</strong>.</p>

<h3>
<a id="user-content-autoquery-dynamodb-global-index-queries" class="anchor" href="#autoquery-dynamodb-global-index-queries" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>AutoQuery DynamoDB Global Index Queries</h3>

<p>For times when you need to perform an efficient <strong>Query Request</strong> across multiple hash keys you will need to 
create a <a href="http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GSI.html">Global Secondary Index</a>.
Luckily this is easy to do in PocoDynamo where you can define Global Indexes with a simple POCO class definition:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">RockstarAlbumGenreIndex</span> : <span class="pl-k">IGlobalIndex</span>&lt;<span class="pl-k">RockstarAlbum</span>&gt;
{
    [HashKey]
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Genre</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }

    [RangeKey]
    <span class="pl-k">public</span> <span class="pl-k">int</span> <span class="pl-en">Id</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }

    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Name</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }    <span class="pl-c">// projected property</span>
    <span class="pl-k">public</span> <span class="pl-k">int</span> <span class="pl-en">RockstarId</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; } <span class="pl-c">// projected property</span>
}</pre></div>

<p>Global Indexes can be thought of as "automatically synced tables" specified with a different Hash Key. 
Just like DynamoDB tables you can specify the <strong>Hash Key</strong> you want to globally query and create the Index 
on as well as a separate <strong>Range Key</strong> you want to be able to perform efficient <strong>Key Condition</strong> queries on. 
You'll also want to specify any properties you want returned when querying the Global Index so they'll be 
automatically projected and stored with the Global Index, ensuring fast access.</p>

<p>Then to have PocoDynamo create the Global Index it should be referenced on the table the Global Index is on:</p>

<div class="highlight highlight-source-cs"><pre>[References(<span class="pl-k">typeof</span>(RockstarAlbumGenreIndex))]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">RockstarAlbum</span> { ... }</pre></div>

<p>When referenced, <code>InitSchema()</code> will create the <code>RockstarAlbumGenreIndex</code> Global Secondary Index when it
creates the <code>RockstarAlbum</code> DynamoDB Table.</p>

<p>With the Global Index created we can now query it just like we would any other DynamoDB AutoQuery but instead
of querying a table, we query the Index instead:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">QueryRockstarAlbumsGenreIndex</span> : <span class="pl-k">QueryData</span>&lt;<span class="pl-k">RockstarAlbumGenreIndex</span>&gt;
{
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Genre</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }     <span class="pl-c">// Hash Key</span>
    <span class="pl-k">public</span> <span class="pl-k">int</span>[] <span class="pl-en">IdBetween</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }  <span class="pl-c">// Range Key</span>
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Name</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}</pre></div>

<p>Once defined you can query it just like any other AutoQuery Service where you're now able to perform 
efficient queries by <strong>Genre</strong> across all Rockstar Album's:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> response = client.Get(<span class="pl-k">new</span> QueryRockstarAlbumsGenreIndex <span class="pl-c">//QUERY</span>
{
    Genre = <span class="pl-s"><span class="pl-pds">"</span>Grunge<span class="pl-pds">"</span></span>,              <span class="pl-c">//Key Condition</span>
    IdBetween = <span class="pl-k">new</span>[] { <span class="pl-c1">1</span>, <span class="pl-c1">1000</span> }, <span class="pl-c">//Key Condition</span>
});</pre></div>

<h3>
<a id="user-content-custom-poco-result-mappings" class="anchor" href="#custom-poco-result-mappings" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Custom POCO Result Mappings</h3>

<p>A noticeable difference from querying a Global Index instead of the Table directly is that results are
returned in a different <code>RockstarAlbumGenreIndex</code> POCO. Luckily we can use AutoQuery's 
<a href="https://github.com/ServiceStack/ServiceStack/wiki/Auto-Query#returning-custom-results">Custom Results Feature</a>
to map the properties back into the original table <code>RockstarAlbum</code> with:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">QueryRockstarAlbumsGenreIndex</span> : <span class="pl-k">QueryData</span>&lt;<span class="pl-k">RockstarAlbumGenreIndex</span>,<span class="pl-k">RockstarAlbum</span>&gt; 
{ 
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Genre</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-k">int</span>[] <span class="pl-en">IdBetween</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Name</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}</pre></div>

<p>Now when we query the Index we get our results populated in <code>RockstarAlbum</code> DTO's instead:</p>

<div class="highlight highlight-source-cs"><pre>QueryResponse&lt;RockstarAlbum&gt; response = client.Get(<span class="pl-k">new</span> QueryRockstarAlbumsGenreIndex
{
    Genre = <span class="pl-s"><span class="pl-pds">"</span>Grunge<span class="pl-pds">"</span></span>,              <span class="pl-c">//Key Condition</span>
    IdBetween = <span class="pl-k">new</span>[] { <span class="pl-c1">1</span>, <span class="pl-c1">1000</span> }, <span class="pl-c">//Key Condition</span>
});</pre></div>

<h3>
<a id="user-content-caching-autoquery-services" class="anchor" href="#caching-autoquery-services" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Caching AutoQuery Services</h3>

<p>One of the many benefits of AutoQuery Services being just regular ServiceStack Services is that we get
access to ServiceStack's rich ecosystem of enhanced functionality around existing Services. An example added
in this release is ServiceStack's new HTTP Caching feature which lets you easily cache a Service with
the new <code>[CacheResponse]</code> attribute, letting you declaratively specify how long you want to cache identical 
requests for on the <strong>Server</strong> as well as a <code>MaxAge</code> option for instructing the <strong>Client</strong> how long they should
consider their local cache is valid for and any custom <code>Cache-Control</code> behavior you want them to have, e.g:</p>

<div class="highlight highlight-source-cs"><pre>[Route(<span class="pl-s"><span class="pl-pds">"</span>/rockstar-albums<span class="pl-pds">"</span></span>)]
[CacheResponse(Duration = <span class="pl-c1">60</span>, MaxAge = <span class="pl-c1">30</span>, CacheControl = CacheControl.MustRevalidate)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">QueryRockstarAlbums</span> : <span class="pl-k">QueryData</span>&lt;<span class="pl-k">RockstarAlbum</span>&gt;
{
    <span class="pl-k">public</span> <span class="pl-k">int</span>? <span class="pl-en">Id</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }         
    <span class="pl-k">public</span> <span class="pl-k">int</span>? <span class="pl-en">RockstarId</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Genre</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-k">int</span>[] <span class="pl-en">IdBetween</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}</pre></div>

<p>So with just the above single Request DTO we've declaratively created a fully-queryable DynamoDB AutoQuery 
Service that transparently executes the most ideal DynamoDB queries for each request, has it's optimal 
representation efficiently cached on both Server and clients, whose Typed DTO can be reused as-is on the 
client to call Services with an end-to-end Typed API using any
<a href="https://github.com/ServiceStack/ServiceStack/wiki/C%23-client">.NET Service Client</a>, 
that's also available to external developers in a clean typed API, natively in their preferred language of 
choice, accessible with just a right-click menu integrated inside VS.NET, Xcode, Android Studio, IntelliJ 
and Eclipse - serving both PCL Xamarin.iOS/Android as well as native iOS and Android developers by just<br>
<a href="https://github.com/ServiceStack/ServiceStack/wiki/Add-ServiceStack-Reference">Adding a ServiceStack Reference</a>
to the base URL of a remote ServiceStack Instance - all without needing to write any implementation!</p>

<h3>
<a id="user-content-more-info" class="anchor" href="#more-info" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>More Info</h3>

<p>For more examples exploring different AutoQuery Data features checkout the
<a href="https://github.com/ServiceStack/ServiceStack/blob/master/tests/ServiceStack.WebHost.Endpoints.Tests/AutoQueryDataTests.cs">AutoQuery Data Tests</a>
and <a href="https://github.com/ServiceStack/ServiceStack/blob/master/tests/ServiceStack.WebHost.Endpoints.Tests/AutoQueryDataTests.Dynamo.cs">AutoQuery DynamoDB Tests</a>
that can be compared on a feature-by-feature basis against the existing
<a href="https://github.com/ServiceStack/ServiceStack/blob/master/tests/ServiceStack.WebHost.Endpoints.Tests/AutoQueryTests.cs">AutoQuery Tests</a>
they were originally based on.</p>
