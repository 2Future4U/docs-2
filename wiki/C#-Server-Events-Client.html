<p>Like ServiceStack's other <a href="https://github.com/ServiceStack/ServiceStack/wiki/C%23-client">C# Service Clients</a>, the new <code>ServerEventsClient</code> is a <a href="https://github.com/ServiceStackApps/HelloMobile">portable library</a> contained in the <code>ServiceStack.Client</code> NuGet package:</p>

<pre><code>PM&gt; Install-Package ServiceStack.Client
</code></pre>

<p>And like the Service Clients it requires the <code>BaseUri</code> of your ServiceStack instance as well as an optional <code>channel</code> for the client to subscribe to:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> client = <span class="pl-k">new</span> ServerEventsClient(
    <span class="pl-s"><span class="pl-pds">"</span>http://chat.servicestack.net<span class="pl-pds">"</span></span>, channels:<span class="pl-s"><span class="pl-pds">"</span>home<span class="pl-pds">"</span></span>);</pre></div>

<h3>
<a id="user-content-managed-connection" class="anchor" href="#managed-connection" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Managed Connection</h3>

<p>The <strong>C# ServerEvent Client</strong> is a managed .NET client with feature parity with the <a href="https://github.com/ServiceStackApps/Chat#client-bindings---ss-utilsjs">ServiceStack's JavaScript client</a> that <strong>auto-reconnects</strong> when a connection is lost, <strong>sends periodic heartbeats</strong> to maintain an active subscription as well as <strong>auto-unregistering</strong> once the client stops listening for messages, or gets disposed.</p>

<h3>
<a id="user-content-handling-server-events" class="anchor" href="#handling-server-events" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Handling Server Events</h3>

<p>Unlike other C# clients, the ServerEvents Client is mainly reactive in that it's primarily waiting for Server Events to be initiated from a remote server instead of the typical scenario in which requests are initiated by clients. To maximize utility, there are a number of different API's to receive and process messages:</p>

<h3>
<a id="user-content-assigning-callback-handlers" class="anchor" href="#assigning-callback-handlers" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Assigning Callback Handlers</h3>

<p>One way to receive messages (useful in long-running clients) is to assign handlers for each of the different events that are fired. This example shows how to capture all the different events a Client can receive:</p>

<div class="highlight highlight-source-cs"><pre>ServerEventConnect connectMsg = <span class="pl-c1">null</span>;
<span class="pl-k">var</span> msgs = <span class="pl-k">new</span> List&lt;ServerEventMessage&gt;();
<span class="pl-k">var</span> commands = <span class="pl-k">new</span> List&lt;ServerEventMessage&gt;();
<span class="pl-k">var</span> errors = <span class="pl-k">new</span> List&lt;Exception&gt;();

<span class="pl-k">var</span> client = <span class="pl-k">new</span> ServerEventsClient(baseUri) {
    OnConnect = e =&gt; connectMsg = e,
    OnCommand = commands.Add,
    OnMessage = msgs.Add,
    OnException = errors.Add,
}.Start();</pre></div>

<p>Once the Client is configured, calling <code>Start()</code> will start listening for messages and calling <code>Stop()</code> or <code>Dispose()</code> will cancel the background HTTP connection and stop it listening for server events.</p>

<h3>
<a id="user-content-customizing-metadata-sent-to-clients" class="anchor" href="#customizing-metadata-sent-to-clients" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Customizing Metadata sent to clients</h3>

<p>As ServerEvents have deep integration with the rest of ServiceStack we're able to offer <a href="https://github.com/ServiceStack/ServiceStack/blob/71b51d231d1ddb2ba7da39613e216ab75fd181c0/src/ServiceStack.Client/ServerEventsClient.cs#L14-L44">Typed Messages</a> containing the users <code>UserAuthId</code>, <code>DisplayName</code> and <code>ProfileUrl</code> of the users avatar when it's available. The typed messages also offer an extensible <code>Dictionary&lt;string,string&gt; Meta</code> collection for maintaining custom metadata that can be sent to clients by appending to them in the ServerEventsFeature hooks, which can be defined when registering <code>ServerEventsFeature</code>:</p>

<div class="highlight highlight-source-cs"><pre>Plugins.Add(<span class="pl-k">new</span> ServerEventsFeature { 
    <span class="pl-c">// private Connect args</span>
    OnConnect = (subscription,httpReq) =&gt; AppendTo(subscription.Meta),

    <span class="pl-c">// public Join/Leave args</span>
    OnCreated = (subscription,httpReq) =&gt; AppendTo(subscription.Meta), 
})</pre></div>

<h3>
<a id="user-content-using-c-asyncawait-friendly-apis" class="anchor" href="#using-c-asyncawait-friendly-apis" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Using C# Async/Await friendly API's</h3>

<p>Depending on your use-case, if you only want to use the ServerEvent Client for a short-time to listen for predictable responses (i.e. waiting for a Server callback on a pending request) you can alternatively use the Task-based API's letting you to participate in C# async/await workflows:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> client = <span class="pl-k">new</span> ServerEventsClient(baseUri, channel=<span class="pl-s"><span class="pl-pds">"</span>Home<span class="pl-pds">"</span></span>);

<span class="pl-c">// Wait to receive onConnect event</span>
ServerEventConnect connectMsg = <span class="pl-k">await</span> client.Connect();

<span class="pl-c">// Wait to receive onJoin command event</span>
ServerEventCommand joinMsg = <span class="pl-k">await</span> client.WaitForNextCommand();

<span class="pl-c">// Hold a future task to get notified once a msg has been received</span>
Task&lt;ServerEventMessage&gt; msgTask = client1.WaitForNextMessage();

<span class="pl-c">// Send a Web Service Request using the built-in JsonServiceClient</span>
client.ServiceClient.Post(<span class="pl-k">new</span> PostChatToChannel {
    Channel = client.Channel,     <span class="pl-c">// The channel we're listening on</span>
    From = client.SubscriptionId, <span class="pl-c">// Populated after Connect() </span>
    Message = <span class="pl-s"><span class="pl-pds">"</span>Hello, World!<span class="pl-pds">"</span></span>,
});

<span class="pl-c">// Wait till we receive the chat Msg event we sent earlier</span>
ServerEventMessage msg = <span class="pl-k">await</span> msgTask;</pre></div>

<p>The above example showcases the <strong>3 Task-based API's</strong> available:</p>

<ol>
<li>
<code>Connect()</code> wait till receiving confirmation of a successful event subscription</li>
<li>
<code>WaitForNextCommand()</code> wait for the next <code>onJoin</code> or <code>onLeave</code> subscription events</li>
<li>
<code>WaitForNextMessage()</code> wait for the next message published to the channel</li>
</ol>

<p>The <code>ServiceClient</code> property lets you access a <code>JsonServiceClient</code> that's pre-configured with the clients <code>BaseUri</code> so that is primed for Sending Web Service Requests with.</p>

<p>After the ServerEvent Client has connected, the <code>ConnectionInfo</code> property is populated with the typed <code>ServerEventConnect</code> response. </p>

<h3>
<a id="user-content-message-event-handlers" class="anchor" href="#message-event-handlers" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Message Event Handlers</h3>

<p>The above examples show generic API's for receiving any type of message, but just like in the JavaScript client, more fine-grained API's are available for handling specific message types.</p>

<p>The <code>Handlers</code> dictionary is akin to the JavaScript Client's <a href="https://github.com/ServiceStackApps/Chat#global-event-handlers">Global Event Handlers</a> which specify lambda's to be executed when messages are sent with the <code>cmd.*</code> selector:</p>

<div class="highlight highlight-source-cs"><pre>client.Handlers[<span class="pl-s"><span class="pl-pds">"</span>chat<span class="pl-pds">"</span></span>] = (client, msg) =&gt; {
    <span class="pl-c">//Deserialize JSON string to typed DTO</span>
    <span class="pl-k">var</span> chatMsg = msg.Json.FromJson&lt;ChatMessage&gt;(); 
    <span class="pl-s"><span class="pl-pds">"</span>Received '{0}' from '{1}'<span class="pl-pds">"</span></span>.Print(chatMsg.Message, chatMsg.FromName);
};</pre></div>

<p>Roughly translates to the equivalent JavaScript below:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-en">$</span>(source).<span class="pl-en">handleServerEvents</span>({
  handlers<span class="pl-k">:</span> {
    <span class="pl-en">chat</span><span class="pl-k">:</span> <span class="pl-k">function</span> (<span class="pl-smi">msg</span>, <span class="pl-c1">event</span>) {
        <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">"</span>Received <span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-smi">msg</span>.<span class="pl-smi">message</span> <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span> from <span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-smi">msg</span>.<span class="pl-smi">fromName</span>);
    }
  }
});</pre></div>

<p>Where both methods handle the <code>ChatMessage</code> sent with the <code>cmd.chat</code> selector.</p>

<h3>
<a id="user-content-named-receivers" class="anchor" href="#named-receivers" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Named Receivers</h3>

<p>Whilst handlers provide a light way to handle loose-typed messages, there's a more structured and typed option that works similar to ServiceStack's <code>IService</code> classes but are used to instead handle typed Server Event Messages. </p>

<p>To be able to handle messages with your own classes, get them to implement the <code>IReceiver</code> empty marker interface:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">interface</span> <span class="pl-en">IReceiver</span>
{
    <span class="pl-k">void</span> <span class="pl-en">NoSuchMethod</span>(<span class="pl-k">string</span> <span class="pl-smi">selector</span>, <span class="pl-k">object</span> <span class="pl-smi">message</span>);
}</pre></div>

<p>Whilst primarily a marker interface, <code>IReceiver</code> does include a <code>NoSuchMethod</code> API to be able to handle messages sent with a unknown selector <strong>target</strong> that doesn't match any defined method or property.</p>

<p><strong>Named Receivers</strong> are equivalent to <a href="https://github.com/ServiceStackApps/Chat#receivers">Receivers</a> in the JavaScript client which can be assigned to handle all messages sent to a receiver with the selector format:</p>

<pre><code>{receiver}.{target}
</code></pre>

<p>A Named Receiver can be registered with the API below:</p>

<div class="highlight highlight-source-cs"><pre>client.RegisterNamedReceiver&lt;TestNamedReceiver&gt;(<span class="pl-s"><span class="pl-pds">"</span>test<span class="pl-pds">"</span></span>);</pre></div>

<p>Which will forward all messages with a <code>test.*</code> selector to an instance of the <code>TestNamedReceiver</code> Type</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">TestNamedReceiver</span> : <span class="pl-k">ServerEventReceiver</span>
{
    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">FooMethod</span>(<span class="pl-k">CustomType</span> <span class="pl-smi">request</span>) {} <span class="pl-c">// void return type</span>

    <span class="pl-k">public</span> CustomType <span class="pl-en">BarMethod</span>(<span class="pl-k">CustomType</span> <span class="pl-smi">request</span>)
    {        
        <span class="pl-k">return</span> request; <span class="pl-c">// works with any return type, which are ignored</span>
    }

    <span class="pl-k">public</span> CustomType <span class="pl-en">BazSetter</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; } <span class="pl-c">// Auto populate properties</span>

    <span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-k">void</span> <span class="pl-en">NoSuchMethod</span>(<span class="pl-k">string</span> <span class="pl-smi">selector</span>, <span class="pl-k">object</span> <span class="pl-smi">message</span>)
    {
        <span class="pl-k">var</span> msg = (ServerEventMessage)message;
        <span class="pl-k">var</span> nonExistentMethodType = msg.Json.FromJson&lt;CustomType&gt;();
    }
}</pre></div>

<p>This is roughly equivalent to the following JavaScript code:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-en">$</span>(source).<span class="pl-en">handleServerEvents</span>({
    receivers<span class="pl-k">:</span> {
        test<span class="pl-k">:</span> {
            <span class="pl-en">FooMethod</span><span class="pl-k">:</span> <span class="pl-k">function</span> (<span class="pl-smi">msg</span>, <span class="pl-c1">event</span>) { <span class="pl-k">...</span> },
            <span class="pl-en">BarMethod</span><span class="pl-k">:</span> <span class="pl-k">function</span> (<span class="pl-smi">msg</span>, <span class="pl-c1">event</span>) { <span class="pl-k">...</span> },
            BazSetter<span class="pl-k">:</span> <span class="pl-c1">null</span>,            
        }
    }
});</pre></div>

<blockquote>
<p>The <a href="https://github.com/ServiceStack/ServiceStack/blob/68c7159037e7cf2a519d482b7dae524ca073da20/src/ServiceStack.Client/ServerEventsClient.Receiver.cs#L16-L28">ServerEventReceiver</a> is a convenient base class that in addition to implementing <code>IReceiver</code> interface, gets injected with the <code>Client</code> as well as additional context about the raw message available in <code>base.Request</code>.</p>
</blockquote>

<h4>
<a id="user-content-unknown-message-handling" class="anchor" href="#unknown-message-handling" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Unknown Message Handling</h4>

<p>One difference in the JavaScript client is that messages with <strong>unknown</strong> targets are assigned as properties on the <code>test</code> receiver, e.g <code>test.QuxTarget = {..}</code>.</p>

<h3>
<a id="user-content-sending-messages-to-named-receivers" class="anchor" href="#sending-messages-to-named-receivers" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Sending messages to Named Receivers</h3>

<p>Once registered, an instance of <code>TestNamedReceiver</code> will process messages sent with a <code>test.*</code> selector. The example below shows how to send a DTO to each of <code>TestNamedReceiver</code> defined methods and properties:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">MyEventServices</span> : <span class="pl-k">Service</span>
{
    <span class="pl-k">public</span> IServerEvents <span class="pl-en">ServerEvents</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Any</span>(<span class="pl-k">CustomType</span> <span class="pl-smi">request</span>)
    {
        ServerEvents.NotifyChannel(<span class="pl-s"><span class="pl-pds">"</span>home<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>test.FooMethod<span class="pl-pds">"</span></span>, request);
        ServerEvents.NotifyChannel(<span class="pl-s"><span class="pl-pds">"</span>home<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>test.BarMethod<span class="pl-pds">"</span></span>, request);
        ServerEvents.NotifyChannel(<span class="pl-s"><span class="pl-pds">"</span>home<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>test.BazSetter<span class="pl-pds">"</span></span>, request);

        ServerEvents.NotifyChannel(<span class="pl-s"><span class="pl-pds">"</span>home<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>test.QuxTarget<span class="pl-pds">"</span></span>, request);
    }
}</pre></div>

<h3>
<a id="user-content-life-cycle-of-receivers" class="anchor" href="#life-cycle-of-receivers" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Life-cycle of Receivers</h3>

<p>Similar to <strong>Services</strong> in ServiceStack, each message is processed with an instance of the Receiver that's resolved from <code>ServerEventsClient.Resolver</code> which by default uses the <a href="https://github.com/ServiceStack/ServiceStack/blob/ec0226b97227048c3bd7c24667a71e7af7e1ff31/src/ServiceStack.Client/ServerEventsClient.Receiver.cs#L30-L36">NewInstanceResolver</a> to execute messages using a new instance of the Receiver Type: </p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">NewInstanceResolver</span> : <span class="pl-k">IResolver</span>
{
    <span class="pl-k">public</span> T TryResolve&lt;T&gt;()
    {
        <span class="pl-k">return</span> <span class="pl-k">typeof</span>(T).CreateInstance&lt;T&gt;();
    }
}</pre></div>

<p>This can be changed to re-use the same instance by assigning a <a href="https://github.com/ServiceStack/ServiceStack/blob/ec0226b97227048c3bd7c24667a71e7af7e1ff31/src/ServiceStack.Client/ServerEventsClient.Receiver.cs#L38-L46">SingletonInstanceResolver</a> instead:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">SingletonInstanceResolver</span> : <span class="pl-k">IResolver</span>
{
    ConcurrentDictionary&lt;Type, <span class="pl-k">object</span>&gt; Cache = 
        <span class="pl-k">new</span> ConcurrentDictionary&lt;Type, <span class="pl-k">object</span>&gt;();

    <span class="pl-k">public</span> T TryResolve&lt;T&gt;()
    {
        <span class="pl-k">return</span> (T)Cache.GetOrAdd(<span class="pl-k">typeof</span>(T), 
            type =&gt; type.CreateInstance&lt;T&gt;());
    }
}

client.Resolver = <span class="pl-k">new</span> SingletonInstanceResolver();</pre></div>

<p>We can also have it resolve instances from your preferred IOC. Here's an example showing how to register all Receiver Types, auto-wire them with any custom dependencies, and instruct the client to resolve instances from our IOC:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">// Register all Receivers:</span>
client.RegisterNamedReceiver&lt;TestNamedReceiver&gt;(<span class="pl-s"><span class="pl-pds">"</span>test<span class="pl-pds">"</span></span>);
...

<span class="pl-c">// Register all dependencies used in a new Funq.Container:</span>
<span class="pl-k">var</span> container = <span class="pl-k">new</span> Container();
container.RegisterAs&lt;Dependency, IDependency&gt;();

<span class="pl-c">// Go through an auto-wire all Registered Receiver Types with Funq:</span>
container.RegisterAutoWiredTypes(client.ReceiverTypes);

<span class="pl-c">// Change the client to resolve receivers from the new Funq Container:</span>
client.Resolver = container;</pre></div>

<p>We can assign <code>Funq.Container</code> directly as it already implements the <a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack.Interfaces/Configuration/IResolver.cs">IResolver</a> interface, whilst you can re-use the existing IOC <strong>Container Adapters</strong> to <a href="https://github.com/ServiceStack/ServiceStack/wiki/The-IoC-container#use-another-ioc-container">enable support for other IOCs</a>. </p>

<h3>
<a id="user-content-the-global-receiver" class="anchor" href="#the-global-receiver" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The Global Receiver</h3>

<p>Whilst Named Receivers are used to handle messages sent to a specific namespaced selector, the client also supports registering a <strong>Global Receiver</strong> for handling messages sent with the special <code>cmd.*</code> selector.</p>

<h4>
<a id="user-content-handling-messages-with-the-default-selector" class="anchor" href="#handling-messages-with-the-default-selector" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Handling Messages with the Default Selector</h4>

<p>All <code>IServerEvents</code> Notify API's inlcudes <a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack/ServerEventsFeature.cs#L743-L771">overloads for sending messages without a selector</a> that by convention will take the format <code>cmd.{TypeName}</code>. </p>

<p>These events can be handled with a Global Receiver <strong>based on Message type</strong>, e.g:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">GlobalReceiver</span> : <span class="pl-k">ServerEventReceiver</span>
{
    <span class="pl-k">public</span> SetterType <span class="pl-en">AnyNamedProperty</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">AnyNamedMethod</span>(<span class="pl-k">CustomType</span> <span class="pl-smi">request</span>)
    {
        ...
    }
}

client.RegisterReceiver&lt;GlobalReceiver&gt;();</pre></div>

<p>Which will be called when messages are sent without a selector, e.g:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">MyServices</span> : <span class="pl-k">Service</span>
{
    <span class="pl-k">public</span> IServerEvents <span class="pl-en">ServerEvents</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Any</span>(<span class="pl-k">Request</span> <span class="pl-smi">request</span>)
    {
        ServerEvents.NotifyChannel(<span class="pl-s"><span class="pl-pds">"</span>home<span class="pl-pds">"</span></span>, <span class="pl-k">new</span> CustomType { ... });
        ServerEvents.NotifyChannel(<span class="pl-s"><span class="pl-pds">"</span>home<span class="pl-pds">"</span></span>, <span class="pl-k">new</span> SetterType { ... });
    }
}</pre></div>

<p>As Global Receivers handle other messages sent with the <code>cmd.*</code> selector and can be re-used as a named receiver, we can define a single class to handle all the different custom messages sent in <a href="http://chat.servicestack.net">chat.servicestack.net</a> App, E.g:</p>

<pre><code>cmd.chat Hi
cmd.announce This is your captain speaking...
cmd.toggle#channels
css.background-image url(https://servicestack.net/img/bg.jpg)
...
</code></pre>

<p>The above messages can all be handled with the Receiver below:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">JavaScriptReceiver</span> : <span class="pl-k">ServerEventReceiver</span>
{
    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Chat</span>(<span class="pl-k">ChatMessage</span> <span class="pl-smi">message</span>) { ... }
    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Announce</span>(<span class="pl-k">string</span> <span class="pl-smi">message</span>) { ... }
    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Toggle</span>(<span class="pl-k">string</span> <span class="pl-smi">message</span>) { ... }
    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">BackgroundImage</span>(<span class="pl-k">string</span> <span class="pl-smi">cssRule</span>) { ... }
}

client.RegisterReceiver&lt;JavaScriptReceiver&gt;();
client.RegisterNamedReceiver&lt;JavaScriptReceiver&gt;(<span class="pl-s"><span class="pl-pds">"</span>css<span class="pl-pds">"</span></span>);</pre></div>

<p>As seen above the <strong>target</strong> names are <strong>case-insensitive</strong> and <code>-</code> are collapsed to cater for JavaScript/CSS naming conventions.</p>

<h2>
<a id="user-content-add-authentication-support-to-net-serverevents-client" class="anchor" href="#add-authentication-support-to-net-serverevents-client" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Add Authentication support to .NET ServerEvents Client</h2>

<p>The explicit <code>Authenticate</code> and <code>AuthenticateAsync</code> API's can be used to authenticate the ServerEvents ServiceClient which <strong>shares cookies</strong> with the WebRequest that connects to the <code>/event-stream</code> so authenticating with the Server Events ServiceClient will also authenticate the <code>/event-stream</code> HTTP Connection:</p>

<div class="highlight highlight-source-cs"><pre>client.Authenticate(<span class="pl-k">new</span> Authenticate {
    provider = CredentialsAuthProvider.Name,
    UserName = <span class="pl-s"><span class="pl-pds">"</span>user<span class="pl-pds">"</span></span>,
    Password = <span class="pl-s"><span class="pl-pds">"</span>pass<span class="pl-pds">"</span></span>,
    RememberMe = <span class="pl-c1">true</span>,
});

client.Start();</pre></div>

<p>This is equivalent to:</p>

<div class="highlight highlight-source-cs"><pre>client.ServiceClient.Post(<span class="pl-k">new</span> Authenticate {
    provider = CredentialsAuthProvider.Name,
    UserName = <span class="pl-s"><span class="pl-pds">"</span>user<span class="pl-pds">"</span></span>,
    Password = <span class="pl-s"><span class="pl-pds">"</span>pass<span class="pl-pds">"</span></span>,
    RememberMe = <span class="pl-c1">true</span>,
});</pre></div>

<h2>
<a id="user-content-net-updatesubscriber-apis" class="anchor" href="#net-updatesubscriber-apis" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>.NET UpdateSubscriber APIs</h2>

<p>The sync/async APIs below built into the C# <code>ServerEventsClient</code> will let you modify an active Server Events
subscription to join new or leave existing channels:</p>

<div class="highlight highlight-source-cs"><pre>client.UpdateSubscriber(<span class="pl-k">new</span> UpdateEventSubscriber { 
    SubscribeChannels = <span class="pl-k">new</span>[]{ <span class="pl-s"><span class="pl-pds">"</span>chan1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>chan2<span class="pl-pds">"</span></span> },
    UnsubscribeChannels = <span class="pl-k">new</span>[]{ <span class="pl-s"><span class="pl-pds">"</span>chan3<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>chan4<span class="pl-pds">"</span></span> },
});

client.SubscribeToChannels(<span class="pl-s"><span class="pl-pds">"</span>chan1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>chan2<span class="pl-pds">"</span></span>);
client.UnsubscribeFromChannels(<span class="pl-s"><span class="pl-pds">"</span>chan3<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>chan4<span class="pl-pds">"</span></span>);

<span class="pl-k">await</span> client.SubscribeToChannelsAsync(<span class="pl-s"><span class="pl-pds">"</span>chan1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>chan2<span class="pl-pds">"</span></span>);
<span class="pl-k">await</span> client.UnsubscribeFromChannelsAsync(<span class="pl-s"><span class="pl-pds">"</span>chan3<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>chan4<span class="pl-pds">"</span></span>);</pre></div>

<h3>
<a id="user-content-onupdate-notification" class="anchor" href="#onupdate-notification" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>onUpdate Notification</h3>

<p>As this modifies the active subscription it also publishes a new <strong>onUpdate</strong> notification to all channel 
subscribers so they're able to maintain up-to-date info on each subscriber. 
This can be handled together with <strong>onJoin</strong> and <strong>onLeave</strong> events using <code>OnCommand</code>:</p>

<div class="highlight highlight-source-cs"><pre>client.OnCommand = msg =&gt; ...; <span class="pl-c">//= ServerEventJoin, ServerEventLeave or ServerEventUpdate</span></pre></div>

<h1>
<a id="user-content-serverevent-net-examples" class="anchor" href="#serverevent-net-examples" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>ServerEvent .NET Examples</h1>

<h2>
<a id="user-content-xamarinandroid-chat" class="anchor" href="#xamarinandroid-chat" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a href="https://github.com/ServiceStackApps/AndroidXamarinChat">Xamarin.Android Chat</a>
</h2>

<p>Xamarin.Android Chat utilizes the 
<a href="https://github.com/ServiceStack/ServiceStack/wiki/C%23-Server-Events-Client">.NET PCL Server Events Client</a>
to create an Android Chat App connecting to the existing 
<a href="http://chat.servicestack.net/">chat.servicestack.net</a> Server Events back-end where it's able to communicate 
with existing Ajax clients and other connected Android Chat Apps. </p>

<p><a href="https://www.youtube.com/watch?v=tImAm2LURu0"><img src="https://raw.githubusercontent.com/ServiceStack/Assets/master/img/livedemos/xamarin-android-server-events.png" alt="" style="max-width:100%;"></a></p>

<blockquote>
<p><a href="https://www.youtube.com/watch?v=tImAm2LURu0">YouTube Video</a> and <a href="https://github.com/ServiceStackApps/AndroidXamarinChat">AndroidXamarinChat Repo</a></p>
</blockquote>
