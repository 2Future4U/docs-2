<p>ServiceStack provides multiple ways to select the Razor View that will be used to render your services response with. First if the <code>IHttpRequest.Items["View"]</code> has been set <a href="https://github.com/ServiceStack/ServiceStack/wiki/Order-of-Operations">via any Global, Request, Response or Action Filter</a> it will use that, otherwise the fallback convention is to use the view with the same name as the <strong>Request DTO</strong> followed finally by one with the <strong>Response DTO</strong> name.</p>

<p>To illustrate this, the below service is overloaded with different ways to select a Razor View, each are assigned a priority number starting from <code>#1</code>:</p>

<div class="highlight highlight-source-cs"><pre>[ClientCanSwapTemplates]        <span class="pl-c">// #4 Client can select with ?view=UserSpecified4</span>
[DefaultView(<span class="pl-s"><span class="pl-pds">"</span>DevSpecified3<span class="pl-pds">"</span></span>)]  <span class="pl-c">// #3 </span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">RockstarsService</span> : <span class="pl-k">Service</span> 
{
    [DefaultView(<span class="pl-s"><span class="pl-pds">"</span>DevSpecified2<span class="pl-pds">"</span></span>)]        <span class="pl-c">// #2 </span>
    <span class="pl-k">public</span> <span class="pl-k">object</span> <span class="pl-en">Get</span>(<span class="pl-k">Rockstars5</span> <span class="pl-smi">request</span>) // #5
    {
        <span class="pl-k">return</span> <span class="pl-k">new</span> HttpResult(<span class="pl-k">new</span> RockstarsResponse6()) <span class="pl-c">// #6</span>
        {
            View = <span class="pl-s"><span class="pl-pds">"</span>DevSpecified1<span class="pl-pds">"</span></span>  <span class="pl-c">// #1</span>
        }
    }
}</pre></div>

<p>The above service selects views that are mapped to the below Razor views. The folder structure is inconsequential so Views can be organized and nested in any number of folders, e.g:</p>

<pre><code>/Views
    /Any            
        /Nested
            /Deep
                DevSpecified1.cshtml       // #1
                DevSpecified2.cshtml       // #2
                DevSpecified3.cshtml       // #3
                UserSpecified4.cshtml      // #4
                Rockstars5.cshtml          // #5
                RockstarsResponse6.cshtml  // #6
    /Shared
        _Layout.cshtml
</code></pre>

<p>The <code>DevSpecified1.cshtml</code> would be selected first because it is last to set the <code>IHttpRequest.Items["View"]</code> property that the Razor Format uses to select the view. You're also not limited to these options as you can easily set the same property in any of your own custom filters. </p>

<p>E.g. this is the entire source code of the <a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack.ServiceInterface/ClientCanSwapTemplatesAttribute.cs">ClientCanSwapTemplates Attribute</a> which once enabled lets the client to specify the view via HTTP Header, QueryString, FormData or Cookies (in that order):</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">ClientCanSwapTemplatesAttribute</span> : <span class="pl-k">ResponseFilterAttribute</span>
{
    <span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-k">void</span> <span class="pl-en">Execute</span>(<span class="pl-k">IHttpRequest</span> <span class="pl-smi">req</span>, <span class="pl-k">IHttpResponse</span> <span class="pl-smi">res</span>, <span class="pl-k">object</span> <span class="pl-smi">requestDto</span>)
    {
        req.Items[<span class="pl-s"><span class="pl-pds">"</span>View<span class="pl-pds">"</span></span>] = req.GetParam(<span class="pl-s"><span class="pl-pds">"</span>View<span class="pl-pds">"</span></span>);
        req.Items[<span class="pl-s"><span class="pl-pds">"</span>Template<span class="pl-pds">"</span></span>] = req.GetParam(<span class="pl-s"><span class="pl-pds">"</span>Template<span class="pl-pds">"</span></span>);
    }
}</pre></div>

<p>The last filter to set <code>req.Items["View"]</code> wins.</p>

<h3>
<a id="user-content-layout-templates" class="anchor" href="#layout-templates" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Layout Templates</h3>

<p>Although the above example only shows how to select the View (e.g. Page Body), the exact same rules applies to select the Layout template via the <strong>Template</strong> field also on the HttpResult and DefaultView attribute. If a template is not specified the default <code>/Shared/_Layout.cshtml</code> is used.</p>

<h2>
<a id="user-content-debuggable-razor-views" class="anchor" href="#debuggable-razor-views" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Debuggable Razor Views</h2>

<p>Razor Views are now debuggable for 
<a href="https://github.com/ServiceStack/ServiceStack/wiki/Debugging#debugmode">Debug builds</a> by default, it can also be explicitly specified on:</p>

<div class="highlight highlight-source-cs"><pre>Plugins.Add(<span class="pl-k">new</span> RazorFormat {
    IncludeDebugInformation = <span class="pl-c1">true</span>,
    CompileFilter = compileParams =&gt; ...
})</pre></div>

<p>The <code>CompileFilter</code> is an advanced option that lets modify the <code>CompilerParameters</code> used by the C# CodeDom provider to compile the Razor Views if needed. </p>
