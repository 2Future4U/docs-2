<h2>
<a id="user-content-mq-examples" class="anchor" href="#mq-examples" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>MQ Examples</h2>

<p>The <a href="https://github.com/ServiceStack/ServiceStack.UseCases/tree/master/Reusability">Reusability ServiceStack.UseCase</a> contains a good introductory demo of using MQ's(message-queues) in ServiceStack where the same services can be called via Web Service or via MQ. Using MQ's provide instant response times, in addition to reliable and durable execution of your services. </p>

<h3>
<a id="user-content-the-smessage-service" class="anchor" href="#the-smessage-service" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The SMessage Service</h3>

<p>The <a href="https://github.com/ServiceStack/ServiceStack.UseCases/blob/master/Reusability/SMessageService.cs#L63">SMessage Service</a> shows an example of dividing a service into multiple subtasks and dispatching them for instant response times and parallel processing of blocking operations without needing any multi-threading code in your application logic, e.g:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">object</span> Any(SMessage request)
{
    <span class="pl-k">var</span> sw = Stopwatch.StartNew();
    <span class="pl-k">if</span> (!request.Defer) <span class="pl-c">//Process sequentially or Defer execution</span>
    {
        <span class="pl-c">//Executes service sequentially: N+1 service calls, will timeout if N is too big</span>
        <span class="pl-k">var</span> results = <span class="pl-k">new</span> List&lt;SMessageReceipt&gt;();
        results.AddRange(Email.Send(request));
        results.AddRange(FacebookR.Send(request));
        results.AddRange(Twitter.Send(request));
        Db.InsertAll(results);
    }
    <span class="pl-k">else</span>
    {
        <span class="pl-c">//Split service into smaller tasks and defers messages in MQ broker for processing in parallel</span>
        Email.CreateMessages(request).ForEach(MessageProducer.Publish);
        Facebook.CreateMessages(request).ForEach(MessageProducer.Publish);
        Twitter.CreateMessages(request).ForEach(MessageProducer.Publish);
    }

    <span class="pl-k">return</span> <span class="pl-k">new</span> SMessageResponse {
        TimeTakenMs = sw.ElapsedMilliseconds,
    };
}</pre></div>

<h3>
<a id="user-content-process-each-service-concurrently-without-holding-up-the-processing-of-other-tasks" class="anchor" href="#process-each-service-concurrently-without-holding-up-the-processing-of-other-tasks" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Process each service concurrently without holding up the processing of other tasks</h3>

<p>Another benefit of dispatching messages into multiple sub tasks is if the Email API is slow, it doesn't hold up the processing of the other tasks which are all running concurrently in the background each individually processing messages as fast as they can.</p>

<h3>
<a id="user-content-easily-parallelize-and-multiply-your-services-throughput" class="anchor" href="#easily-parallelize-and-multiply-your-services-throughput" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Easily Parallelize and Multiply your services throughput</h3>

<p>The RedisMqServer also supports spawning any number of background threads for individual requests, so if Posting to twitter was an IO intensive operation you can double the throughput by simply assigning 2 or more worker threads, e.g:</p>

<div class="highlight highlight-source-cs"><pre>mqService.RegisterHandler&lt;PostStatusTwitter&gt;(ServiceController.ExecuteMessage, noOfThreads:<span class="pl-c1">2</span>);
mqService.RegisterHandler&lt;CallFacebook&gt;(ServiceController.ExecuteMessage);
mqService.RegisterHandler&lt;EmailMessage&gt;(ServiceController.ExecuteMessage);</pre></div>

<h2>
<a id="user-content-redis-mq-client--server" class="anchor" href="#redis-mq-client--server" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Redis MQ Client / Server</h2>

<p>A redis-based message queue client/server that can be hosted in any .NET or ASP.NET application. All Redis MQ Hosts lives in the <a href="https://github.com/ServiceStack/ServiceStack/tree/master/src/ServiceStack.Server/Messaging/Redis">ServiceStack.Server</a> project and brings the many benefits of using a Message Queue. </p>

<pre><code>PM&gt; Install-Package ServiceStack.Server
</code></pre>

<h3>
<a id="user-content-redismqserver" class="anchor" href="#redismqserver" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a href="https://github.com/ServiceStack/ServiceStack/tree/master/src/ServiceStack.Server/Messaging/Redis/RedisMqServer.cs">RedisMqServer</a>
</h3>

<p>Works by using a background thread for <strong>each service</strong>. This allows you to process messages from different services concurrently. Recommended if you have any long-running services so other services can still run in parallel.</p>

<p>Major kudos goes to Redis which thanks to its versatility, has Pub/Sub and Lists primitives that makes implementing a Queue trivial.</p>

<h2>
<a id="user-content-mq-architecture-in-servicestack" class="anchor" href="#mq-architecture-in-servicestack" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>MQ Architecture in ServiceStack</h2>

<p>The logical architecture of how a MQ Publisher and MQ Host works together in ServiceStack:</p>

<p><a href="https://camo.githubusercontent.com/696024c9c9acb3c96ccfdb45953af88185d4c5b7/687474703a2f2f6d6f6e6f2e73657276696365737461636b2e6e65742f66696c65732f73657276696365737461636b2d6d71636c69656e74732e706e67" target="_blank"><img src="https://camo.githubusercontent.com/696024c9c9acb3c96ccfdb45953af88185d4c5b7/687474703a2f2f6d6f6e6f2e73657276696365737461636b2e6e65742f66696c65732f73657276696365737461636b2d6d71636c69656e74732e706e67" alt="ServiceStack MQ Client Architecture" data-canonical-src="http://mono.servicestack.net/files/servicestack-mqclients.png" style="max-width:100%;"></a> </p>

<h3>
<a id="user-content-easily-testable-and-swappable" class="anchor" href="#easily-testable-and-swappable" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Easily testable and swappable</h3>

<p>All MQ implementations share the same <a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack.Interfaces/Messaging/IMessageService.cs">IMessageService</a> so they're easily swappable and testable. There is also an <a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack/Messaging/InMemoryTransientMessageService.cs">InMemoryTransientMessageService</a> available, useful for development &amp; testing.</p>

<p>These versions already sports the major features you've come to expect from a MQ:</p>

<ul>
<li>Each service maintains its own Standard and Priority MQ's</li>
<li>Automatic Retries on messages generating errors with Failed messages sent to a DLQ (Dead Letter Queue) when its Retry threshold is reached.</li>
<li>Each message can have a ReplyTo pointing to any Queue, alternatively you can even provide a <strong>ServiceStack endpoint URL</strong> which will send the response to a Web Service instead. If the web service is not available it falls back into publishing it in the default Response Queue so you never lose a message!
MQ/Web Services that don't return any output have their Request DTOs sent to a rolling Out queue which can be monitored by external services (i.e. the publisher/callee) to determine when the request has been processed.</li>
</ul>

<h2>
<a id="user-content-re-use-your-existing-web-services" class="anchor" href="#re-use-your-existing-web-services" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Re-use your existing Web Services!</h2>

<p>Although you can host RedisMqServer in any ASP.NET web app, the benefit of hosting inside ServiceStack is that your web services are <strong>already capable</strong> of processing Redis MQ messages <strong>without any changes required</strong> since they're already effectively designed to work like a Message service to begin with, i.e. C# POCO-in -&gt; C# POCO-out.</p>

<p>This is another example of how ServiceStack's prescribed DTO-first architecture continues to pay dividends since each web service is a DI clean-room allowing your C# logic to be kept pure as it only has to deal with untainted POCO DTOs, allowing your same web service to be re-used in: SOAP, REST (JSON,XML,JSV,CSV,HTML) web services, view models for dynamic HTML pages and now as a MQ service!</p>

<h2>
<a id="user-content-future-roadmap" class="anchor" href="#future-roadmap" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Future Roadmap</h2>

<p>Eventually (based on feedback) there will be posts/documentation/examples forthcoming covering how to use it, in the meantime you can Check out the Messaging API to see how simple it is to use. To see some working code showing some of the capabilities listed above, view the tests.</p>

<h2>
<a id="user-content-example" class="anchor" href="#example" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Example</h2>

<p>Hooking up a basic send/reply example is as easy as:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">//DTO messages:</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Hello</span> { <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Name</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; } }
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">HelloResponse</span> { <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Result</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; } }

<span class="pl-k">var</span> redisFactory = <span class="pl-k">new</span> PooledRedisClientManager(<span class="pl-s"><span class="pl-pds">"</span>localhost:6379<span class="pl-pds">"</span></span>);
<span class="pl-k">var</span> mqHost = <span class="pl-k">new</span> RedisMqServer(redisFactory, retryCount:<span class="pl-c1">2</span>);

<span class="pl-c">//Server - MQ Service Impl:</span>
mqHost.RegisterHandler&lt;Hello&gt;(m =&gt;
    <span class="pl-k">new</span> HelloResponse { Result = <span class="pl-s"><span class="pl-pds">"</span>Hello, <span class="pl-pds">"</span></span> + m.GetBody().Name });
mqHost.Start();

...

<span class="pl-c">//Client - Process Response:</span>
mqHost.RegisterHandler&lt;HelloResponse&gt;(m =&gt; {
    Console.WriteLine(<span class="pl-s"><span class="pl-pds">"</span>Received: <span class="pl-pds">"</span></span> + m.GetBody().Result);
});
mqHost.Start();

...

<span class="pl-c">//Producer - Start publishing messages:</span>
<span class="pl-k">var</span> mqClient = mqHost.CreateMessageQueueClient();
mqClient.Publish(<span class="pl-k">new</span> Hello { Name = <span class="pl-s"><span class="pl-pds">"</span>ServiceStack<span class="pl-pds">"</span></span> });
</pre></div>

<h1>
<a id="user-content-redis" class="anchor" href="#redis" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Redis</h1>

<blockquote>
<p><strong>Note:</strong> This is a quote of a <a href="https://groups.google.com/d/msg/servicestack/Jl1xjlLH-4E/kz8mL_bq9zMJ">google group topic</a> to provide more information about ServiceStack and Redis until more documentation/examples are added.</p>
</blockquote>

<p>Redis is a  NoSQL datastore that runs as a network server. To start it you need to run an instance of redis-server either locally or remotely accessible.</p>

<p>Probably will help to understand the background concepts behind Redis so you can get a better idea of how it works. 
A good start is this brief overview of Redis which also includes as how you can install it: 
<a href="http://stackoverflow.com/a/2760282/85785">http://stackoverflow.com/a/2760282/85785</a></p>

<p>The RedisMQ Host is in ServiceStack.Redis project which is a dependency on the ServiceStack NuGet package (if that's how you have ServiceStack installed).</p>

<p>At the moment the there is not much documentation available and will look to improve this after I get the next release of ServiceStack out.</p>

<p>You can look through the tests to get a better idea of how it works, especially the <a href="https://github.com/ServiceStack/ServiceStack/blob/master/tests/ServiceStack.Server.Tests/Messaging/RedisMqServerTests.cs#L291">Request/Reply Example</a></p>

<p>Basically the RedisMQ runs as a separate background thread you start from inside your AppHostHttpListenerBase.</p>

<p>For duplex communication each client and server will require its own AppHostHttpListenerBase + RedisMQ Host, although unless your server is going to call HTTP services on the client you don't need it and you can use <a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack/Testing/BasicAppHost.cs">BasicAppHost</a></p>

<p>Here is a simple example of a client/server with HTTP + RedisMQ enabled on the server, and just RedisMQ on the client: </p>

<p><code>Shared.cs</code>:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">using</span> System<span class="pl-k">;</span>

<span class="pl-k">namespace</span> <span class="pl-en">TestMqShared</span>
{
    <span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Hello</span> { 
        <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Name</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; } 
    }
    <span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">HelloResponse</span> { 
        <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Result</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; } 
    }
}</pre></div>

<p><code>Server.cs</code>:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">using</span> System<span class="pl-k">;</span>
<span class="pl-k">using</span> Funq<span class="pl-k">;</span>
<span class="pl-k">using</span> ServiceStack<span class="pl-k">;</span>
<span class="pl-k">using</span> ServiceStack.Messaging.Redis<span class="pl-k">;</span>
<span class="pl-k">using</span> ServiceStack.Redis<span class="pl-k">;</span>
<span class="pl-k">using</span> ServiceStack.Testing<span class="pl-k">;</span>
<span class="pl-k">using</span> TestMqShared<span class="pl-k">;</span>

<span class="pl-k">namespace</span> <span class="pl-en">TestMq</span>
{
    <span class="pl-c">//Server</span>
    <span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">HelloService</span> : <span class="pl-k">Service</span> 
    {
        <span class="pl-k">public</span> <span class="pl-k">object</span> <span class="pl-en">Any</span>(<span class="pl-k">Hello</span> <span class="pl-smi">req</span>) 
        { 
            <span class="pl-k">return</span> <span class="pl-k">new</span> HelloResponse { Result = <span class="pl-s"><span class="pl-pds">"</span>Hello, <span class="pl-pds">"</span></span> + req.Name }; 
        }
    }

    <span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">ServerAppHost</span> : <span class="pl-k">AppHostHttpListenerBase</span> 
    {
        <span class="pl-k">public</span> <span class="pl-en">ServerAppHost</span>() : <span class="pl-c1">base</span>("Test Server", typeof(HelloService).Assembly) {}

        <span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-k">void</span> <span class="pl-en">Configure</span>(<span class="pl-k">Container</span> <span class="pl-smi">container</span>) 
        {
            <span class="pl-c1">base</span>.Routes
                .Add&lt;Hello&gt;(<span class="pl-s"><span class="pl-pds">"</span>/hello<span class="pl-pds">"</span></span>)
                .Add&lt;Hello&gt;(<span class="pl-s"><span class="pl-pds">"</span>/hello/{Name}<span class="pl-pds">"</span></span>);

            <span class="pl-k">var</span> redisFactory = <span class="pl-k">new</span> PooledRedisClientManager(<span class="pl-s"><span class="pl-pds">"</span>localhost:6379<span class="pl-pds">"</span></span>);
            container.Register&lt;IRedisClientsManager&gt;(redisFactory); <span class="pl-c">// req. to log exceptions in redis</span>
            <span class="pl-k">var</span> mqHost = <span class="pl-k">new</span> RedisMqServer(redisFactory, retryCount:<span class="pl-c1">2</span>);

            <span class="pl-c">//Server - MQ Service Impl:</span>

            <span class="pl-c">//Listens for 'Hello' messages sent with 'mqClient.Publish(new Hello { Name = "Client" });'</span>
            mqHost.RegisterHandler&lt;Hello&gt;(<span class="pl-c1">this</span>.ServiceController.ExecuteMessage);
            mqHost.Start(); <span class="pl-c">//Starts listening for messages</span>
        }
    }

    <span class="pl-k">class</span> <span class="pl-en">MainClass</span>
    {
        <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">void</span> <span class="pl-en">Main</span>(<span class="pl-k">string[]</span> <span class="pl-smi">args</span>)
        {
            <span class="pl-k">var</span> serverAppHost = <span class="pl-k">new</span> ServerAppHost();
            serverAppHost.Init(); 
            serverAppHost.Start(<span class="pl-s"><span class="pl-pds">"</span>http://localhost:1400/<span class="pl-pds">"</span></span>);
            Console.WriteLine(<span class="pl-s"><span class="pl-pds">"</span>Server running.  Press enter to terminate...<span class="pl-pds">"</span></span>);
            Console.ReadLine(); <span class="pl-c">//Block the server from exiting (i.e. if running inside Console App)</span>
        }
    }
}</pre></div>

<p><code>Client.cs</code>:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">using</span> System<span class="pl-k">;</span>
<span class="pl-k">using</span> Funq<span class="pl-k">;</span>
<span class="pl-k">using</span> ServiceStack<span class="pl-k">;</span>
<span class="pl-k">using</span> ServiceStack.Messaging<span class="pl-k">;</span>
<span class="pl-k">using</span> ServiceStack.Messaging.Redis<span class="pl-k">;</span>
<span class="pl-k">using</span> ServiceStack.Redis<span class="pl-k">;</span>
<span class="pl-k">using</span> ServiceStack.Testing<span class="pl-k">;</span>
<span class="pl-k">using</span> TestMqShared<span class="pl-k">;</span>

<span class="pl-k">namespace</span> <span class="pl-en">TestMqCli</span>
{
    <span class="pl-k">class</span> <span class="pl-en">MainClass</span>
    {
        <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">void</span> <span class="pl-en">Main</span>(<span class="pl-k">string[]</span> <span class="pl-smi">args</span>)
        {
            <span class="pl-k">var</span> redisFactory = <span class="pl-k">new</span> PooledRedisClientManager(<span class="pl-s"><span class="pl-pds">"</span>localhost:6379<span class="pl-pds">"</span></span>);
            <span class="pl-k">var</span> mqServer = <span class="pl-k">new</span> RedisMqServer(redisFactory, retryCount:<span class="pl-c1">2</span>);

            <span class="pl-c">//Client - MQ Service Impl:</span>
            <span class="pl-c">//Listens for 'HelloResponse' as returned by the 'Hello' service on the server</span>
            mqServer.RegisterHandler&lt;HelloResponse&gt;(m =&gt; {  
                Console.WriteLine(<span class="pl-s"><span class="pl-pds">"</span>Received: <span class="pl-pds">"</span></span> + m.GetBody().Result);  <span class="pl-c">//Fired </span>
                <span class="pl-c">// See comments below</span>
                <span class="pl-c">// m.Options = (int)MessageOption.None;</span>
                <span class="pl-k">return</span> <span class="pl-c1">null</span>;
            });

            <span class="pl-c">//or to call an existing service with:</span>
            <span class="pl-c">//mqServer.RegisterHandler&lt;HelloResponse&gt;(m =&gt;   </span>
            <span class="pl-c">//    this.ServiceController.ExecuteMessage(m));</span>

            mqServer.Start(); <span class="pl-c">//Starts listening for messages</span>

            <span class="pl-k">var</span> mqClient = mqServer.CreateMessageQueueClient();
            mqClient.Publish(<span class="pl-k">new</span> Hello { Name = <span class="pl-s"><span class="pl-pds">"</span>Client 1<span class="pl-pds">"</span></span> });

            Console.WriteLine(<span class="pl-s"><span class="pl-pds">"</span>Client running.  Press any key to terminate...<span class="pl-pds">"</span></span>);
            Console.ReadLine(); <span class="pl-c">//Block the server from exiting (i.e. if running inside Console App)</span>
        }
    }
}</pre></div>

<p>The first RedisMQ host listening to the <code>Hello</code> message (i.e. the server) will process the message. </p>

<p>When the server returns a 'HelloResponse' message it gets put on the 'HelloResponse' Inbox Queue and the first RedisMQ Host listening to the 'HelloResponse' message (i.e. Client) will have their callback fired.</p>

<p>Note that the <code>HelloResponse</code> will get put back on a 'transient' message queue, <code>mq.HelloResponse.outq</code> with a maximum message limit of 100 (by default).  You can subscribe to this queue to get a notification and do further processing, such as recording the number of messages handled.  Or you can clear the message <code>NotifyOneWay</code> option to prevent this.</p>

<h3>
<a id="user-content-request--reply-mq-pattern" class="anchor" href="#request--reply-mq-pattern" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Request + Reply MQ Pattern</h3>

<p>However MQ's are normally used for async OneWay messages as any client host listening to 'HelloResponse' could receive the response message, and only 1 will, which is not guaranteed to be the client that sent the original message. For this reason you want to make use of the ReplyTo field of the Message for Request/Reply responses.</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> uniqueCallbackQ = <span class="pl-s"><span class="pl-pds">"</span>mq:c1<span class="pl-pds">"</span></span> + <span class="pl-s"><span class="pl-pds">"</span>:<span class="pl-pds">"</span></span> Guid.NewGuid().ToString(<span class="pl-s"><span class="pl-pds">"</span>N<span class="pl-pds">"</span></span>);
<span class="pl-k">var</span> clientMsg = <span class="pl-k">new</span> Message&lt;Hello&gt;(<span class="pl-k">new</span> Hello { Name = <span class="pl-s"><span class="pl-pds">"</span>Client 1<span class="pl-pds">"</span></span> }) {
   ReplyTo =  uniqueCallbackQ
};
mqClient.Publish( clientMsg );
<span class="pl-k">var</span> response = mqClient.Get(clientMsg).ToMessage&lt;HelloResponse&gt;();  <span class="pl-c">//Blocks thread on client until reply message is received</span></pre></div>

<p>Note: The ReplyTo callback url could also be a ServiceStack endpoint that expects a 'HelloResponse' e.g.</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> clientMsg = <span class="pl-k">new</span> Message&lt;Hello&gt;(<span class="pl-k">new</span> Hello { Name = <span class="pl-s"><span class="pl-pds">"</span>Client 1<span class="pl-pds">"</span></span> }) {
   ReplyTo =  <span class="pl-s"><span class="pl-pds">"</span>http://clienthost:82/helloresponse<span class="pl-pds">"</span></span>
};</pre></div>

<p>In this case the server wont put the response message on the back on the MQ and will instead send the response directly to your client web service host.</p>

<p>There's a few MQ concepts covered above here, I invite you to do your own reading on MQ's in general as it works a little different to normal request/reply web services.</p>

<p>See Also: <a href="http://masonoise.files.wordpress.com/2010/03/redis-cheatsheet-v1.pdf">Redis Commands (PDF)</a></p>
