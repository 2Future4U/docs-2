<p>ServiceStack uses a slightly modified version of <a href="http://funq.codeplex.com/">Funq</a> - which was adopted because of its excellent <a href="http://www.servicestack.net/benchmarks/">performance and memory characteristics</a>. ServiceStack's version of Funq has been enhanced with Expression-based Auto-wiring and lifetime Request Scope.</p>

<p>If you so wish, you can still elect to use your favourite IOC by creating an <code>IContainerAdapter</code> for them. See below for examples of adapters for popular IOC's. All ServiceStack's customizable hooks support Auto-wiring out-of-the-box, namely:</p>

<ul>
<li><a href="https://github.com/ServiceStack/ServiceStack/wiki/Your-first-webservice-explained">Services</a></li>
<li>
<a href="https://github.com/ServiceStack/ServiceStack/wiki/Filter-attributes">Request and Response Filter attributes</a> <em>(are executed before a service gets called)</em>
</li>
<li>
<a href="https://github.com/ServiceStack/ServiceStack/wiki/Validation">Validators</a> <em>(validates a request DTO before the service gets called)</em>
</li>
</ul>

<p>For each of these features, dependencies are resolved for all parameters in the constructor that has the most arguments as well as all public properties.</p>

<h2>
<a id="user-content-autowire-registration" class="anchor" href="#autowire-registration" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Autowire Registration</h2>

<p>You can register dependencies so that all the dependencies are automatically auto-wired. Just like the hooks above, once resolved Funq will create a new instance resolving dependencies for the constructor that has the most arguments as well as all public properties.</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-k">void</span> Configure(Container container)
{
   container.RegisterAutoWired&lt;MyType&gt;();
   container.RegisterAutoWiredAs&lt;MyType,IMyType&gt;();
}</pre></div>

<p>There's also support for registration of run-time types with these APIs below:</p>

<div class="highlight highlight-source-cs"><pre>container.RegisterAutoWiredType(<span class="pl-k">typeof</span>(MyType));
container.RegisterAutoWiredType(<span class="pl-k">typeof</span>(MyType),<span class="pl-k">typeof</span>(IMyType));
container.RegisterAutoWiredTypes(<span class="pl-k">typeof</span>(MyType),<span class="pl-k">typeof</span>(MyType2),<span class="pl-k">typeof</span>(MyType3));</pre></div>

<h2>
<a id="user-content-custom-registration" class="anchor" href="#custom-registration" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Custom Registration</h2>

<p>Funq also supports custom creation of instances. When used no auto-wiring is performed and it's left up to you to explicitly resolve all your dependencies.</p>

<h3>
<a id="user-content-using-custom-factories" class="anchor" href="#using-custom-factories" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Using Custom Factories</h3>

<p>In addition to Auto-wiring Funq allows you to customize the creation of your instance with custom delegates. This is useful when your dependencies require custom configuration. E.g:</p>

<div class="highlight highlight-source-cs"><pre>container.Register(c =&gt; <span class="pl-k">new</span> MyType(c.Resolve&lt;IDependency&gt;(), connectionString));
container.Register&lt;IMyType&gt;(c =&gt; <span class="pl-k">new</span> MyType(c.Resolve&lt;IDependency&gt;(), connectionString));
container.Register(c =&gt; CreateAndInitializeMyType(c.Resolve&lt;IDependency1&gt;(), c.Resolve&lt;IDependency2&gt;));</pre></div>

<h3>
<a id="user-content-register-instances" class="anchor" href="#register-instances" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Register instances</h3>

<p>Other than factories, you can also register custom instances where instead of returning a lambda above you can return an instance:</p>

<div class="highlight highlight-source-cs"><pre>container.Register(<span class="pl-k">new</span> MyType(c.Resolve&lt;IDependency&gt;(), connectionString));</pre></div>

<blockquote>
<p><strong>Note:</strong> When using the methods above, the properties and the constructor of the registered type aren't auto-wired (ie <strong>the properties and the constructor are not injected</strong>). You would need to do that manually like that:</p>

<div class="highlight highlight-source-cs"><pre>container.Register&lt;T&gt;(c =&gt; <span class="pl-k">new</span> Foo(c.Resolve&lt;Some&gt;(), c.Resolve&lt;Other&gt;(), c.Resolve&lt;Dependencies&gt;());</pre></div>
</blockquote>

<h2>
<a id="user-content-object-lifetime" class="anchor" href="#object-lifetime" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Object lifetime</h2>

<p>By default all dependencies registered in Funq have singleton scope, where the same instance is injected into all dependencies. This behaviour can be changed by defining the scope explicitly, which is supported with the following APIs:</p>

<div class="highlight highlight-source-cs"><pre>container.Register(c =&gt; <span class="pl-k">new</span> MyType()).ReusedWithin(ReuseScope.None); 
container.RegisterAutoWired&lt;MyType&gt;().ReusedWithin(ReuseScope.None); 
container.RegisterAutoWiredAs&lt;MyType,IMyType&gt;().ReusedWithin(ReuseScope.None); 
container.RegisterAutoWiredType(<span class="pl-k">typeof</span>(MyType), ReuseScope.None); 
container.RegisterAutoWiredType(<span class="pl-k">typeof</span>(MyType), <span class="pl-k">typeof</span>(IMyType), ReuseScope.None); </pre></div>

<h3>
<a id="user-content-supported-lifetime-scopes" class="anchor" href="#supported-lifetime-scopes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Supported Lifetime Scopes</h3>

<ul>
<li>
<code>ReuseScope.Container</code>: Singleton scope (a instance is used per application lifetime)</li>
<li>
<code>ReuseScope.Request</code>: Request scope (a instance is used per request lifetime)</li>
<li>
<code>ReuseScope.None</code>: Transient scope (a new instance is created every time)</li>
</ul>

<h2>
<a id="user-content-advanced-usages" class="anchor" href="#advanced-usages" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Advanced Usages</h2>

<h3>
<a id="user-content-autowiring-generic-type-definitions" class="anchor" href="#autowiring-generic-type-definitions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Autowiring Generic Type Definitions</h3>

<p>Whilst ServiceStack's IOC doesn't have a native support for registering types based on a generic type definition, it's easy to use the Runtime Type APIs and register them yourself. E.g the example below will register and autowire all types that implement <code>ICommand&lt;T&gt;</code> in the current assembly:</p>

<div class="highlight highlight-source-cs"><pre>GetType().Assembly.GetTypes()
    .Where(x =&gt; x.IsOrHasGenericInterfaceTypeOf(<span class="pl-k">typeof</span>(ICommand&lt;&gt;)))
    .Each(x =&gt; container.RegisterAutoWiredType(x));</pre></div>

<h2>
<a id="user-content-use-another-ioc-container" class="anchor" href="#use-another-ioc-container" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Use another IoC container</h2>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">interface</span> <span class="pl-en">IResolver</span> {
    T TryResolve&lt;T&gt;();
}

<span class="pl-k">public</span> <span class="pl-k">interface</span> <span class="pl-en">IContainerAdapter</span> : <span class="pl-k">IResolver</span> {
    T Resolve&lt;T&gt;();
}</pre></div>

<h4>
<a id="user-content-example-usage" class="anchor" href="#example-usage" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Example Usage</h4>

<div class="highlight highlight-source-cs"><pre>IKernel kernel = <span class="pl-k">new</span> StandardKernel();
container.Adapter = <span class="pl-k">new</span> NinjectIocAdapter(kernel);</pre></div>

<p>Adding a custom ContainerAdapter allows your services to resolve its dependencies from an alternative IOC, in this way they act like a <strong>dependency repository</strong> where the services are still registered in Funq but all their dependencies are resolved by the ContainerAdapter specified. Dependencies in constructors are resolved by calling <code>IContainerAdapter.Resolve&lt;T&gt;()</code> whilst public property dependencies are resolved with <code>IContainerAdapter.TryResolve&lt;T&gt;()</code>, the idea is you can have missing constructor dependencies throw an exception whilst you can be more lax about property dependencies, where your service can continue to execute without them (should you wish).</p>

<p>Here are some example how to use some popular IoC containers side-by-side with Funq. Of course you're not only limited to the these IoC containers here:</p>

<h3>
<a id="user-content-use-ninject" class="anchor" href="#use-ninject" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Use Ninject</h3>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">NinjectIocAdapter</span> : <span class="pl-k">IContainerAdapter</span>
{
    <span class="pl-k">private</span> <span class="pl-k">readonly</span> IKernel kernel;

    <span class="pl-k">public</span> <span class="pl-en">NinjectIocAdapter</span>(<span class="pl-k">IKernel</span> <span class="pl-smi">kernel</span>)
    {
        <span class="pl-c1">this</span>.kernel = kernel;
    }

    <span class="pl-k">public</span> T Resolve&lt;T&gt;()
    {
        <span class="pl-k">return</span> <span class="pl-c1">this</span>.kernel.Get&lt;T&gt;();
    }

    <span class="pl-k">public</span> T TryResolve&lt;T&gt;()
    {
        <span class="pl-k">return</span> <span class="pl-c1">this</span>.kernel.CanResolve&lt;T&gt;() ? <span class="pl-c1">this</span>.kernel.Get&lt;T&gt;() : <span class="pl-k">default</span>(T);
    }
}</pre></div>

<p>Then in the <code>AppHost</code> <code>Configure(Container container)</code> method you need to enable this adapter:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">//Create Ninject IoC container</span>
IKernel kernel = <span class="pl-k">new</span> StandardKernel();
<span class="pl-c">//Now register all depedencies to your custom IoC container</span>
<span class="pl-c">//...</span>

<span class="pl-c">//Register Ninject IoC container, so ServiceStack can use it</span>
container.Adapter = <span class="pl-k">new</span> NinjectIocAdapter(kernel);</pre></div>

<h3>
<a id="user-content-use-structuremap" class="anchor" href="#use-structuremap" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Use StructureMap</h3>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">StructureMapContainerAdapter</span> : <span class="pl-k">IContainerAdapter</span>
{
    <span class="pl-k">public</span> T TryResolve&lt;T&gt;()
    {
        <span class="pl-k">return</span> ObjectFactory.TryGetInstance&lt;T&gt;();
    }

    <span class="pl-k">public</span> T Resolve&lt;T&gt;()
    {
        <span class="pl-k">return</span> ObjectFactory.TryGetInstance&lt;T&gt;();
    }
}</pre></div>

<p>In <code>AppHost</code> <code>Configure</code>:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">//Configure User Defined REST Paths</span>
container.Adapter = <span class="pl-k">new</span> StructureMapContainerAdapter();

<span class="pl-c">//Register your dependencies</span>
ObjectFactory.Inject(<span class="pl-k">typeof</span>(IFoo), <span class="pl-k">new</span> Foo());</pre></div>

<blockquote>
<p><strong>Note:</strong> Due to a behavior of StructureMap, you need your <code>AppHost</code> declare as <code>internal</code>, eg: 
<code>internal class AppHost : AppHostBase</code></p>
</blockquote>

<h3>
<a id="user-content-use-windsor" class="anchor" href="#use-windsor" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Use Windsor</h3>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">// The "ApplicationAssemblyFilter" is a custom class that just helps to </span>
<span class="pl-c">// automate registration to assemblies which match a particular pattern </span>
<span class="pl-c">// in the app path</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">ApplicationAssemblyFilter</span> : <span class="pl-k">AssemblyFilter</span>
{
    <span class="pl-k">public</span> <span class="pl-en">ApplicationAssemblyFilter</span>()
        : <span class="pl-c1">base</span>(AppDomain.CurrentDomain.BaseDirectory, Assembly.GetExecutingAssembly()<span class="pl-en">.GetName</span>().Name + ".*.dll"){}
}</pre></div>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">WindsorContainerAdapter</span> : <span class="pl-k">IContainerAdapter</span>, <span class="pl-k">IDisposable</span> 
{ 
    <span class="pl-k">private</span> <span class="pl-k">readonly</span> IWindsorContainer container; 

    <span class="pl-k">public</span> <span class="pl-en">WindsorContainerAdapter</span>() 
    { 
        container = <span class="pl-k">new</span> WindsorContainer().Install(FromAssembly.InThisApplication(), 
             FromAssembly.InDirectory(<span class="pl-k">new</span> ApplicationAssemblyFilter())); 
    } 

    <span class="pl-k">public</span> T TryResolve&lt;T&gt;() 
    { 
       <span class="pl-k">if</span> (container.Kernel.HasComponent(<span class="pl-k">typeof</span>(T)))
       {
          <span class="pl-k">return</span> (T)container.Resolve(<span class="pl-k">typeof</span>(T));
       }

       <span class="pl-k">return</span> <span class="pl-k">default</span>(T); 
    } 

    <span class="pl-k">public</span> T Resolve&lt;T&gt;() 
    { 
        <span class="pl-k">return</span> container.Resolve&lt;T&gt;(); 
    } 

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Dispose</span>() 
    { 
        container.Dispose(); 
    } 
} </pre></div>

<h3>
<a id="user-content-use-autofac" class="anchor" href="#use-autofac" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Use Autofac</h3>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">AutofacIocAdapter</span> : <span class="pl-k">IContainerAdapter</span>
{
    <span class="pl-k">private</span> <span class="pl-k">readonly</span> IContainer container;

    <span class="pl-k">public</span> <span class="pl-en">AutofacIocAdapter</span>(<span class="pl-k">IContainer</span> <span class="pl-smi">container</span>)
    {
        container = container;
    }

    <span class="pl-k">public</span> T Resolve&lt;T&gt;()
    {
        <span class="pl-k">return</span> container.Resolve&lt;T&gt;();
    }

    <span class="pl-k">public</span> T TryResolve&lt;T&gt;()
    {
        T result;

        <span class="pl-k">if</span> (container.TryResolve&lt;T&gt;(out result))
        {
            <span class="pl-k">return</span> result;
        }

        <span class="pl-k">return</span> <span class="pl-k">default</span>(T);
    }
}</pre></div>

<p>Then in the <code>AppHost</code> <code>Configure(Container container)</code> method you need to enable this adapter:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">//Create Autofac builder</span>
<span class="pl-k">var</span> builder = <span class="pl-k">new</span> ContainerBuilder();
<span class="pl-c">//Now register all depedencies to your custom IoC container</span>
<span class="pl-c">//...</span>

<span class="pl-c">//Register Autofac IoC container adapter, so ServiceStack can use it</span>
IContainerAdapter adapter = <span class="pl-k">new</span> AutofacIocAdapter(builder.Build());
container.Adapter = adapter;</pre></div>

<h3>
<a id="user-content-use-simpleinjector" class="anchor" href="#use-simpleinjector" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Use SimpleInjector</h3>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">SimpleInjectorIocAdapter</span> : <span class="pl-k">IContainerAdapter</span>
{
    <span class="pl-k">private</span> <span class="pl-k">readonly</span> Container container;

    <span class="pl-k">public</span> <span class="pl-en">SimpleInjectorIocAdapter</span>(<span class="pl-k">Container</span> <span class="pl-smi">container</span>)
    {
        <span class="pl-c1">this</span>.container = container;
    }

    <span class="pl-k">public</span> T Resolve&lt;T&gt;() 
    {
        <span class="pl-k">return</span> (T)<span class="pl-c1">this</span>.container.GetInstance(<span class="pl-k">typeof</span>(T));
    }

    <span class="pl-k">public</span> T TryResolve&lt;T&gt;()
    {
        <span class="pl-k">var</span> registration = <span class="pl-c1">this</span>.container.GetRegistration(<span class="pl-k">typeof</span>(T));
        <span class="pl-k">return</span> registration == <span class="pl-c1">null</span> ? <span class="pl-k">default</span>(T) : (T)registration.GetInstance();
    }
}</pre></div>

<p>Then in the <code>AppHost</code> <code>Configure(Container container)</code> method you need to enable this adapter:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">//Create SimpleInjector IoC container</span>
Container container = <span class="pl-k">new</span> Container();
<span class="pl-c">//Now register all depedencies to your custom IoC container</span>
<span class="pl-c">//...</span>

<span class="pl-c">//Register SimpleInjector IoC container, so ServiceStack can use it</span>
container.Adapter = <span class="pl-k">new</span> SimpleInjectorIocAdapter (container);</pre></div>

<h3>
<a id="user-content-use-unity" class="anchor" href="#use-unity" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Use Unity</h3>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">UnityIocAdapter</span> : <span class="pl-k">IContainerAdapter</span>
{
    <span class="pl-k">private</span> <span class="pl-k">readonly</span> IUnityContainer container;

    <span class="pl-k">public</span> <span class="pl-en">UnityIocAdapter</span>(<span class="pl-k">IUnityContainer</span> <span class="pl-smi">container</span>)
    {
        <span class="pl-c1">this</span>.container = container;
    }

    <span class="pl-k">public</span> T Resolve&lt;T&gt;()
    {
        <span class="pl-k">return</span> container.Resolve&lt;T&gt;();
    }

    <span class="pl-k">public</span> T TryResolve&lt;T&gt;()
    {
        <span class="pl-k">if</span>(container.IsRegistered&lt;T&gt;())
        {
            <span class="pl-k">return</span> container.Resolve&lt;T&gt;();
        }

        <span class="pl-k">return</span> <span class="pl-k">default</span>(T);
    }
}</pre></div>

<p>Then in the <code>AppHost</code> <code>Configure(Container container)</code> method you need to enable this adapter:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">//Create Unity IoC container</span>
<span class="pl-k">var</span> unityContainer = <span class="pl-k">new</span> UnityContainer();
<span class="pl-c">//Now register all depedencies to your custom IoC container</span>
<span class="pl-c">//...</span>

<span class="pl-c">//Register SimpleInjector IoC container, so ServiceStack can use it</span>
container.Adapter = <span class="pl-k">new</span> UnityIocAdapter(unityContainer);</pre></div>

<h3>
<a id="user-content-disposing-of-your-services" class="anchor" href="#disposing-of-your-services" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Disposing of your services</h3>

<p>The <code>AppHost.Release(instance)</code> method gets called for every resolved service right after it's used. 
This is the <a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack/ServiceStackHost.cs#L422-L439">default implementation</a> (which can be overridden):</p>

<pre><code>var iocAdapterReleases = Container.Adapter as IRelease;
if (iocAdapterReleases != null)
{
    iocAdapterReleases.Release(instance);
}
else 
{
    var disposable = instance as IDisposable;
    if (disposable != null)
        disposable.Dispose();
}
</code></pre>

<p>Which will first try to call your ContainerAdapter if it implements <code>IRelease</code> otherwise if the service is <code>IDisposable</code> it will just dispose of it itself.</p>

<p>So to have resolved services released back into your IOC, implement the <code>IRelease</code> interface on your IContainerAdapter, e.g:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">WindsorContainerAdapter</span> : <span class="pl-k">IContainerAdapter</span>, <span class="pl-k">IRelease</span>
{ 
    <span class="pl-k">private</span> <span class="pl-k">readonly</span> IWindsorContainer _container; 

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Release</span>(<span class="pl-k">object</span> <span class="pl-smi">instance</span>)
    { 
        _container.Release(instance);
    }
}</pre></div>

<p>Otherwise you can override default implementation in your <code>AppHost.Release(instance)</code> if you want to do something other than the default implementation.</p>

<h1>
<a id="user-content-community-resources" class="anchor" href="#community-resources" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Community Resources</h1>

<ul>
<li>
<a href="http://www.agile-code.com/blog/servicestack-ioc-with-microsoft-unity/">ServiceStack: IoC with Microsoft Unity</a> by <a href="https://twitter.com/zoranmax">@zoranmax</a>
</li>
<li>
<a href="http://bhameyie.com/2013/09/03/servicestack-extensibility-using-mef/">ServiceStack extensibility using MEF</a> by <a href="https://twitter.com/bhameyie">@bhameyie</a>
</li>
</ul>
