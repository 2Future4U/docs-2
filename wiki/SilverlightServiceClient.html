<p>The <strong>recommended</strong> way to get Silverlight builds of ServiceStack client libraries is from <a href="https://nuget.org/packages/ServiceStack.Client.Silverlight">NuGet</a>:</p>

<p><a href="https://nuget.org/packages/ServiceStack.Client"><img src="https://raw.githubusercontent.com/ServiceStack/Assets/master/img/wikis/nuget-servicestack.client.silverlight.png" alt="ServiceStack Silverlight Client on NuGet" style="max-width:100%;"></a></p>

<p>These binaries are custom builds of the full ServiceStack Service Clients providing JSON, JSV and XML ServiceClients.</p>

<blockquote>
<p>Note: Due to restrictions in Silverlight only the Async operations are supported.</p>
</blockquote>

<h2>
<a id="user-content-hellomobile" class="anchor" href="#hellomobile" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a href="https://github.com/ServiceStackApps/HelloMobile">HelloMobile</a>
</h2>

<p>See the <a href="https://github.com/ServiceStackApps/HelloMobile">HelloMobile</a> project for more info on ServiceStack's Silverlight and PCL client support including showing re-use of shared libraries between each of the different mobile platforms.</p>

<hr>

<h3>
<a id="user-content-building-silverlight-json-service-client-from-scratch" class="anchor" href="#building-silverlight-json-service-client-from-scratch" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Building Silverlight JSON Service Client from Scratch</h3>

<p>Although it is recommended to use the published binaries above, for illustrative purposes, this section below walks through creating a Silverlight client from scratch. This example below shows how to create a JSON ServiceClient.</p>

<p><em>Note: The code below has been tested in Silverlight 5.  It should work fine in other versions of Silverlight as well.</em></p>

<h2>
<a id="user-content-please-be-aware-of-the-following-considerations" class="anchor" href="#please-be-aware-of-the-following-considerations" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Please be aware of the following considerations:</h2>

<h3>
<a id="user-content-uses-httpwebrequest-with-clienthttp-handling" class="anchor" href="#uses-httpwebrequest-with-clienthttp-handling" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Uses HttpWebRequest with ClientHttp handling</h3>

<p>The <a href="http://www.silverlight.net/learn/data-networking/network-services-%28soap,-rest-and-more%29/rest-services-%28silverlight-quickstart%29">Silverlight REST Services Quickstart</a> describes the different mechanisms of how http calls can be made from Silverlight.  There is the easier-but-heavier WebClient implementation, and the lighter-but-harder HttpWebRequest implementation.  The code below uses the HttpWebRequest implementation, primarily because you cannot manipulate cookies with the WebClient version, but also because it provides better hooks for serializing and deserializing the JSON we want to send to our ServiceStack service.</p>

<p>It also uses the ClientHttp handling instead of BrowserHttp handling. <a href="http://msdn.microsoft.com/en-us/library/dd920295%28VS.95%29.aspx">See the differences here.</a>  </p>

<p>You may need to put a clientaccesspolicy.xml file in the root of your host.  It depends on the domains of the host and client, and the trust level of the particular Silverlight client application (differs between out-of-browser and between Silverlight versions).  <a href="http://msdn.microsoft.com/en-us/library/cc645032%28v=VS.95%29.aspx">See MSDN documentation for more info.</a></p>

<h3>
<a id="user-content-is-cookie-aware" class="anchor" href="#is-cookie-aware" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Is Cookie-Aware</h3>

<p>In the code below, you will see how cookies can be enabled or disabled.  Because we are using ClientHttp handling, when cookies are enabled, we have to create a custom CookieContainer.</p>

<p>In order to share these cookies with the browser, we are populating from HtmlPage.Document.Cookies before the request, and then setting the cookies back to the browser after getting a response.  This technique allows things like ServiceStack's built-in authentication to work, even if you authenticate in the browser before launching your Silverlight app.</p>

<p>If you don't want to share cookies with the browser, you can set EnableCookies = false, or you can modify the code to persist the CookieContainer in some other way.</p>

<h3>
<a id="user-content-talks-only-json" class="anchor" href="#talks-only-json" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Talks only JSON</h3>

<p>The request and response streams are assumed to be JSON, and the Accept and Content-Type headers are set accordingly.  If you want to implement xml or jsv, you will have to adjust the headers and the content appropriately.</p>

<h5>
<a id="user-content-using-the-datacontractjsonserializer" class="anchor" href="#using-the-datacontractjsonserializer" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Using the DataContractJsonSerializer</h5>

<p>The only JSON serializer that comes with Silverlight is the <a href="http://msdn.microsoft.com/en-us/library/system.runtime.serialization.json.datacontractjsonserializer%28v=vs.95%29.aspx">DataContractJsonSerializer</a>.  While not as performant as ServiceStack's serializers, performance on the client usually tends not to be as important as on the server (due to load).</p>

<p>Note that if you decide to apply a [DataContract] attribute to your DTO that you must specifically mark all members that you want to serialize with [DataMember].  If you leave them off, all public members will be serialized.</p>

<p>The code below uses this serializer by default.  If you use it, be aware that there is a bug in the DataContractJsonSerializer related to handling of dates that are not of type DateTimeKind.Local.  <a href="http://connect.microsoft.com/VisualStudio/feedback/details/723368">Read more here</a></p>

<h5>
<a id="user-content-using-the-servicestack-jsonserializer" class="anchor" href="#using-the-servicestack-jsonserializer" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Using the ServiceStack JsonSerializer</h5>

<p>The Silverlight build of ServiceStack.Text (the one that comes with the ServiceStack.Client.Silverlight) is easy to implement.  There is code in the below sample that is commented out, showing how to do this.  Simply uncomment the code and remove the DCJS implementation, then reference ServiceStack.Text and you now have a faster serializer (one without the date bug).</p>

<h2>
<a id="user-content-example-usage" class="anchor" href="#example-usage" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Example Usage</h2>

<h3>
<a id="user-content-setting-up-your-dtos" class="anchor" href="#setting-up-your-dtos" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Setting up your DTOs</h3>

<p>The regular ServiceStack example DTOs should work:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Hello</span>
{
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Name</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">HelloResponse</span>
{
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Result</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}</pre></div>

<p>Your DTO projects will need to be accessible from both Silverlight and your other .Net projects.  There are two ways to accomplish this:</p>

<h5>
<a id="user-content-shared-projects" class="anchor" href="#shared-projects" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Shared Projects</h5>

<p>You can use a set of shared project for porting your DTOs to Silverlight.  One should be a regular .Net Class Library (perhaps named MySilverlightApp.DTOs), and another should be a Silverlight Class Library (perhaps named MySilverlightApp.DTOs.Silverlight).  You can use the project linking technique <a href="http://10rem.net/blog/2009/07/13/sharing-entities-between-wcf-and-silverlight">documented here</a>.</p>

<p>You may also want to use the Visual Studio Project Linker add-in, which is <a href="http://visualstudiogallery.msdn.microsoft.com/5e730577-d11c-4f2e-8e2b-cbb87f76c044">available here</a> and <a href="http://msdn.microsoft.com/en-us/library/ff921108.aspx">documented here</a>.</p>

<h5>
<a id="user-content-portable-class-libraries" class="anchor" href="#portable-class-libraries" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Portable Class Libraries</h5>

<p>You can put your DTOs in a single project that is set up as a <a href="http://msdn.microsoft.com/en-us/library/gg597391.aspx">Portable Class Library</a>.  This is a much easier solution, but you will not be able to take on any dependencies.</p>

<p>This means that you cannot use the [Route] attribute on your DTOs with this approach.  Instead, use one of the other ways to register services, such as <code>Routes.Add()</code> in your AppHost.Config.</p>

<h3>
<a id="user-content-the-serviceclient-implementation" class="anchor" href="#the-serviceclient-implementation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The ServiceClient Implementation</h3>

<p>Here is the actual code that implements the ServiceClient.  If you've followed all of the above instructions, you should be able to use it easily in your application.  Simply change the namespace as you desire.</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">using</span> System<span class="pl-k">;</span>
<span class="pl-k">using</span> System.Net<span class="pl-k">;</span>
<span class="pl-k">using</span> System.Net.Browser<span class="pl-k">;</span>
<span class="pl-k">using</span> System.Runtime.Serialization.Json<span class="pl-k">;</span>
<span class="pl-k">using</span> System.Windows<span class="pl-k">;</span>
<span class="pl-k">using</span> System.Windows.Browser<span class="pl-k">;</span>
<span class="pl-c">//using ServiceStack.Text;  // uncomment if using SS serializer instead of DCJS.</span>

<span class="pl-k">namespace</span> <span class="pl-en">MySilverlightApp</span>
{
    <span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">ServiceClient</span>&lt;TRequest, TResponse&gt;
        where TRequest : <span class="pl-k">class</span>
        <span class="pl-k">where</span> <span class="pl-k">TResponse</span> : <span class="pl-k">class</span>
    {
        <span class="pl-k">private</span> <span class="pl-k">readonly</span> <span class="pl-k">string</span> _baseUri;

        <span class="pl-k">public</span> <span class="pl-k">bool</span> <span class="pl-en">EnableCookies</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }

        <span class="pl-k">public</span> <span class="pl-en">ServiceClient</span>(<span class="pl-k">string</span> <span class="pl-smi">baseUri</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>/api<span class="pl-pds">"</span></span>)
        {
            <span class="pl-c">// make sure the base uri is set appropriately</span>
            <span class="pl-k">if</span> (!baseUri.StartsWith(<span class="pl-s"><span class="pl-pds">"</span>http<span class="pl-pds">"</span></span>, StringComparison.InvariantCultureIgnoreCase))
            {
                <span class="pl-k">var</span> source = Application.Current.Host.Source;

                <span class="pl-k">string</span> rootUri = <span class="pl-k">string</span>.Empty;
                <span class="pl-k">if</span> (source.AbsoluteUri.Contains(<span class="pl-s"><span class="pl-pds">"</span>ClientBin<span class="pl-pds">"</span></span>))
                {
                    <span class="pl-k">int</span> idx = source.AbsoluteUri.IndexOf(<span class="pl-s"><span class="pl-pds">"</span>ClientBin<span class="pl-pds">"</span></span>);

                    rootUri = source.AbsoluteUri.Substring(<span class="pl-c1">0</span>, idx);
                }
                <span class="pl-k">else</span>
                    rootUri = source.AbsoluteUri.Substring(<span class="pl-c1">0</span>, source.AbsoluteUri.Length - source.AbsolutePath.Length);
                <span class="pl-k">if</span> (!baseUri.StartsWith(<span class="pl-s"><span class="pl-pds">"</span>/<span class="pl-pds">"</span></span>))
                    baseUri = <span class="pl-s"><span class="pl-pds">"</span>/<span class="pl-pds">"</span></span> + baseUri;
                baseUri = rootUri + baseUri;
            }
            <span class="pl-c1">this</span>._baseUri = baseUri;

            <span class="pl-c">// cookies are on by default</span>
            <span class="pl-c1">this</span>.EnableCookies = <span class="pl-c1">true</span>;
        }

        <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Send</span>(<span class="pl-k">string</span> <span class="pl-smi">uri</span>, <span class="pl-k">string</span> <span class="pl-smi">method</span>, <span class="pl-k">TRequest</span> <span class="pl-smi">data</span> <span class="pl-k">=</span> <span class="pl-c1">null</span>)
        {
            <span class="pl-c">// set up the web request</span>
            <span class="pl-k">var</span> webRequest = (HttpWebRequest)WebRequestCreator.ClientHttp.Create(<span class="pl-k">new</span> Uri(_baseUri + uri));
            webRequest.Method = method;

            <span class="pl-c">// if cookies are enabled, pass them in from the browser</span>
            <span class="pl-k">if</span> (<span class="pl-c1">this</span>.EnableCookies)
            {
                webRequest.CookieContainer = <span class="pl-k">new</span> CookieContainer();
                webRequest.CookieContainer.SetCookies(<span class="pl-k">new</span> Uri(_baseUri), HtmlPage.Document.Cookies);
            }

            <span class="pl-c">// set the accept header so our response is in json</span>
            webRequest.Accept = <span class="pl-s"><span class="pl-pds">"</span>application/json<span class="pl-pds">"</span></span>;

            <span class="pl-c">// if we have data to stream, start streaming.  Otherwise we can get the response now.</span>
            <span class="pl-k">if</span> (data != <span class="pl-c1">null</span>)
                webRequest.BeginGetRequestStream(RequestCallback, <span class="pl-k">new</span> DataContainer(webRequest, data));
            <span class="pl-k">else</span>
                webRequest.BeginGetResponse(<span class="pl-c1">this</span>.ResponseCallback, webRequest);
        }

        <span class="pl-k">private</span> <span class="pl-k">void</span> <span class="pl-en">RequestCallback</span>(<span class="pl-k">IAsyncResult</span> <span class="pl-smi">asyncResult</span>)
        {
            <span class="pl-k">try</span>
            {
                <span class="pl-c">// Get the web request stream</span>
                <span class="pl-k">var</span> container = (DataContainer)asyncResult.AsyncState;
                <span class="pl-k">var</span> webRequest = container.WebRequest;
                <span class="pl-k">var</span> stream = webRequest.EndGetRequestStream(asyncResult);

                <span class="pl-c">// set the content type to json</span>
                webRequest.ContentType = <span class="pl-s"><span class="pl-pds">"</span>application/json<span class="pl-pds">"</span></span>;

                <span class="pl-c">// serialize the object to json and write it to the stream</span>
                <span class="pl-k">var</span> serializer = <span class="pl-k">new</span> DataContractJsonSerializer(<span class="pl-k">typeof</span>(TRequest));
                serializer.WriteObject(stream, container.Data);
                stream.Flush();
                stream.Close();

                <span class="pl-c">// If you want to use ServiceStack's serializer, replace the previous code block with this one.</span>
                <span class="pl-c">//using (var writer = new StreamWriter(stream))</span>
                <span class="pl-c">//{</span>
                <span class="pl-c">//    var serializer = new JsonSerializer&lt;TRequest&gt;();</span>
                <span class="pl-c">//    serializer.SerializeToWriter(container.Data, writer);</span>
                <span class="pl-c">//}</span>


                <span class="pl-c">// now we can get the response</span>
                webRequest.BeginGetResponse(ResponseCallback, webRequest);
            }
            <span class="pl-k">catch</span> (Exception ex)
            {
                <span class="pl-c">// Raise our own event for the error on the UI thread</span>
                <span class="pl-k">var</span> args = <span class="pl-k">new</span> ServiceClientEventArgs&lt;TResponse&gt;(ex);
                Deployment.Current.Dispatcher.BeginInvoke(() =&gt; <span class="pl-c1">this</span>.OnCompleted(args));
            }

        }

        <span class="pl-k">private</span> <span class="pl-k">void</span> <span class="pl-en">ResponseCallback</span>(<span class="pl-k">IAsyncResult</span> <span class="pl-smi">asyncResult</span>)
        {
            <span class="pl-k">try</span>
            {
                <span class="pl-c">// Get the web response</span>
                <span class="pl-k">var</span> webRequest = (HttpWebRequest)asyncResult.AsyncState;
                <span class="pl-k">var</span> webResponse = webRequest.EndGetResponse(asyncResult);

                <span class="pl-c">// Get the web response stream</span>
                <span class="pl-k">var</span> stream = webResponse.GetResponseStream();

                <span class="pl-c">// Deserialize the json data in the response stream</span>
                <span class="pl-k">var</span> serializer = <span class="pl-k">new</span> DataContractJsonSerializer(<span class="pl-k">typeof</span>(TResponse));
                <span class="pl-k">var</span> response = (TResponse)serializer.ReadObject(stream);

                <span class="pl-c">// If you want to use ServiceStack's serializer, replace the previous code block with this one.</span>
                <span class="pl-c">//TResponse response;</span>
                <span class="pl-c">//using (var reader = new StreamReader(stream))</span>
                <span class="pl-c">//{</span>
                <span class="pl-c">//    var serializer = new JsonSerializer&lt;TResponse&gt;();</span>
                <span class="pl-c">//    response = serializer.DeserializeFromReader(reader);</span>
                <span class="pl-c">//}</span>


                <span class="pl-c">// Switch to the UI thread</span>
                <span class="pl-k">var</span> args = <span class="pl-k">new</span> ServiceClientEventArgs&lt;TResponse&gt;(response);
                Deployment.Current.Dispatcher.BeginInvoke(
                    () =&gt;
                    {
                        <span class="pl-c">// if cookies are enabled, pass them back to the browser</span>
                        <span class="pl-k">if</span> (<span class="pl-c1">this</span>.EnableCookies &amp;&amp; webRequest.CookieContainer != <span class="pl-c1">null</span>)
                        {
                            <span class="pl-k">var</span> cookieHeader = webRequest.CookieContainer.GetCookieHeader(<span class="pl-k">new</span> Uri(_baseUri));
                            HtmlPage.Document.Cookies = cookieHeader;
                        }

                        <span class="pl-c">//Raise our own event for the response</span>
                        <span class="pl-c1">this</span>.OnCompleted(args);
                    });
            }
            <span class="pl-k">catch</span> (Exception ex)
            {
                <span class="pl-c">// Raise our own event for the error on the UI thread</span>
                <span class="pl-k">var</span> args = <span class="pl-k">new</span> ServiceClientEventArgs&lt;TResponse&gt;(ex);
                Deployment.Current.Dispatcher.BeginInvoke(() =&gt; <span class="pl-c1">this</span>.OnCompleted(args));
            }
        }

        <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Get</span>(<span class="pl-k">string</span> <span class="pl-smi">uri</span>)
        {
            <span class="pl-c1">this</span>.Send(uri, <span class="pl-s"><span class="pl-pds">"</span>GET<span class="pl-pds">"</span></span>);
        }

        <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Post</span>(<span class="pl-k">string</span> <span class="pl-smi">uri</span>, <span class="pl-k">TRequest</span> <span class="pl-smi">data</span> <span class="pl-k">=</span> <span class="pl-c1">null</span>)
        {
            <span class="pl-c1">this</span>.Send(uri, <span class="pl-s"><span class="pl-pds">"</span>POST<span class="pl-pds">"</span></span>, data);
        }

        <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Put</span>(<span class="pl-k">string</span> <span class="pl-smi">uri</span>, <span class="pl-k">TRequest</span> <span class="pl-smi">data</span> <span class="pl-k">=</span> <span class="pl-c1">null</span>)
        {
            <span class="pl-c1">this</span>.Send(uri, <span class="pl-s"><span class="pl-pds">"</span>PUT<span class="pl-pds">"</span></span>, data);
        }

        <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Patch</span>(<span class="pl-k">string</span> <span class="pl-smi">uri</span>, <span class="pl-k">TRequest</span> <span class="pl-smi">data</span> <span class="pl-k">=</span> <span class="pl-c1">null</span>)
        {
            <span class="pl-c1">this</span>.Send(uri, <span class="pl-s"><span class="pl-pds">"</span>PATCH<span class="pl-pds">"</span></span>, data);
        }

        <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Delete</span>(<span class="pl-k">string</span> <span class="pl-smi">uri</span>, <span class="pl-k">TRequest</span> <span class="pl-smi">data</span> <span class="pl-k">=</span> <span class="pl-c1">null</span>)
        {
            <span class="pl-c1">this</span>.Send(uri, <span class="pl-s"><span class="pl-pds">"</span>DELETE<span class="pl-pds">"</span></span>, data);
        }

        <span class="pl-k">public</span> <span class="pl-k">event</span> EventHandler&lt;ServiceClientEventArgs&lt;TResponse&gt;&gt; Completed;

        <span class="pl-k">protected</span> <span class="pl-k">void</span> <span class="pl-en">OnCompleted</span>(ServiceClientEventArgs&lt;TResponse&gt; e)
        {
            <span class="pl-k">var</span> handler = <span class="pl-c1">this</span>.Completed;
            <span class="pl-k">if</span> (handler != <span class="pl-c1">null</span>)
                handler(<span class="pl-c1">this</span>, e);
        }

        <span class="pl-k">private</span> <span class="pl-k">class</span> <span class="pl-en">DataContainer</span>
        {
            <span class="pl-k">public</span> <span class="pl-en">DataContainer</span>(<span class="pl-k">HttpWebRequest</span> <span class="pl-smi">webRequest</span>, <span class="pl-k">TRequest</span> <span class="pl-smi">data</span>)
            {
                <span class="pl-c1">this</span>.WebRequest = webRequest;
                <span class="pl-c1">this</span>.Data = data;
            }

            <span class="pl-k">public</span> HttpWebRequest <span class="pl-en">WebRequest</span> { <span class="pl-k">get</span>; <span class="pl-k">private</span> <span class="pl-k">set</span>; }
            <span class="pl-k">public</span> TRequest <span class="pl-en">Data</span> { <span class="pl-k">get</span>; <span class="pl-k">private</span> <span class="pl-k">set</span>; }
        }
    }

    <span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">ServiceClientEventArgs</span>&lt;TResponse&gt; : <span class="pl-k">EventArgs</span>
        <span class="pl-k">where</span> <span class="pl-k">TResponse</span> : <span class="pl-k">class</span>
    {
        <span class="pl-k">private</span> <span class="pl-k">readonly</span> TResponse _response;
        <span class="pl-k">private</span> <span class="pl-k">readonly</span> Exception _error;

        <span class="pl-k">public</span> <span class="pl-en">ServiceClientEventArgs</span>(<span class="pl-k">TResponse</span> <span class="pl-smi">response</span>)
        {
            <span class="pl-c1">this</span>._response = response;
        }

        <span class="pl-k">public</span> <span class="pl-en">ServiceClientEventArgs</span>(<span class="pl-k">Exception</span> <span class="pl-smi">error</span>)
        {
            <span class="pl-c1">this</span>._error = error;
        }

        <span class="pl-k">public</span> TResponse Response
        {
            <span class="pl-k">get</span> { <span class="pl-k">return</span> <span class="pl-c1">this</span>._response; }
        }

        <span class="pl-k">public</span> Exception Error
        {
            <span class="pl-k">get</span> { <span class="pl-k">return</span> <span class="pl-c1">this</span>._error; }
        }
    }
}</pre></div>

<h1>
<a id="user-content-community-resources" class="anchor" href="#community-resources" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Community Resources</h1>

<ul>
<li>
<a href="http://skov-boisen.dk/?p=214">Silverlight, GZip and ServiceStack</a> by <a href="https://twitter.com/ssboisen">@ssboisen</a>
</li>
</ul>
