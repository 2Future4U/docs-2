<h2>
<a id="user-content-pre-defined-routes" class="anchor" href="#pre-defined-routes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Pre-defined Routes</h2>

<p>Without any configuration required, ServiceStack already includes <a href="http://mono.servicestack.net/ServiceStack.Hello/#predefinedroutes">pre-defined routes</a> for all services in the format:</p>

<pre><code>/api?/[xml|json|html|jsv|csv]/[reply|oneway]/[servicename]
</code></pre>

<blockquote>
<p>servicename is the name of the Request DTO</p>
</blockquote>

<p>e.g. the pre-defined url to call a JSON 'Hello' Service is:</p>

<pre><code>/json/reply/hello
</code></pre>

<h4>
<a id="user-content-auto-batched-requests" class="anchor" href="#auto-batched-requests" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a href="https://github.com/ServiceStack/ServiceStack/wiki/Auto-Batched-Requests">Auto Batched Requests</a>
</h4>

<pre><code>/json/reply/Hello[]
</code></pre>

<h3>
<a id="user-content-soap-web-service-urls" class="anchor" href="#soap-web-service-urls" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>SOAP Web Service urls</h3>

<pre><code>/api?/[soap11|soap12]
</code></pre>

<h2>
<a id="user-content-custom-routes" class="anchor" href="#custom-routes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Custom Routes</h2>

<p>In its most basic form, a Route is just any string literal attributed on your Request DTO:</p>

<pre><code>[Route("/hello")]
public class Hello { ... }
</code></pre>

<p>which matches: </p>

<pre><code>/hello
/hello?Name=XXX
</code></pre>

<h3>
<a id="user-content-variable-place-holders" class="anchor" href="#variable-place-holders" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Variable place-holders</h3>

<p>Routes can also have variable place-holders:</p>

<pre><code>[Route("/hello/{Name}")]
</code></pre>

<p>matches:</p>

<pre><code>/hello/foo
</code></pre>

<p>And will populate the public property <strong>Name</strong> on the Request DTO with <strong>foo</strong>.</p>

<p><em>Note: The QueryString, FormData and HTTP Request Body isn't apart of the Route (i.e. only the /path/info is) but they can all be used in addition to every web service call to further populate the Request DTO.</em></p>

<h3>
<a id="user-content-wildcard-paths" class="anchor" href="#wildcard-paths" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Wildcard paths</h3>

<p>Using a route with a wild card path like:</p>

<pre><code>[Route("/hello/{Name*}")]
</code></pre>

<p>matches any number of variable paths:</p>

<pre><code>/hello
/hello/name
/hello/my/name/is/ServiceStack    //Name = my/name/is/ServiceStack
</code></pre>

<p><a href="http://stackoverflow.com/questions/7780157/multiple-optional-parameters-with-servicestack-net">Another good use-case for when to use wildcard routes</a>.</p>

<h3>
<a id="user-content-fallback-route" class="anchor" href="#fallback-route" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Fallback Route</h3>

<p>Use the <code>FallbackRoute</code> attribute to specify a fallback route starting from the root path, e.g:</p>

<div class="highlight highlight-source-cs"><pre>[FallbackRoute(<span class="pl-s"><span class="pl-pds">"</span>/{Path}<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Fallback</span>
{
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Path</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}</pre></div>

<p>This will match any unmatched route from the root path (e.g. <code>/foo</code> but not <code>/foo/bar</code>) that's not handled by CatchAll Handler or matches a static file. You can also specify a wildcard path e.g. <code>[FallbackRoute("/{Path*}")]</code> which will handle every unmatched route (inc. <code>/foo/bar</code>). Only 1 fallback route is allowed.</p>

<p>The Fallback route is useful for HTML5 Single Page App websites handling server requests of HTML5 pushState pretty urls.</p>

<h3>
<a id="user-content-limiting-to-http-verbs" class="anchor" href="#limiting-to-http-verbs" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Limiting to HTTP Verbs</h3>

<p>If not specified Routes will match <strong>All</strong> HTTP Verbs. You can also limit Routes to individual Verbs, this lets you route the same path to different services, e.g:</p>

<div class="highlight highlight-source-cs"><pre>[Route(<span class="pl-s"><span class="pl-pds">"</span>/contacts<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>GET<span class="pl-pds">"</span></span>)]
[Route(<span class="pl-s"><span class="pl-pds">"</span>/contacts/{Id}<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>GET<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">GetContacts</span> { ... }

[Route(<span class="pl-s"><span class="pl-pds">"</span>/contacts<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>POST PUT<span class="pl-pds">"</span></span>)]
[Route(<span class="pl-s"><span class="pl-pds">"</span>/contacts/{Id}<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>POST PUT<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">UpdateContact</span> { ... }

[Route(<span class="pl-s"><span class="pl-pds">"</span>/contacts/{Id}<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>DELETE<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">DeleteContact</span> { ... }</pre></div>

<h3>
<a id="user-content-matching-ignored-paths" class="anchor" href="#matching-ignored-paths" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Matching ignored paths</h3>

<p>You can use the <code>{ignore}</code> variable placeholder to match a Route definition that doesn't map to a Request DTO property, e.g:</p>

<div class="highlight highlight-source-cs"><pre>[Route(<span class="pl-s"><span class="pl-pds">"</span>/contacts/{Id}/{ignore}<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>GET<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">GetContacts</span> { ... }</pre></div>

<p>Will match on <code>/contacts/1/john-doe</code> request and not require your Request DTO to have an <strong>ignore</strong> property</p>

<h3>
<a id="user-content-fluent-api" class="anchor" href="#fluent-api" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Fluent API</h3>

<p>You can also use a Fluent API to register ServiceStack Routes by adding them in your <code>AppHost.Configure()</code>:</p>

<pre><code>Routes
  .Add&lt;Hello&gt;("/hello")
  .Add&lt;Hello&gt;("/hello/{Name}");
</code></pre>

<p>and to match only <strong>GET</strong> request for <code>/Customers?Key=Value</code> and <code>/Customers/{Id}</code>:</p>

<pre><code>Routes
    .Add&lt;GetContact&gt;("/Contacts", "GET")
    .Add&lt;GetContact&gt;("/Contacts/{ContactId}", "GET");
</code></pre>

<h2>
<a id="user-content-content-negotiation" class="anchor" href="#content-negotiation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Content Negotiation</h2>

<p>In addition to using the standard <code>Accept</code> HTTP Header to retrieve the response a different format, you can also request an alternative Content-Type by appending <strong>?format=ext</strong> to the query string, e.g:</p>

<ul>
<li><a href="http://razor.servicestack.net/rockstars?format=xml">/rockstars?format=xml</a></li>
<li><a href="http://razor.servicestack.net/rockstars/1?format=json">/rockstars/1?format=json</a></li>
</ul>

<p>Or by appending the format <strong>.ext</strong> to the end of the route, e.g:</p>

<ul>
<li><a href="http://razor.servicestack.net/rockstars.xml">/rockstars.xml</a></li>
<li><a href="http://razor.servicestack.net/rockstars/1.json">/rockstars/1.json</a></li>
<li><a href="http://razor.servicestack.net/rockstars.html?id=1">/rockstars.html?id=1</a></li>
</ul>

<p>This is enabled on all custom routes and works for all built-in and user-registered formats. 
It can be disabled by setting <code>Config.AllowRouteContentTypeExtensions = false</code>.</p>

<h2>
<a id="user-content-auto-route-generation-strategies" class="anchor" href="#auto-route-generation-strategies" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Auto Route Generation Strategies</h2>

<p>Also related to this is registering Auto routes via the <a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack/ServiceRoutesExtensions.cs#L23">Routes.AddFromAssembly</a> extension method, where this single call:</p>

<pre><code>Routes.AddFromAssembly(typeof(FooService).Assembly)
</code></pre>

<p>Goes through and scans all your services (in the Assemblies specified) and registers convention-based routes based on all the HTTP methods you have implemented. </p>

<p>The default convention registers routes based on the Request DTO Name, whether it has an <strong>Id</strong> property and what actions were implemented. These conventions are configurable where you can now adjust/remove the existing rules or add your own to the <strong>pre-defined</strong> rules in <code>Config.RouteNamingConventions</code>:</p>

<div class="highlight highlight-source-cs"><pre>RouteNamingConventions = <span class="pl-k">new</span> List&lt;RouteNamingConventionDelegate&gt; {
    RouteNamingConvention.WithRequestDtoName,
    RouteNamingConvention.WithMatchingAttributes,     <span class="pl-c">// defaults: PrimaryKeyAttrubute</span>
    RouteNamingConvention.WithMatchingPropertyNames,  <span class="pl-c">// defaults: Id, IDs</span>
}</pre></div>

<p>The existing rules can be further customized by modifying the related static properties, e.g:</p>

<div class="highlight highlight-source-cs"><pre>RouteNamingConvention.PropertyNamesToMatch.Add(<span class="pl-s"><span class="pl-pds">"</span>UniqueId<span class="pl-pds">"</span></span>);
RouteNamingConvention.AttributeNamesToMatch.Add(<span class="pl-s"><span class="pl-pds">"</span>DefaultIdAttribute<span class="pl-pds">"</span></span>);</pre></div>

<p>Which will make these request DTOs:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">class</span> <span class="pl-en">MyRequest1</span>
{
    <span class="pl-k">public</span> <span class="pl-en">UniqueId</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>;}
}

<span class="pl-k">class</span> <span class="pl-en">MyRequest2</span>
{
    [DefaultId]
    <span class="pl-k">public</span> <span class="pl-en">CustomId</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>;}
}</pre></div>

<p>Generate the following routes:</p>

<pre><code>/myrequest1
/myrequest1/{UniqueId}
/myrequest2
/myrequest2/{CustomId}
</code></pre>

<p>See the implementation of <a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack/Host/RouteNamingConvention.cs">RouteNamingConvention</a> for examples of how to add your own auto-generated route conventions.</p>

<h3>
<a id="user-content-dynamically-adding-route-attributes" class="anchor" href="#dynamically-adding-route-attributes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Dynamically adding Route Attributes</h3>

<p>Routes attributes can also be added dynamically but as Services are auto-registered before <code>AppHost.Configure()</code> runs, Route attributes need to be added before this happens like in the AppHost Constructor or before <code>new AppHost().Init()</code>, i.e:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">AppHost</span> : <span class="pl-k">AppHostBase</span> {
    <span class="pl-k">public</span> <span class="pl-en">AppHost</span>() {
        <span class="pl-k">typeof</span>(MyRequest)
           .AddAttributes(<span class="pl-k">new</span> RouteAttribute(<span class="pl-s"><span class="pl-pds">"</span>/myrequest<span class="pl-pds">"</span></span>))
           .AddAttributes(<span class="pl-k">new</span> RouteAttribute(<span class="pl-s"><span class="pl-pds">"</span>/myrequest/{UniqueId}<span class="pl-pds">"</span></span>));
    }
}</pre></div>

<h3>
<a id="user-content-customizing-defined-routes" class="anchor" href="#customizing-defined-routes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Customizing Defined Routes</h3>

<p>You can customize existing routes by overriding <code>GetRouteAttributes()</code> in your AppHost, the example below adds a <code>/api</code> prefix to all existing routes:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">AppHost</span> : <span class="pl-k">AppHostBase</span>
{
    <span class="pl-c">//...</span>
    <span class="pl-k">public</span> <span class="pl-k">override</span> RouteAttribute[] <span class="pl-en">GetRouteAttributes</span>(<span class="pl-k">Type</span> <span class="pl-smi">requestType</span>)
    {
        <span class="pl-k">var</span> routes = <span class="pl-c1">base</span>.GetRouteAttributes(requestType);
        routes.Each(x =&gt; x.Path = <span class="pl-s"><span class="pl-pds">"</span>/api<span class="pl-pds">"</span></span> + x.Path);
        <span class="pl-k">return</span> routes;
    }
}</pre></div>

<h2>
<a id="user-content-routing-resolution-order" class="anchor" href="#routing-resolution-order" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Routing Resolution Order</h2>

<p>This is described in more detail on the <a href="https://github.com/ServiceStack/ServiceStack/wiki/New-API">New API Design wiki</a> but the weighting used to select a route is based on:</p>

<ol>
<li>Any exact Literal Matches are used first</li>
<li>Exact Verb match is preferred over All Verbs</li>
<li>The more variables in your route the less weighting it has</li>
<li>Routes with wildcard variables have the lowest precedence</li>
<li>When Routes have the same weight, the order is determined by the position of the Action in the service or Order of Registration (FIFO)</li>
</ol>

<h3>
<a id="user-content-route-weighting-example" class="anchor" href="#route-weighting-example" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Route weighting example</h3>

<p>The following HTTP Request:</p>

<pre><code>GET /content/v1/literal/slug
</code></pre>

<p>Will match the following Route definitions in order from highest precedence to lowest:</p>

<div class="highlight highlight-source-cs"><pre>[Route(<span class="pl-s"><span class="pl-pds">"</span>/content/v1/literal/slug<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>GET<span class="pl-pds">"</span></span>)]
[Route(<span class="pl-s"><span class="pl-pds">"</span>/content/v1/literal/slug<span class="pl-pds">"</span></span>)]
[Route(<span class="pl-s"><span class="pl-pds">"</span>/content/v1/literal/{ignore}<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>GET<span class="pl-pds">"</span></span>)]
[Route(<span class="pl-s"><span class="pl-pds">"</span>/content/{ignore}/literal/{ignore}<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>GET<span class="pl-pds">"</span></span>)]
[Route(<span class="pl-s"><span class="pl-pds">"</span>/content/{Version*}/literal/{Slug*}<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>GET<span class="pl-pds">"</span></span>)]
[Route(<span class="pl-s"><span class="pl-pds">"</span>/content/{Version*}/literal/{Slug*}<span class="pl-pds">"</span></span>)]
[Route(<span class="pl-s"><span class="pl-pds">"</span>/content/{Slug*}<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>GET<span class="pl-pds">"</span></span>)]
[Route(<span class="pl-s"><span class="pl-pds">"</span>/content/{Slug*}<span class="pl-pds">"</span></span>)]</pre></div>

<p>See the <a href="https://github.com/ServiceStack/ServiceStack/blob/master/tests/ServiceStack.ServiceHost.Tests/RestPathTests.cs">RestPathTests.cs</a> and <a href="https://github.com/ServiceStack/ServiceStack/wiki/New-API">Smart Routing</a> section on the wiki for more examples.</p>

<h3>
<a id="user-content-reverse-routing" class="anchor" href="#reverse-routing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Reverse Routing</h3>

<p>If you use <code>[Route]</code> metadata attributes (as opposed to the Fluent API) you will be able to generate strong-typed URI's using just the DTOs, letting you create urls outside of ServiceStack web framework as done with <a href="https://github.com/ServiceStack/ServiceStack/wiki/C#-client">.NET Service Clients</a> using the <code>ToUrl(HttpMethod)</code> and <code>ToAbsoluteUri(HttpMethod)</code>, e.g:</p>

<div class="highlight highlight-source-cs"><pre>[Route(<span class="pl-s"><span class="pl-pds">"</span>/reqstars/search<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>GET<span class="pl-pds">"</span></span>)]
[Route(<span class="pl-s"><span class="pl-pds">"</span>/reqstars/aged/{Age}<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">SearchReqstars</span> : <span class="pl-k">IReturn</span>&lt;<span class="pl-k">ReqstarsResponse</span>&gt;
{
    <span class="pl-k">public</span> <span class="pl-k">int</span>? <span class="pl-en">Age</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}

<span class="pl-k">var</span> relativeUrl = <span class="pl-k">new</span> SearchReqstars { Age = <span class="pl-c1">20</span> }.ToGetUrl();
<span class="pl-k">var</span> absoluteUrl = <span class="pl-k">new</span> SearchReqstars { Age = <span class="pl-c1">20</span> }.ToAbsoluteUri();

relativeUrl.Print(); <span class="pl-c">//=  /reqstars/aged/20</span>
absoluteUrl.Print(); <span class="pl-c">//=  http://www.myhost.com/reqstars/aged/20</span></pre></div>

<p>The <a href="https://github.com/ServiceStack/EmailContacts/">Email Contacts demo</a> shows an example of using the above Reverse Routing extension methods to <a href="https://github.com/ServiceStack/EmailContacts/#bootstrap-forms">populate routes for HTML Forms and Links in Razor Views</a>. </p>

<h4>
<a id="user-content-other-reverse-routing-extension-methods" class="anchor" href="#other-reverse-routing-extension-methods" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Other Reverse Routing Extension methods</h4>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">new</span> RequestDto().ToPostUrl();
<span class="pl-k">new</span> RequestDto().ToPutUrl();
<span class="pl-k">new</span> RequestDto().ToDeleteUrl();
<span class="pl-k">new</span> RequestDto().ToOneWayUrl();
<span class="pl-k">new</span> RequestDto().ToReplyUrl();</pre></div>

<h3>
<a id="user-content-customize-urls-used-with-iurlfilter" class="anchor" href="#customize-urls-used-with-iurlfilter" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Customize urls used with <code>IUrlFilter</code>
</h3>

<p>Request DTO's can customize urls used in Service Clients or any libraries using ServiceStack's typed 
<a href="https://github.com/ServiceStack/ServiceStack/wiki/Routing#reverse-routing">Reverse Routing</a> by having 
Request DTO's implement 
<a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack.Interfaces/IUrlFilter.cs">IUrlFilter</a>.</p>

<p>ServiceStack's <a href="https://github.com/ServiceStack/Stripe">Stripe Gateway</a> takes advantage of ServiceStack's
typed Routing feature to implement its 
<a href="https://github.com/ServiceStack/Stripe#open-ended-declarative-message-based-apis">Open-Ended, Declarative Message-based APIs</a>
with minimal effort.</p>

<p>In order to match Stripe's unconventional syntax for specifying arrays on the QueryString of their 3rd party
REST API we use <code>IUrlFilter</code> to customize the url that's used. E.g. we need to specify <code>include[]</code> in order
for the Stripe API to return any optional fields like <strong>total_count</strong>.</p>

<div class="highlight highlight-source-cs"><pre>[Route(<span class="pl-s"><span class="pl-pds">"</span>/customers<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">GetStripeCustomers</span> : <span class="pl-k">IGet</span>, <span class="pl-k">IReturn</span>&lt;<span class="pl-k">StripeCollection</span>&lt;<span class="pl-k">Customer</span>&gt;&gt;, <span class="pl-k">IUrlFilter</span>
{
    <span class="pl-k">public</span> <span class="pl-en">GetStripeCustomers</span>() 
    {
        Include = <span class="pl-k">new</span>[] { <span class="pl-s"><span class="pl-pds">"</span>total_count<span class="pl-pds">"</span></span> };
    }

    [IgnoreDataMember]
    <span class="pl-k">public</span> <span class="pl-k">string</span>[] <span class="pl-en">Include</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }

    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">ToUrl</span>(<span class="pl-k">string</span> <span class="pl-smi">absoluteUrl</span>)
    {
        <span class="pl-k">return</span> Include == <span class="pl-c1">null</span> ? absoluteUrl 
            : absoluteUrl.AddQueryParam(<span class="pl-s"><span class="pl-pds">"</span>include[]<span class="pl-pds">"</span></span>, <span class="pl-k">string</span>.Join(<span class="pl-s"><span class="pl-pds">"</span>,<span class="pl-pds">"</span></span>, Include));
    }
}</pre></div>

<blockquote>
<p><code>[IgnoreDataMember]</code> is used to hide the property being emitted using the default convention</p>
</blockquote>

<p>Which when sending the Request DTO:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> response = client.Get(<span class="pl-k">new</span> GetStripeCustomers());</pre></div>

<p>Generates and sends the relative url:</p>

<pre><code>/customers?include[]=total_count
</code></pre>

<p>Which has the effect of populating the <code>TotalCount</code> property in the typed <code>StripeCollection&lt;StripeCustomer&gt;</code> response.</p>

<h2>
<a id="user-content-routing-metadata" class="anchor" href="#routing-metadata" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Routing Metadata</h2>

<p>Most of the metadata ServiceStack knows about your services are accessible internally via <code>HostContext.Config.Metadata</code> from within ServiceStack and externally via the <code>/operations/metadata</code> route. A link to the <strong>Operations Metadata</strong> page is displayed at the bottom of the /metadata when in ServiceStack is in <code>DebugMode</code>.</p>

<h3>
<a id="user-content-great-performance" class="anchor" href="#great-performance" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Great Performance</h3>

<p>Since <a href="http://samsaffron.com/archive/2011/10/13/optimising-asp-net-mvc3-routing">Routing in ASP.NET MVC can be slow</a> when you have a large number of Routes, it's worthwhile pointing out ServiceStack's Routing implementation is implemented with hash lookups so doesn't suffer the linear performance regression issues you might have had with MVC. So you don't have to worry about degraded performance when registering a large number of Routes.</p>

<h1>
<a id="user-content-community-resources" class="anchor" href="#community-resources" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Community Resources</h1>

<ul>
<li>
<a href="http://dilanperera.wordpress.com/2014/02/23/servicestack-use-routes-to-customise-service-endpoints/">Use routes to customize service endpoints</a>

<ul>
<li><a href="http://dilanperera.wordpress.com/2014/02/24/servicestack-more-on-routes/">More on Routes</a></li>
</ul>
</li>
<li>
<a href="http://jokecamp.wordpress.com/2013/06/11/using-postsharp-to-add-servicestack-route-attributes/">Using PostSharp to Add ServiceStack Route Attributes</a> by <a href="https://twitter.com/jokecamp">@jokecamp</a>
</li>
</ul>
