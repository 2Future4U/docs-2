<h1>
<a id="user-content-validation-and-error-handling" class="anchor" href="#validation-and-error-handling" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Validation and Error Handling</h1>

<p>As validation and error handling is an essential part of developing services, ServiceStack provides a rich array of error handling options that work intuitively out-of-the-box. </p>

<p>Optimized for developer happiness ServiceStack allows you to idiomatically throw C# exceptions directly in your services and trivially consume them on the client with minimal effort, intuitively and conventionally - allowing the opportunity to inject generic error handling routines to handle errors for all your web services. </p>

<p>For bonus REST Internet points the most appropriate HTTP Status code is returned based upon the C# Exception type.</p>

<h3>
<a id="user-content-typed-structured-exceptions-end-to-end" class="anchor" href="#typed-structured-exceptions-end-to-end" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Typed, Structured Exceptions end-to-end</h3>

<p>The error handling support works end-to-end where all errors get auto-serialized into your Response DTO and re-hydrated into a C# Exception on ServiceStack's generic Service Clients. This allows you to idiomatically treat errors like normal C# Exceptions - providing easy access to rich, structured error messages in your clients. </p>

<h3>
<a id="user-content-javascript-support-included" class="anchor" href="#javascript-support-included" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>JavaScript support included</h3>

<p>To make it trivial to consume errors in JavaScript, you can use the lightweight <a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack/js/ss-utils.js">ss-utils.js</a> JavaScript library to trivially bind your response errors to your <strong>HTML form fields</strong> with a <strong>single line of code</strong>.</p>

<hr>

<p>All Error handling and validation options described below are treated in the same way - serialized into the <code>ResponseStatus</code> property of your Response DTO making it possible for your clients applications to generically treat all Web Service Errors in the same way.</p>

<blockquote>
<p><strong>Note:</strong> The response DTO must follow the <strong><code>{Request DTO}Response</code> naming convention</strong> and has to be in the <strong>same namespace</strong> as the request DTO!</p>
</blockquote>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Hello</span> {}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">HelloResponse</span> <span class="pl-c">//Follows naming convention and is in the same namespace as 'Hello'</span>
{
    <span class="pl-k">public</span> ResponseStatus <span class="pl-en">ResponseStatus</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; } <span class="pl-c">//Exception gets serialized here</span>
}</pre></div>

<p>If now an exception occurs in the service implementation, the exception is serialized.</p>

<p><strong>Example JSON output:</strong></p>

<pre><code>{
    "ResponseStatus": {
         "ErrorCode": "NotSupportedException",
         "Message": "..."
    }
}
</code></pre>

<p>It's up to the client how to handle this service error.</p>

<h2>
<a id="user-content-throw-a-c-exception" class="anchor" href="#throw-a-c-exception" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Throw a C# Exception</h2>

<p>The easiest way to generate an Error in ServiceStack is to simply throw a C# Exception:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">object</span> Post(User request) 
{
    <span class="pl-k">if</span> (<span class="pl-k">string</span>.IsNullOrEmpty(request.Name))
        <span class="pl-k">throw</span> <span class="pl-k">new</span> ArgumentNullException(<span class="pl-s"><span class="pl-pds">"</span>Name<span class="pl-pds">"</span></span>);
}</pre></div>

<p>By Default C# Exceptions:</p>

<ul>
<li>Inheriting from ArgumentException are returned as a HTTP StatusCode of <strong>400 BadRequest</strong>
</li>
<li>NotImplementedException is returned as a <strong>405 MethodNotAllowed</strong> </li>
<li>Other normal C# Exceptions are returned as <strong>500 InternalServerError</strong>
</li>
</ul>

<p>All Exceptions gets injected into the ResponseStatus property of your Response DTO that is serialized into your ServiceClient's preferred Content-Type making error handling transparent regardless of your preferred format - i.e. the same C# Error handling code can be used for all ServiceClients.</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">try</span> 
{
    <span class="pl-k">var</span> client = <span class="pl-k">new</span> JsonServiceClient(BaseUri);
    <span class="pl-k">var</span> response = client.Send&lt;UserResponse&gt;(<span class="pl-k">new</span> User());
} 
<span class="pl-k">catch</span> (WebServiceException webEx) 
{
    <span class="pl-c">/*</span>
<span class="pl-c">      webEx.StatusCode  = 400</span>
<span class="pl-c">      webEx.ErrorCode   = ArgumentNullException</span>
<span class="pl-c">      webEx.Message     = Value cannot be null. Parameter name: Name</span>
<span class="pl-c">      webEx.StackTrace  = (your Server Exception StackTrace - if DebugMode is enabled)</span>
<span class="pl-c">      webEx.ResponseDto = (your populated Response DTO)</span>
<span class="pl-c">      webEx.ResponseStatus   = (your populated Response Status DTO)</span>
<span class="pl-c">      webEx.GetFieldErrors() = (individual errors for each field if any)</span>
<span class="pl-c">    */</span>
}</pre></div>

<h3>
<a id="user-content-enabling-stacktraces" class="anchor" href="#enabling-stacktraces" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Enabling StackTraces</h3>

<p>By default display StackTraces in your Response DTOs are disabled, but they're a good to have for development, which you can enable with:</p>

<pre><code>SetConfig(new EndpointHostConfig { DebugMode = true });
</code></pre>

<h2>
<a id="user-content-customized-error-messages" class="anchor" href="#customized-error-messages" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Customized Error Messages</h2>

<p>If you want even finer grained control of your HTTP errors you can either <strong>throw</strong> or <strong>return</strong> a <strong>HttpError</strong> letting you customize the <strong>Http Headers</strong> and <strong>Status Code</strong> and HTTP Response <strong>body</strong> to get exactly what you want on the wire:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">object</span> Get(User request) {
       <span class="pl-k">throw</span> HttpError.NotFound(<span class="pl-s"><span class="pl-pds">"</span>User {0} does not exist<span class="pl-pds">"</span></span>.Fmt(request.Name));
}</pre></div>

<p>the above is a short-hand for <code>new HttpError(HttpStatusCode.NotFound, string.Format("User {0} does not exist", request.Name))</code> which returns a <strong>404</strong> NotFound StatusCode on the wire.</p>

<h2>
<a id="user-content-validation-feature" class="anchor" href="#validation-feature" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Validation Feature</h2>

<p>For more complex validation and to be able to return multiple validation errors ServiceStack includes the excellent <a href="https://github.com/JeremySkinner/FluentValidation">Fluent Validation</a> library by <a href="http://twitter.com/JeremySkinner">@JeremySkinner</a> - a very clean and DSL-like way to validate request DTOs. Even contextual validation for each HTTP method (GET, POST, ...) is supported.</p>

<p>ServiceStack's Fluent Validation feature is encapsulated in the <code>ValidationFeature</code> plugin which can be registered in your AppHost with:</p>

<div class="highlight highlight-source-cs"><pre>Plugins.Add(<span class="pl-k">new</span> ValidationFeature());</pre></div>

<h3>
<a id="user-content-fluentvalidation-for-request-dtos" class="anchor" href="#fluentvalidation-for-request-dtos" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>FluentValidation for request dtos</h3>

<p>The example below uses this request dto for validation:</p>

<div class="highlight highlight-source-cs"><pre>[Route(<span class="pl-s"><span class="pl-pds">"</span>/users<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">User</span>
{
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Name</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Company</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-k">int</span> <span class="pl-en">Age</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-k">int</span> <span class="pl-en">Count</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Address</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}</pre></div>

<p>The validation rules for this request dto are made with <a href="https://github.com/JeremySkinner/FluentValidation/wiki">FluentValidation</a>. ServiceStack makes heavy use of <a href="https://github.com/JeremySkinner/FluentValidation/wiki/b.-Creating-a-Validator#rulesets">rule sets</a> to provide different validation rules for each HTTP method (GET, POST, PUT...).</p>

<blockquote>
<p>Tip: First read the <a href="https://github.com/JeremySkinner/FluentValidation/wiki">documentation about FluentValidation</a> before you continue reading</p>
</blockquote>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">interface</span> <span class="pl-en">IAddressValidator</span>
{
    <span class="pl-k">bool</span> <span class="pl-en">ValidAddress</span>(<span class="pl-k">string</span> <span class="pl-smi">address</span>);
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">AddressValidator</span> : <span class="pl-k">IAddressValidator</span>
{
    <span class="pl-k">public</span> <span class="pl-k">bool</span> <span class="pl-en">ValidAddress</span>(<span class="pl-k">string</span> <span class="pl-smi">address</span>)
    {
    <span class="pl-k">return</span> address != <span class="pl-c1">null</span>
        &amp;&amp; address.Length &gt;= <span class="pl-c1">20</span>
        &amp;&amp; address.Length &lt;= <span class="pl-c1">250</span>;
    }
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">UserValidator</span> : <span class="pl-k">AbstractValidator</span>&lt;<span class="pl-k">User</span>&gt;
{
    <span class="pl-k">public</span> IAddressValidator <span class="pl-en">AddressValidator</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }

    <span class="pl-k">public</span> <span class="pl-en">UserValidator</span>()
    {
        <span class="pl-c">//Validation rules for all requests</span>
        RuleFor(r =&gt; r.Name).NotEmpty();
        RuleFor(r =&gt; r.Age).GreaterThan(<span class="pl-c1">0</span>);
        RuleFor(x =&gt; x.Address).Must(x =&gt; AddressValidator.ValidAddress(x));

        <span class="pl-c">//Validation rules for GET request</span>
        RuleSet(ApplyTo.Get, () =&gt; {
            RuleFor(r =&gt; r.Count).GreaterThan(<span class="pl-c1">10</span>);
        });

        <span class="pl-c">//Validation rules for POST and PUT request</span>
        RuleSet(ApplyTo.Post | ApplyTo.Put, () =&gt; {
            RuleFor(r =&gt; r.Company).NotEmpty();
        });
    }
}</pre></div>

<blockquote>
<p><strong>Info:</strong> ServiceStack adds another extension method named <code>RuleSet</code> which can handle <code>ApplyTo</code> enum flags. This method doesn't exist in the core FluentValidation framework.</p>

<p><strong>Warning:</strong> If a validator for a request dto is created, all rules which aren't in any rule set are executed <strong>+ the rules in the matching rule set</strong>. 
Normally FluentValidation only executes the matching rule set and <strong>ignores</strong> all other rules (whether they're in a rule set or not) and the rules which don't belong 
to any rule set are normally only executed, if no rule set-name was given to the validate method of the validator. </p>
</blockquote>

<p>Like services registered in the IoC container, validators are also auto-wired, so if there's a public property which can be resolved by the IoC container, the IoC container will inject it. In this case, the IoC container will resolve the property <code>AddressValidator</code>, if an object of the type <code>IAdressValidator</code> was registered.</p>

<blockquote>
<p><strong>Tip:</strong> You can access the http request in a validator by implementing <code>IRequiresHttpRequest</code>. Attention, it's lazily loaded and so only available in the validation delegates.</p>
</blockquote>

<h3>
<a id="user-content-register-validators" class="anchor" href="#register-validators" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Register Validators</h3>

<p>All validators have to be registered in the IoC container, a convenient way to register all validators which exist in one assembly is to use <code>RegisterValidators()</code>, e.g:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">//This method scans the assembly for validators</span>
container.RegisterValidators(<span class="pl-k">typeof</span>(UserValidator).Assembly);</pre></div>

<p>Optionally you can also register each validator individually:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">//Add the IAdressValidator which will be injected into the UserValidator</span>
container.Register&lt;IAddressValidator&gt;(<span class="pl-k">new</span> AddressValidator());</pre></div>

<p>Now the service etc can be created and the validation rules are checked every time a request comes in.</p>

<p>If you try now for example to send this request:</p>

<pre><code>POST localhost:50386/validated
{
    "Name": "Max"
} 
</code></pre>

<p>You'll get this JSON response:</p>

<pre><code>{
    "ErrorCode": "GreaterThan",
    "Message": "'Age' must be greater than '0'.",
    "Errors": [
        {
            "ErrorCode": "GreaterThan",
            "FieldName": "Age",
            "Message": "'Age' must be greater than '0'."
        },
        {
            "ErrorCode": "NotEmpty",
            "FieldName": "Company",
            "Message": "'Company' should not be empty."
        }
    ]
}
</code></pre>

<p>As you can see, the <code>ErrorCode</code> and the <code>FieldName</code> provide an easy way to handle the validation error at the client side. 
If you want, you can also configure a custom <code>ErrorCode</code> for a validation rule:</p>

<div class="highlight highlight-source-cs"><pre>RuleFor(x =&gt; x.Name).NotEmpty().WithErrorCode(<span class="pl-s"><span class="pl-pds">"</span>ShouldNotBeEmpty<span class="pl-pds">"</span></span>); </pre></div>

<p>If the rule fails, the JSON response will look like that:</p>

<pre><code>{
    "ErrorCode": "ShouldNotBeEmpty",
    "FieldName": "Name",
    "Message": "'Name' should not be empty."
}
</code></pre>

<h2>
<a id="user-content-use-fluentvalidation-everywhere" class="anchor" href="#use-fluentvalidation-everywhere" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Use FluentValidation everywhere!</h2>

<p>Of course FluentValidation can be used for any other classes (not only request DTOs), too:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">TestClass</span>
{
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Text</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-k">int</span> <span class="pl-en">Length</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}</pre></div>

<p>Now the validator: </p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">TestClassValidator</span> : <span class="pl-k">AbstractValidator</span>&lt;<span class="pl-k">TestClass</span>&gt;
{
    <span class="pl-k">public</span> <span class="pl-en">TestClassValidator</span>()
    {
        RuleFor(x =&gt; x.Text).NotEmpty();
        RuleFor(x =&gt; x.Length).GreaterThan(<span class="pl-c1">0</span>);
    }
}</pre></div>

<blockquote>
<p>Info: If FluentValidation isn't used for request DTOs, it behaves the same as documented in the <a href="https://github.com/JeremySkinner/FluentValidation/wiki">Fluent Validation documentation</a>.</p>
</blockquote>

<p>Inside some service code you can validate an instance of this class:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">SomeService</span> : <span class="pl-k">Service</span>
{
    <span class="pl-c">//You should have registered your validator in the IoC container to inject the validator into this property</span>
    <span class="pl-k">public</span> IValidator&lt;TestClass&gt; <span class="pl-en">Validator</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }

    <span class="pl-k">public</span> <span class="pl-k">object</span> <span class="pl-en">Get</span>(<span class="pl-k">Validated</span> <span class="pl-smi">request</span>)
    {
        TestClass instance = <span class="pl-k">new</span> TestClass();

        ValidationResult result = <span class="pl-c1">this</span>.Validator.Validate(instance);

        <span class="pl-k">if</span> (!result.IsValid)
        {
            <span class="pl-c">//The result will be serialized into a ValidationErrorException and throw this one</span>
            <span class="pl-c">//The errors will be serialized in a clean, human-readable way (as the above JSON example)</span>
            <span class="pl-k">throw</span> result.ToException();
        }

    }
}</pre></div>

<h2>
<a id="user-content-populating-the-response-dto-manually" class="anchor" href="#populating-the-response-dto-manually" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Populating the Response DTO Manually</h2>

<p>All the error handling methods illustrated above are just sugar coating for serializing exceptions into your Response DTOs <a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack.Interfaces/ServiceInterface.ServiceModel/ResponseStatus.cs">ResponseStatus</a> property. You don't have use any of this as you can simply populate the ResponseStatus property yourself, coupled with the HttpResult class you have complete control of your HTTP Response - this gives you the necessary freedom so you are able to define your own Error handling API and helpers if you have an existing validation library that you would like to use instead.</p>
