<p>Using DTOs to define your web service interface makes it possible to provide strong-typed generic service clients without any code-gen or extra build-steps, leading to a productive end-to-end type-safe communication gateway from client to server.</p>

<p><strong>Note</strong>: you have to install the NuGet package <strong>ServiceStack.Client</strong> in your client project, e.g. with the following command in the package manager console:</p>

<pre><code>PM&gt; Install-Package ServiceStack.Client
</code></pre>

<p>Alternatively you can use the <a href="https://github.com/ServiceStack/ServiceStack/wiki/C%23-client#jsonhttpclient">HttpClient-based JsonHttpClient</a> in:</p>

<pre><code>PM&gt; Install-Package ServiceStack.HttpClient
</code></pre>

<p>These packages also contain PCL versions of the Service Clients available with support for <a href="https://github.com/ServiceStackApps/HelloMobile">Xamarin.iOS, Xamarin.Android, Windows Store, WPF and Silverlight 5</a> platforms.</p>

<h3>
<a id="user-content-cache-aware-service-clients" class="anchor" href="#cache-aware-service-clients" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a href="https://github.com/ServiceStack/ServiceStack/wiki/Cache-Aware-Clients">Cache Aware Service Clients</a>
</h3>

<p>When <a href="https://github.com/ServiceStack/ServiceStack/wiki/HTTP-Caching">caching is enabled on Services</a>, the Cache-aware Service Clients can dramatically improve performance by eliminating server requests entirely as well as reducing bandwidth for re-validated requests. They also offer an additional layer of resiliency as re-validated requests that result in Errors will transparently fallback to using pre-existing locally cached responses. For bandwidth-constrained environments like Mobile Apps they can dramatically improve the User Experience.</p>

<p>The Cache-Aware clients implement the full <code>IServiceClient</code> interface so they should be an easy drop-in enhancement for existing Apps:</p>

<div class="highlight highlight-source-cs"><pre>IServiceClient client = <span class="pl-k">new</span> JsonServiceClient(baseUrl).WithCache(); 

<span class="pl-c">//equivalent to:</span>
IServiceClient client = <span class="pl-k">new</span> CachedServiceClient(<span class="pl-k">new</span> JsonServiceClient(baseUrl));</pre></div>

<p>Likewise for the HttpClient-based <code>JsonHttpClient</code>:</p>

<div class="highlight highlight-source-cs"><pre>IServiceClient client = <span class="pl-k">new</span> JsonHttpClient(baseUrl).WithCache(); 

<span class="pl-c">//equivalent to:</span>
IServiceClient client = <span class="pl-k">new</span> CachedHttpClient(<span class="pl-k">new</span> JsonHttpClient(baseUrl));</pre></div>

<h2>
<a id="user-content-rest-api" class="anchor" href="#rest-api" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>REST API</h2>

<p>All ServiceStack's C# clients share the same interfaces and are created by passing in the <strong>Base URI</strong> of your ServiceStack service in the clients constructor, e.g. if your ServiceStack instance was hosted on the root path <code>/</code> on the 8080 custom port:</p>

<pre><code>var client = new JsonServiceClient("http://host:8080/");
</code></pre>

<p>Or if hosted on the <code>/api</code> custom path:</p>

<pre><code>var client = new JsonServiceClient("http://host/api/");
</code></pre>

<p>In addition, the Service Clients provide HTTP verbs (Get, Post &amp; PostFile, Put, Delete, Patch, etc) enabling a productive typed API for consuming ServiceStack Services with their best matching Custom Routes as seen in the examples below:</p>

<blockquote>
<p>See <a href="https://github.com/ServiceStack/ServiceStack/blob/master/docs/pages/IServiceClient.md">IServiceClient</a> for the full API available</p>
</blockquote>

<h3>
<a id="user-content-using-the-new-api" class="anchor" href="#using-the-new-api" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Using the [[New Api]]</h3>

<div class="highlight highlight-source-cs"><pre>HelloResponse response = client.Get(<span class="pl-k">new</span> Hello { Name = <span class="pl-s"><span class="pl-pds">"</span>World!<span class="pl-pds">"</span></span> });
response.Result.Print();</pre></div>

<p><strong>Async Example</strong></p>

<p>Using C# <code>await</code>:</p>

<div class="highlight highlight-source-cs"><pre>HelloResponse response = <span class="pl-k">await</span> client.GetAsync(
    <span class="pl-k">new</span> Hello { Name = <span class="pl-s"><span class="pl-pds">"</span>World!<span class="pl-pds">"</span></span> });</pre></div>

<p>Using Tasks:</p>

<div class="highlight highlight-source-cs"><pre>client.GetAsync(<span class="pl-k">new</span> Hello { Name = <span class="pl-s"><span class="pl-pds">"</span>World!<span class="pl-pds">"</span></span> })
    .Success(r =&gt; r =&gt; r.Result.Print())
    .Error(ex =&gt; { <span class="pl-k">throw</span> ex; });</pre></div>

<h3>
<a id="user-content-alternative-api" class="anchor" href="#alternative-api" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Alternative API</h3>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> response = client.Get&lt;HelloResponse&gt;(<span class="pl-s"><span class="pl-pds">"</span>/hello/World!<span class="pl-pds">"</span></span>);
response.Result.Print();</pre></div>

<p><strong>Async Example</strong></p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> response = <span class="pl-k">await</span> client.GetAsync&lt;HelloResponse&gt;(<span class="pl-s"><span class="pl-pds">"</span>/hello/World!<span class="pl-pds">"</span></span>);</pre></div>

<hr>

<h2>
<a id="user-content-service-client-api" class="anchor" href="#service-client-api" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Service Client API</h2>

<p>C#/.NET Clients can call the above Hello Service using any of the JSON, JSV, XML or SOAP Service Clients with the code below:</p>

<h3>
<a id="user-content-using-the-new-api-1" class="anchor" href="#using-the-new-api-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Using the [[New Api]]</h3>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> response = client.Send(<span class="pl-k">new</span> Hello { Name = <span class="pl-s"><span class="pl-pds">"</span>World!<span class="pl-pds">"</span></span> });
response.Result.Print();</pre></div>

<p><strong>Async Example</strong></p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> response = <span class="pl-k">await</span> client.SendAsync(<span class="pl-k">new</span> Hello { Name = <span class="pl-s"><span class="pl-pds">"</span>World!<span class="pl-pds">"</span></span> });
response.Result.Print();</pre></div>

<h3>
<a id="user-content-alternative-api-1" class="anchor" href="#alternative-api-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Alternative API</h3>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> response = client.Send&lt;HelloResponse&gt;(<span class="pl-k">new</span> Hello { Name = <span class="pl-s"><span class="pl-pds">"</span>World!<span class="pl-pds">"</span></span> });
response.Result.Print();</pre></div>

<p><strong>Async Example</strong></p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> response = <span class="pl-k">await</span> client.SendAsync&lt;HelloResponse&gt;(
    <span class="pl-k">new</span> Hello { Name = <span class="pl-s"><span class="pl-pds">"</span>World!<span class="pl-pds">"</span></span> });</pre></div>

<p>The service clients use the automatic <a href="https://github.com/ServiceStack/ServiceStack/wiki/Endpoints#">pre-defined routes</a> for each service.</p>

<p><a name="user-content-native-responses"></a></p>

<h2>
<a id="user-content-support-for-native-built-in-response-types" class="anchor" href="#support-for-native-built-in-response-types" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Support for Native built-in Response Types</h2>

<p>All of ServiceStack's generic Service Clients also allow you to fetch raw <code>string</code>, <code>byte[]</code> and <code>Stream</code> responses of any existing service, or when you need it, the underlying <code>HttpWebResponse</code> allowing fine-grained access to the HTTP Response. e.g With just the Service below:</p>

<div class="highlight highlight-source-cs"><pre>[Route(<span class="pl-s"><span class="pl-pds">"</span>/poco/{Text}<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Poco</span> : <span class="pl-k">IReturn</span>&lt;<span class="pl-k">PocoResponse</span>&gt;
{
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Text</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">PocoResponse</span>
{
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Result</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">NativeTypesExamples</span> : <span class="pl-k">Service</span>
{
    <span class="pl-k">public</span> PocoResponse <span class="pl-en">Any</span>(<span class="pl-k">Poco</span> <span class="pl-smi">request</span>)
    {
        <span class="pl-c1">base</span>.Response.AddHeader(<span class="pl-s"><span class="pl-pds">"</span>X-Response<span class="pl-pds">"</span></span>, request.Text);
        <span class="pl-k">return</span> <span class="pl-k">new</span> PocoResponse { 
            Result = <span class="pl-s"><span class="pl-pds">"</span>Hello, <span class="pl-pds">"</span></span> + (request.Text ?? <span class="pl-s"><span class="pl-pds">"</span>World!<span class="pl-pds">"</span></span>) 
        };
    }
}</pre></div>

<p>You can access it normally with the typed API:</p>

<div class="highlight highlight-source-cs"><pre>PocoResponse response = client.Get(<span class="pl-k">new</span> Poco { Text = <span class="pl-s"><span class="pl-pds">"</span>World<span class="pl-pds">"</span></span> });
response.Result <span class="pl-c">//Hello, World</span></pre></div>

<p>Or as get the JSON as a raw string:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">string</span> responseJson = client.Get&lt;<span class="pl-k">string</span>&gt;(<span class="pl-s"><span class="pl-pds">"</span>/poco/World<span class="pl-pds">"</span></span>);
<span class="pl-k">var</span> dto = responseJson.FromJson&lt;PocoResponse&gt;();
dto.Result <span class="pl-c">//Hello, World</span></pre></div>

<p>Or as raw bytes:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">byte</span>[] responseBytes = client.Get&lt;<span class="pl-k">byte</span>[]&gt;(<span class="pl-s"><span class="pl-pds">"</span>/poco/World<span class="pl-pds">"</span></span>);
<span class="pl-k">var</span> dto = responseBytes.FromUtf8Bytes().FromJson&lt;PocoResponse&gt;();
dto.Result <span class="pl-c">//Hello, World</span></pre></div>

<p>Or as a Stream:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">using</span> (Stream responseStream = client.Get&lt;Stream&gt;("/poco/World")) {
    <span class="pl-k">var</span> dto = responseStream.ReadFully()
        .FromUtf8Bytes()
        .FromJson&lt;PocoResponse&gt;();
    dto.Result <span class="pl-c">//Hello, World</span>
}</pre></div>

<p>Or even access the populated <code>HttpWebResponse</code> object:</p>

<div class="highlight highlight-source-cs"><pre>HttpWebResponse webResponse = client.Get&lt;HttpWebResponse&gt;(<span class="pl-s"><span class="pl-pds">"</span>/poco/World<span class="pl-pds">"</span></span>);

webResponse.Headers[<span class="pl-s"><span class="pl-pds">"</span>X-Response<span class="pl-pds">"</span></span>] <span class="pl-c">//World</span>
<span class="pl-k">using</span> (var stream = webResponse.GetResponseStream())
<span class="pl-k">using</span> (var sr = new StreamReader(stream)) {
    <span class="pl-k">var</span> dto = sr.ReadToEnd().FromJson&lt;PocoResponse&gt;();
    dto.Result <span class="pl-c">//Hello, World</span>
}</pre></div>

<h3>
<a id="user-content-accessing-raw-service-responses" class="anchor" href="#accessing-raw-service-responses" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Accessing raw service responses</h3>

<p>ServiceStack isn't limited to just returning POCO's as you can effectively <a href="https://github.com/ServiceStack/ServiceStack/wiki/Service-return-types">return anything you want</a> even images 
<a href="http://test.servicestack.net/image-draw/ServiceStack?Width=600&amp;height=300&amp;Foreground=Yellow">/helloimage/ServiceStack?Width=600&amp;height=300&amp;Foreground=Yellow</a>. These native responses can also be mark on your Request DTO <code>IReturn&lt;T&gt;</code> interface marker to give you a terse end-to-end API for fetching raw responses, e.g:</p>

<div class="highlight highlight-source-cs"><pre>[Route(<span class="pl-s"><span class="pl-pds">"</span>/headers/{Text}<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Headers</span> : <span class="pl-k">IReturn</span>&lt;<span class="pl-k">HttpWebResponse</span>&gt;
{
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Text</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}

[Route(<span class="pl-s"><span class="pl-pds">"</span>/strings/{Text}<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Strings</span> : <span class="pl-k">IReturn</span>&lt;<span class="pl-k">string</span>&gt;
{
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Text</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}

[Route(<span class="pl-s"><span class="pl-pds">"</span>/bytes/{Text}<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Bytes</span> : <span class="pl-k">IReturn</span>&lt;<span class="pl-k">byte</span>[]&gt;
{
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Text</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}

[Route(<span class="pl-s"><span class="pl-pds">"</span>/streams/{Text}<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Streams</span> : <span class="pl-k">IReturn</span>&lt;<span class="pl-k">Stream</span>&gt;
{
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Text</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">BuiltInTypesService</span> : <span class="pl-k">Service</span>
{
    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Any</span>(<span class="pl-k">Headers</span> <span class="pl-smi">request</span>)
    {
        <span class="pl-c1">base</span>.Response.AddHeader(<span class="pl-s"><span class="pl-pds">"</span>X-Response<span class="pl-pds">"</span></span>, request.Text);
    }

    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Any</span>(<span class="pl-k">Strings</span> <span class="pl-smi">request</span>)
    {
        <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>Hello, <span class="pl-pds">"</span></span> + (request.Text ?? <span class="pl-s"><span class="pl-pds">"</span>World!<span class="pl-pds">"</span></span>);
    }

    <span class="pl-k">public</span> <span class="pl-k">byte</span>[] <span class="pl-en">Any</span>(<span class="pl-k">Bytes</span> <span class="pl-smi">request</span>)
    {
        <span class="pl-k">return</span> <span class="pl-k">new</span> Guid(request.Text).ToByteArray();
    }

    <span class="pl-k">public</span> <span class="pl-k">byte</span>[] <span class="pl-en">Any</span>(<span class="pl-k">Streams</span> <span class="pl-smi">request</span>)
    {
        <span class="pl-k">return</span> <span class="pl-k">new</span> Guid(request.Text).ToByteArray();
    }        
}</pre></div>

<h3>
<a id="user-content-accessing-client-raw-responses" class="anchor" href="#accessing-client-raw-responses" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Accessing client raw responses</h3>

<p>Which let you access the results as you would a normal response:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">using</span> (HttpWebResponse response = client.Get(new Headers { Text = "World" }))
{
    response.Headers[<span class="pl-s"><span class="pl-pds">"</span>X-Response<span class="pl-pds">"</span></span>] <span class="pl-c">// "World"</span>
}

<span class="pl-k">string</span> response = client.Get(<span class="pl-k">new</span> Strings { Text = <span class="pl-s"><span class="pl-pds">"</span>World<span class="pl-pds">"</span></span> });
response <span class="pl-c">// Hello, World</span>

<span class="pl-k">byte</span>[] response = client.Get(<span class="pl-k">new</span> Bytes { 
    Text = Guid.NewGuid().ToString() 
});
<span class="pl-k">var</span> guid = <span class="pl-k">new</span> Guid(response);

<span class="pl-k">using</span> (Stream stream = client.Get(new Streams { Text = Guid.NewGuid().ToString() })) 
{
    <span class="pl-k">var</span> guid = <span class="pl-k">new</span> Guid(response.ReadFully());
}</pre></div>

<p>All these APIs are also available asynchronously as well:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">using</span> (HttpWebResponse response = await client.GetAsync(
    <span class="pl-k">new</span> Strings { Text = <span class="pl-s"><span class="pl-pds">"</span>Test<span class="pl-pds">"</span></span> })) {
    response.Headers[<span class="pl-s"><span class="pl-pds">"</span>X-Response<span class="pl-pds">"</span></span>] <span class="pl-c">// "World"</span>
}

<span class="pl-k">string</span> response = <span class="pl-k">await</span> client.GetAsync(
    <span class="pl-k">new</span> Strings { Text = <span class="pl-s"><span class="pl-pds">"</span>World<span class="pl-pds">"</span></span> });
response <span class="pl-c">// Hello, World</span>

<span class="pl-k">byte</span>[] response = <span class="pl-k">await</span> client.GetAsync(<span class="pl-k">new</span> Bytes { 
    Text = Guid.NewGuid().ToString() 
});
<span class="pl-k">var</span> guid = <span class="pl-k">new</span> Guid(response);

<span class="pl-k">using</span> (Stream stream = await client.GetAsync(new Streams { 
    Text = Guid.NewGuid().ToString() 
})) 
{
    <span class="pl-k">var</span> guid = <span class="pl-k">new</span> Guid(response.ReadFully());
}</pre></div>

<blockquote>
<p>Note: You must explicitly dispose all APIs returning either <code>HttpWebResponse</code> or <code>Stream</code> as seen in the above examples.</p>
</blockquote>

<p>They all behave the same as the sync versions except for <code>HttpWebResponse</code> which gets returned just after
the request is sent (asynchronously) and before any response is read so you can still access the HTTP Headers e.g:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> client = <span class="pl-k">new</span> JsonServiceClient(<span class="pl-s"><span class="pl-pds">"</span>http://localhost:2020/<span class="pl-pds">"</span></span>) {
    ResponseFilter = httpRes =&gt; {
        <span class="pl-k">var</span> header = httpRes.Headers[<span class="pl-s"><span class="pl-pds">"</span>X-Response<span class="pl-pds">"</span></span>];
    }
};
<span class="pl-k">var</span> response = <span class="pl-k">await</span> client.GetAsync(<span class="pl-k">new</span> Headers { Text = <span class="pl-s"><span class="pl-pds">"</span>World<span class="pl-pds">"</span></span> });</pre></div>

<p>Which makes a great starting point if you want to stream the responses back asynchronously as seen in this
<a href="https://gist.github.com/bamboo/5078236">Reactive ServiceStack example</a> by <a href="https://twitter.com/rodrigobamboo">@rodrigobamboo</a>.</p>

<p>More examples can be found in the ServiceClients <a href="https://github.com/ServiceStack/ServiceStack/blob/master/tests/ServiceStack.WebHost.Endpoints.Tests/ServiceClientsBuiltInResponseTests.cs">Built-in native type response tests</a></p>

<h2>
<a id="user-content-sending-raw-data" class="anchor" href="#sending-raw-data" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Sending Raw Data</h2>

<p>.NET Service Clients can also send raw <code>string</code>, <code>byte[]</code> or <code>Stream</code> Request bodies in their custom Sync or Async API's, e.g:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">string</span> json = <span class="pl-s"><span class="pl-pds">"</span>{<span class="pl-cce">\"</span>Key<span class="pl-cce">\"</span>:1}<span class="pl-pds">"</span></span>;
client.Post&lt;SendRawResponse&gt;(<span class="pl-s"><span class="pl-pds">"</span>/sendraw<span class="pl-pds">"</span></span>, json);

<span class="pl-k">byte</span>[] bytes = json.ToUtf8Bytes();
client.Put&lt;SendRawResponse&gt;(<span class="pl-s"><span class="pl-pds">"</span>/sendraw<span class="pl-pds">"</span></span>, bytes);

Stream stream = <span class="pl-k">new</span> MemoryStream(bytes);
<span class="pl-k">await</span> client.PostAsync&lt;SendRawResponse&gt;(<span class="pl-s"><span class="pl-pds">"</span>/sendraw<span class="pl-pds">"</span></span>, stream);</pre></div>

<h2>
<a id="user-content-authentication" class="anchor" href="#authentication" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Authentication</h2>

<p>ServiceStack's <a href="https://github.com/ServiceStack/ServiceStack/blob/master/tests/ServiceStack.WebHost.Endpoints.Tests/AuthTests.cs#L108">Auth Tests</a> shows different ways of authenticating when using the C# Service Clients. By default BasicAuth and DigestAuth is built into the clients, e.g:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> client = <span class="pl-k">new</span> JsonServiceClient(baseUri) {
    UserName = UserName,
    Password = Password,
};

<span class="pl-k">var</span> request = <span class="pl-k">new</span> Secured { Name = <span class="pl-s"><span class="pl-pds">"</span>test<span class="pl-pds">"</span></span> };
<span class="pl-k">var</span> response = client.Send&lt;SecureResponse&gt;(request);    </pre></div>

<p>Behind the scenes ServiceStack will attempt to send the request normally but when the request is rejected and challenged by the Server the clients will automatically retry the same request but this time with the Basic/Digest Auth headers.</p>

<p>To skip the extra hop when you know you're accessing a secure service, you can tell the clients to always send the BasicAuth header with:</p>

<div class="highlight highlight-source-cs"><pre>client.AlwaysSendBasicAuthHeader = <span class="pl-c1">true</span>;</pre></div>

<p>The alternative way to Authenticate is to make an explicit call to the <code>Auth</code> service (this requires CredentialsAuthProvider enabled) e.g:</p>

<div class="highlight highlight-source-cs"><pre>AuthResponse authResponse = client.Post(<span class="pl-k">new</span> Auth {
    provider = CredentialsAuthProvider.Name,
    UserName = <span class="pl-s"><span class="pl-pds">"</span>user<span class="pl-pds">"</span></span>,
    Password = <span class="pl-s"><span class="pl-pds">"</span>p@55word<span class="pl-pds">"</span></span>,
    RememberMe = <span class="pl-c1">true</span>,  <span class="pl-c">//important tell client to retain permanent cookies</span>
});

<span class="pl-k">var</span> request = <span class="pl-k">new</span> Secured { Name = <span class="pl-s"><span class="pl-pds">"</span>test<span class="pl-pds">"</span></span> };
<span class="pl-k">var</span> response = client.Send&lt;SecureResponse&gt;(request);    </pre></div>

<p>After a successful call to the <code>Auth</code> service the client is Authenticated and if <strong>RememberMe</strong> is set, the client will retain the Session Cookies added by the Server on subsequent requests which is what enables future requests from that client to be authenticated.</p>

<h3>
<a id="user-content-upload-and-download-progress-on-async-apis" class="anchor" href="#upload-and-download-progress-on-async-apis" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Upload and Download Progress on Async API's</h3>

<p>The Async API's support on progress updates with the <code>OnDownloadProgress</code> and <code>OnUploadProgress</code> callbacks which can be used to provide UX Progress updates, e.g:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> client = <span class="pl-k">new</span> JsonServiceClient(ListeningOn);

<span class="pl-c">//Available in ASP.NET/HttpListener when downloading responses with known lengths </span>
<span class="pl-c">//E.g: Strings, Files, etc.</span>
client.OnDownloadProgress = (done, total) =&gt;
    <span class="pl-s"><span class="pl-pds">"</span>{0}/{1} bytes downloaded<span class="pl-pds">"</span></span>.Print(done, total);

<span class="pl-k">var</span> response = <span class="pl-k">await</span> client.GetAsync(<span class="pl-k">new</span> Request());</pre></div>

<blockquote>
<p>Note: total = -1 when 'Transfer-Encoding: chunked'</p>
</blockquote>

<p>Whilst the <code>OnUploadProgress</code> callback gets fired when uploading files, e.g:</p>

<div class="highlight highlight-source-cs"><pre>client.OnUploadProgress = (bytesWritten, total) =&gt; 
    <span class="pl-s"><span class="pl-pds">"</span>Written {0}/{1} bytes...<span class="pl-pds">"</span></span>.Print(bytesWritten, total);

client.PostFileWithRequest&lt;UploadResponse&gt;(url, 
    <span class="pl-k">new</span> FileInfo(path), <span class="pl-k">new</span> Upload { CreatedBy = <span class="pl-s"><span class="pl-pds">"</span>Me<span class="pl-pds">"</span></span> });</pre></div>

<h3>
<a id="user-content-custom-client-caching-strategy" class="anchor" href="#custom-client-caching-strategy" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Custom Client Caching Strategy</h3>

<p>The <code>ResultsFilter</code> and <code>ResultsFilterResponse</code> delegates on Service Clients can be used to enable a custom caching strategy. </p>

<p>Here's a basic example implementing a cache for all <strong>GET</strong> Requests:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> cache = <span class="pl-k">new</span> Dictionary&lt;<span class="pl-k">string</span>, <span class="pl-k">object</span>&gt;();

client.ResultsFilter = (type, method, uri, request) =&gt; {
    <span class="pl-k">if</span> (method != HttpMethods.Get) <span class="pl-k">return</span> <span class="pl-c1">null</span>;
    <span class="pl-k">object</span> cachedResponse;
    cache.TryGetValue(uri, out cachedResponse);
    <span class="pl-k">return</span> cachedResponse;
};
client.ResultsFilterResponse = (webRes, response, method, uri, request) =&gt; {
    <span class="pl-k">if</span> (method != HttpMethods.Get) <span class="pl-k">return</span>;
    cache[uri] = response;
};

<span class="pl-c">//Subsequent requests returns cached result</span>
<span class="pl-k">var</span> response1 = client.Get(<span class="pl-k">new</span> GetCustomer { CustomerId = <span class="pl-c1">5</span> });
<span class="pl-k">var</span> response2 = client.Get(<span class="pl-k">new</span> GetCustomer { CustomerId = <span class="pl-c1">5</span> }); <span class="pl-c">//cached response</span></pre></div>

<p>The <code>ResultsFilter</code> delegate is executed with the context of the request before the request is made. Returning a value of type <code>TResponse</code> short-circuits the request and returns that response. Otherwise the request continues and its response passed into the <code>ResultsFilterResponse</code> delegate where it can be cached. </p>

<h3>
<a id="user-content-implicitly-populate-sessionid-and-version-number" class="anchor" href="#implicitly-populate-sessionid-and-version-number" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Implicitly populate SessionId and Version Number</h3>

<p>Service Clients can be used to auto-populate Request DTO's implementing <code>IHasSessionId</code> or <code>IHasVersion</code> by assigning the <code>Version</code> and <code>SessionId</code> properties on the Service Client, e.g:</p>

<div class="highlight highlight-source-cs"><pre>client.Version = <span class="pl-c1">1</span>;
client.SessionId = authResponse.SessionId;</pre></div>

<p>Which populates the SessionId and Version number on each Request DTO's that implementing the specific interfaces, e.g:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Hello</span> : <span class="pl-k">IReturn</span>&lt;<span class="pl-k">HelloResponse</span>&gt;, <span class="pl-k">IHasSessionId</span>, <span class="pl-k">IHasVersion</span> {
    <span class="pl-k">public</span> <span class="pl-k">int</span> <span class="pl-en">Version</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">SessionId</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Name</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}

client.Get(<span class="pl-k">new</span> Hello { Name = <span class="pl-s"><span class="pl-pds">"</span>World<span class="pl-pds">"</span></span> }); <span class="pl-c">//Auto populates Version and SessionId</span></pre></div>

<h3>
<a id="user-content-http-verb-interface-markers" class="anchor" href="#http-verb-interface-markers" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>HTTP Verb Interface Markers</h3>

<p>You can decorate your Request DTO's using the <code>IGet</code>, <code>IPost</code>, <code>IPut</code>, <code>IDelete</code> and <code>IPatch</code> interface markers and the <code>Send</code> and  <code>SendAsync</code> API's will use it to automatically send the Request using the selected HTTP Method. E.g:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">HelloByGet</span> : <span class="pl-k">IReturn</span>&lt;<span class="pl-k">HelloResponse</span>&gt;, <span class="pl-k">IGet</span> 
{
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Name</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">HelloByPut</span> : <span class="pl-k">IReturn</span>&lt;<span class="pl-k">HelloResponse</span>&gt;, <span class="pl-k">IPut</span> 
{
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Name</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}

<span class="pl-k">var</span> response = client.Send(<span class="pl-k">new</span> HelloByGet { Name = <span class="pl-s"><span class="pl-pds">"</span>World<span class="pl-pds">"</span></span> }); <span class="pl-c">//GET</span>

<span class="pl-k">await</span> client.SendAsync(<span class="pl-k">new</span> HelloByPut { Name = <span class="pl-s"><span class="pl-pds">"</span>World<span class="pl-pds">"</span></span> }); <span class="pl-c">//PUT</span></pre></div>

<p>Interface markers is supported in all .NET Service Clients, they're also included in the generated 
<a href="https://github.com/ServiceStack/ServiceStack/wiki/Add-ServiceStack-Reference">Add ServiceStack Reference</a> DTO's so they're also available in the
<a href="https://github.com/ServiceStack/ServiceStack/wiki/Java-Add-ServiceStack-Reference">Java JsonServiceClient</a> and
<a href="https://github.com/ServiceStack/ServiceStack/wiki/Swift-Add-ServiceStack-Reference">Swift JsonServiceClient</a>. It's also available in our 3rd Party <a href="https://github.com/ServiceStack/Stripe">StripeGateway</a>.</p>

<p>Whilst a simple feature, it enables treating your remote services as a message-based API 
<a href="https://github.com/ServiceStack/ServiceStack/wiki/Advantages-of-message-based-web-services#advantages-of-message-based-designs">yielding its many inherent advantages</a> 
where your Application API's need only pass Request DTO models around to be able to invoke remote Services, decoupling the Service Request from its implementation which can be now easily managed by a high-level adapter that takes care of proxying the Request to the underlying Service Client. The adapter could also add high-level functionality of it's own including auto retrying of failed requests, generic error handling, logging/telemetrics, event notification, throttling, offline queuing/syncing, etc.</p>

<h3>
<a id="user-content-multiple-file-uploads" class="anchor" href="#multiple-file-uploads" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Multiple File Uploads</h3>

<p>The <code>PostFilesWithRequest</code> APIs available in all .NET Service Clients allow you to easily upload multiple 
streams within a single HTTP request. It supports populating Request DTO with any combination of QueryString 
and POST'ed FormData in addition to multiple file upload data streams:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">using</span> (var stream1 = uploadFile1.OpenRead())
<span class="pl-k">using</span> (var stream2 = uploadFile2.OpenRead())
{
    <span class="pl-k">var</span> client = <span class="pl-k">new</span> JsonServiceClient(baseUrl);
    <span class="pl-k">var</span> response = client.PostFilesWithRequest&lt;MultipleFileUploadResponse&gt;(
        <span class="pl-s"><span class="pl-pds">"</span>/multi-fileuploads?CustomerId=123<span class="pl-pds">"</span></span>,
        <span class="pl-k">new</span> MultipleFileUpload { CustomerName = <span class="pl-s"><span class="pl-pds">"</span>Foo,Bar<span class="pl-pds">"</span></span> },
        <span class="pl-k">new</span>[] {
            <span class="pl-k">new</span> UploadFile(<span class="pl-s"><span class="pl-pds">"</span>upload1.png<span class="pl-pds">"</span></span>, stream1),
            <span class="pl-k">new</span> UploadFile(<span class="pl-s"><span class="pl-pds">"</span>upload2.png<span class="pl-pds">"</span></span>, stream2),
        });
}</pre></div>

<p>Example using only a Typed Request DTO. The <code>JsonHttpClient</code> also includes async equivalents for each of the 
<code>PostFilesWithRequest</code> APIs:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">using</span> (var stream1 = uploadFile1.OpenRead())
<span class="pl-k">using</span> (var stream2 = uploadFile2.OpenRead())
{
    <span class="pl-k">var</span> client = <span class="pl-k">new</span> JsonHttpClient(baseUrl);
    <span class="pl-k">var</span> response = <span class="pl-k">await</span> client.PostFilesWithRequestAsync&lt;MultipleFileUploadResponse&gt;(
        <span class="pl-k">new</span> MultipleFileUpload { CustomerId = <span class="pl-c1">123</span>, CustomerName = <span class="pl-s"><span class="pl-pds">"</span>Foo,Bar<span class="pl-pds">"</span></span> },
        <span class="pl-k">new</span>[] {
            <span class="pl-k">new</span> UploadFile(<span class="pl-s"><span class="pl-pds">"</span>upload1.png<span class="pl-pds">"</span></span>, stream1),
            <span class="pl-k">new</span> UploadFile(<span class="pl-s"><span class="pl-pds">"</span>upload2.png<span class="pl-pds">"</span></span>, stream2),
        });
}</pre></div>

<h3>
<a id="user-content-serviceclient-url-resolvers" class="anchor" href="#serviceclient-url-resolvers" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>ServiceClient URL Resolvers</h3>

<p>The urls used in all .NET Service Clients are now customizable with the new <code>UrlResolver</code> and <code>TypedUrlResolver</code> 
delegates. </p>

<p>E.g. you can use this feature to rewrite the URL used with the Request DTO Type Name used as the subdomain by:</p>

<div class="highlight highlight-source-cs"><pre>[Route(<span class="pl-s"><span class="pl-pds">"</span>/test<span class="pl-pds">"</span></span>)] 
<span class="pl-k">class</span> <span class="pl-en">Request</span> {}

<span class="pl-k">var</span> client = JsonServiceClient(<span class="pl-s"><span class="pl-pds">"</span>http://example.org/api<span class="pl-pds">"</span></span>) {
    TypedUrlResolver =  (meta, httpMethod, dto) =&gt; 
        meta.BaseUri.Replace(<span class="pl-s"><span class="pl-pds">"</span>example.org<span class="pl-pds">"</span></span>, dto.GetType().Name + <span class="pl-s"><span class="pl-pds">"</span>.example.org<span class="pl-pds">"</span></span>)
            .CombineWith(dto.ToUrl(httpMethod, meta.Format)));
};

<span class="pl-k">var</span> res = client.Get(<span class="pl-k">new</span> Request());  <span class="pl-c">//= http://Request.example.org/api/test</span>
<span class="pl-k">var</span> res = client.Post(<span class="pl-k">new</span> Request()); <span class="pl-c">//= http://Request.example.org/api/test</span></pre></div>

<p>This feature is also implemented in <code>JsonHttpClient</code>, examples below shows rewriting APIs that use custom urls:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> client = JsonHttpClient(<span class="pl-s"><span class="pl-pds">"</span>http://example.org/api<span class="pl-pds">"</span></span>) {
    UrlResolver = (meta, httpMethod, url) =&gt; 
        meta.BaseUri.Replace(<span class="pl-s"><span class="pl-pds">"</span>example.org<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>111.111.111.111<span class="pl-pds">"</span></span>).CombineWith(url))
};

<span class="pl-k">await</span> client.DeleteAsync&lt;MockResponse&gt;(<span class="pl-s"><span class="pl-pds">"</span>/dummy<span class="pl-pds">"</span></span>); 
<span class="pl-c">//=http://111.111.111.111/api/dummy</span>

<span class="pl-k">await</span> client.PutAsync&lt;MockResponse&gt;(<span class="pl-s"><span class="pl-pds">"</span>/dummy<span class="pl-pds">"</span></span>, <span class="pl-k">new</span> Request()); 
<span class="pl-c">//=http://111.111.111.111/api/dummy</span></pre></div>

<h2>
<a id="user-content-servicestackdiscoveryconsul" class="anchor" href="#servicestackdiscoveryconsul" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a href="https://github.com/wwwlicious/servicestack-discovery-consul">ServiceStack.Discovery.Consul</a>
</h2>

<p>This feature makes it easier to support features like
<a href="https://github.com/wwwlicious/servicestack-discovery-consul">ServiceStack.Discovery.Consul</a>
plugin which enables external RequestDTO endpoint discovery 
by integrating with <a href="http://consul.io">Consul.io</a> to provide automatic service registration and health checking.</p>

<hr>

<h2>
<a id="user-content-built-in-clients" class="anchor" href="#built-in-clients" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Built-in Clients</h2>

<p>All REST and ServiceClients share the same interfaces (<code>IServiceClient</code>, <code>IRestClient</code> and <code>IRestClientAsync</code>) so they can easily be replaced (for increased perf/debuggability/etc) with a single line of code.</p>

<h3>
<a id="user-content-jsonhttpclient" class="anchor" href="#jsonhttpclient" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>JsonHttpClient</h3>

<p>The new <code>JsonHttpClient</code> is an alternative to the existing generic typed <code>JsonServiceClient</code> for consuming ServiceStack Services which instead of using <strong>HttpWebRequest</strong> is based on Microsoft's latest async <a href="https://www.nuget.org/packages/Microsoft.Net.Http">HttpClient</a>. </p>

<p>JsonHttpClient implements the full <a href="https://gist.github.com/mythz/4683438240820b522d39">IServiceClient API</a> making it an easy drop-in replacement for your existing JsonServiceClient where in most cases it can simply be renamed to JsonHttpClient, e.g:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">//IServiceClient client = new JsonServiceClient("http://techstacks.io");</span>
IServiceClient client = <span class="pl-k">new</span> JsonHttpClient(<span class="pl-s"><span class="pl-pds">"</span>http://techstacks.io<span class="pl-pds">"</span></span>);

<span class="pl-k">var</span> response = <span class="pl-k">await</span> client.GetAsync(<span class="pl-k">new</span> GetTechnology { Slug = <span class="pl-s"><span class="pl-pds">"</span>servicestack<span class="pl-pds">"</span></span> })</pre></div>

<h4>
<a id="user-content-install" class="anchor" href="#install" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Install</h4>

<p>JsonHttpClient can be downloaded from NuGet at:</p>

<pre><code>&gt; Install-Package ServiceStack.HttpClient
</code></pre>

<h3>
<a id="user-content-modernhttpclient" class="anchor" href="#modernhttpclient" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a href="https://github.com/paulcbetts/ModernHttpClient">ModernHttpClient</a>
</h3>

<p>One of the primary benefits of being based on <code>HttpClient</code> is being able to make use of 
<a href="https://github.com/paulcbetts/ModernHttpClient">ModernHttpClient</a> which provides a thin wrapper around iOS's native <code>NSURLSession</code> or <code>OkHttp</code> client on Android, offering improved stability for 3G mobile connectivity.</p>

<p>To enable, install <a href="https://www.nuget.org/packages/ModernHttpClient">ModernHttpClient</a> then set the 
Global HttpMessageHandler Factory to configure all <code>JsonHttpClient</code> instances to use ModernHttpClient's <code>NativeMessageHandler</code>: </p>

<div class="highlight highlight-source-cs"><pre>JsonHttpClient.GlobalHttpMessageHandlerFactory = () =&gt; <span class="pl-k">new</span> NativeMessageHandler()</pre></div>

<p>Alternatively, you can configure a single client instance to use ModernHttpClient with:</p>

<div class="highlight highlight-source-cs"><pre>client.HttpMessageHandler = <span class="pl-k">new</span> NativeMessageHandler();</pre></div>

<h3>
<a id="user-content-differences-with-jsonserviceclient" class="anchor" href="#differences-with-jsonserviceclient" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Differences with JsonServiceClient</h3>

<p>Whilst the goal is to retain the same behavior in both clients, there are some differences resulting from using HttpClient where the Global and Instance Request and Response Filters are instead passed HttpClients <code>HttpRequestMessage</code> and <code>HttpResponseMessage</code>. </p>

<p>Also, all API's are <strong>Async</strong> under-the-hood where any Sync API's that doesn't return a <code>Task&lt;T&gt;</code> just blocks on the Async <code>Task.Result</code> response. As this can dead-lock in certain environments we recommend sticking with the Async API's unless safe to do otherwise. </p>

<h3>
<a id="user-content-httpwebrequest-service-clients" class="anchor" href="#httpwebrequest-service-clients" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>HttpWebRequest Service Clients</h3>

<p>Whilst the list below contain the built-in clients based on .NET's built-in <code>HttpWebRequest</code>:</p>

<ul>
<li>implements both <code>IRestClient</code> and <code>IServiceClient</code>:

<ul>
<li>
<a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack.Client/JsonServiceClient.cs">JsonServiceClient</a>
(uses default endpoint with <strong>JSON</strong>) - recommended</li>
<li>
<a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack.Client/JsvServiceClient.cs">JsvServiceClient</a>
(uses default endpoint with <strong>JSV</strong>)</li>
<li>
<a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack.Client/XmlServiceClient.cs">XmlServiceClient</a>
(uses default endpoint with <strong>XML</strong>)</li>
<li>
<a href="https://github.com/ServiceStack/ServiceStack/wiki/MessagePack-Format">MsgPackServiceClient</a>
(uses default endpoint with <strong>Message-Pack</strong>)</li>
<li>
<a href="https://github.com/ServiceStack/ServiceStack/wiki/Protobuf-format">ProtoBufServiceClient</a>
(uses default endpoint with <strong>Protocol Buffers</strong>)</li>
</ul>
</li>
<li>implements <code>IServiceClient</code> only:

<ul>
<li>
<a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack.Client/Soap11ServiceClient.cs">Soap11ServiceClient</a> (uses <strong>SOAP 11</strong> endpoint)</li>
<li>
<a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack.Client/Soap12ServiceClient.cs">Soap12ServiceClient</a>
(uses <strong>SOAP 12</strong> endpoint)</li>
</ul>
</li>
</ul>

<h4>
<a id="user-content-install-1" class="anchor" href="#install-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Install</h4>

<p>The HttpWebRequest clients above are available in:</p>

<pre><code>&gt; Install-Package ServiceStack.Client
</code></pre>

<h1>
<a id="user-content-community-resources" class="anchor" href="#community-resources" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Community Resources</h1>

<ul>
<li>
<a href="https://gist.github.com/bamboo/5078236">Reactive ServiceStack</a> by <a href="https://twitter.com/rodrigobamboo">@rodrigobamboo</a>
</li>
</ul>
