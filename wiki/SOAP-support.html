<p>If you want to support SOAP, you have to ensure you adhere to some additional constraints where each method needs to be defined with the <code>Any()</code> endpoint and each DTO needs to be decorated with <code>[DataContract]</code> and <code>[DataMember]</code> attributes so their metadata is generated in your Services XSD and WSDL metadata.</p>

<h2>
<a id="user-content-soap--rest" class="anchor" href="#soap--rest" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Soap + Rest</h2>

<p>SOAP only supports a single <code>POST</code> request but REST services also make use of <code>GET</code>, <code>PUT</code>, <code>DELETE</code>, etc requests, which aren't used in SOAP. So if you want to support SOAP and REST, you need to create one service for each operation which is also the <a href="http://stackoverflow.com/a/15235822/85785">recommended API structure</a> for creating <a href="http://stackoverflow.com/a/15941229/85785">message-based Services</a>. The difference to be able to support SOAP is that Service implementations need to be defined with <code>Any()</code>, e.g:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">//Request DTO - Add DataMember attribute for all properties.</span>
[DataContract]
[Route(<span class="pl-s"><span class="pl-pds">"</span>/customers<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>GET<span class="pl-pds">"</span></span>)]
[Route(<span class="pl-s"><span class="pl-pds">"</span>/customers/{Id}<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>GET<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">GetCustomers</span> {...}

[DataContract]
[Route(<span class="pl-s"><span class="pl-pds">"</span>/customers<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>POST<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">AddCustomer</span> {...}

[DataContract]
[Route(<span class="pl-s"><span class="pl-pds">"</span>/customers/{Id}<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>PUT<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">UpdateCustomer</span> {...}

[DataContract]
[Route(<span class="pl-s"><span class="pl-pds">"</span>/customers/{Id}<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>DELETE<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">DeleteCustomer</span> {...}

<span class="pl-c">//Service</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">CustomersService</span> : <span class="pl-k">Service</span> 
{
   <span class="pl-k">public</span> <span class="pl-k">object</span> <span class="pl-en">Any</span>(<span class="pl-k">GetCustomers</span> <span class="pl-smi">request</span>){...}
   <span class="pl-k">public</span> <span class="pl-k">object</span> <span class="pl-en">Any</span>(<span class="pl-k">AddCustomer</span> <span class="pl-smi">request</span>){...}
   <span class="pl-k">public</span> <span class="pl-k">object</span> <span class="pl-en">Any</span>(<span class="pl-k">UpdateCustomer</span> <span class="pl-smi">request</span>){...}
   <span class="pl-k">public</span> <span class="pl-k">object</span> <span class="pl-en">Any</span>(<span class="pl-k">DeleteCustomer</span>  <span class="pl-smi">request</span>){...}
}</pre></div>

<p>Using <code>Any</code> will allow the Service to be executed on each HTTP Verb which is required for SOAP since all SOAP Requests are made with a HTTP POST Request wrapped inside a SOAP message and sent to the fixed <code>/soap11</code> or <code>/soap12</code> endpoints. You also want to make sure that <strong>all DTO models</strong> have <code>[DataContract]</code> attribute (and <code>[DataMember]</code> attribute for <strong>all properties</strong>) otherwise the XSD-schema embedded within the WSDL will be partially incomplete.  </p>

<h3>
<a id="user-content-rest-ful-registration-of-multiple-services" class="anchor" href="#rest-ful-registration-of-multiple-services" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>REST-ful registration of multiple services</h3>

<p>The Custom <code>[Route]</code> definitions are used to control how you want services exposed in REST APIs which all logically appear to exposed them under a single REST-ful resource, i.e:</p>

<pre><code>GET /customers    - Get All Customers
GET /customers/1  - Get Customer #1
POST /customers   - Add New Customer
PUT /customers/1  - Update Customer #1 
DELETE /customers - Delete Customer #1
</code></pre>

<p>This Web Service now supports both <strong>REST and SOAP</strong> with REST API's using the above custom routes and SOAP requests posting WSDL Requests to their fixed <code>/soap11</code> or <code>/soap12</code> endpoints.</p>

<h3>
<a id="user-content-raw-access-to-wcf-soap-message" class="anchor" href="#raw-access-to-wcf-soap-message" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Raw Access to WCF SOAP Message</h3>

<p><code>IRequiresSoapMessage</code> works similar to <a href="https://github.com/ServiceStack/ServiceStack/wiki/Serialization-deserialization">IRequiresRequestStream</a> interface to tell ServiceStack to skip de-serialization of the request and instead pass the raw WCF Message to the Service instead for manual processing, e.g:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">RawWcfMessage</span> : <span class="pl-k">IRequiresSoapMessage</span> {
    <span class="pl-k">public</span> Message <span class="pl-en">Message</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}

<span class="pl-k">public</span> <span class="pl-k">object</span> Post(RawWcfMessage request) { 
    request.Message... <span class="pl-c">//Raw WCF SOAP Message</span>
}</pre></div>

<h2>
<a id="user-content-soap-limitations" class="anchor" href="#soap-limitations" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>SOAP Limitations</h2>

<p>SOAP expects that <strong>each request always returns the same response DTO</strong>. So you need to <strong>follow the response DTO naming convention</strong>, otherwise <strong>ServiceStack won't be able to generate the WSDLs</strong> and the SOAP endpoint won't work. </p>

<h3>
<a id="user-content-dto-naming-conventions" class="anchor" href="#dto-naming-conventions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>DTO Naming Conventions</h3>

<blockquote>
<p><strong>Naming convention:</strong>
{Request DTO Name} + Response</p>

<p><strong>Example:</strong>
Request DTO: <code>DeleteCustomer</code> --&gt; Response DTO: <code>DeleteCustomerResponse</code>.</p>
</blockquote>

<p>If you would leave the services as they are, the REST endpoint wouldn't exist. So you need to hook them all up on the same URL like that:</p>

<h3>
<a id="user-content-single-wsdl-namespace" class="anchor" href="#single-wsdl-namespace" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Single WSDL Namespace</h3>

<p>If you happen to generate requests from the WSDLs with a tool like SoapUI you may end up with an incorrectly generated request like this:</p>

<div class="highlight highlight-text-xml"><pre>&lt;<span class="pl-ent">soap</span><span class="pl-ent">:</span><span class="pl-ent">Envelope</span> <span class="pl-e">xmlns</span><span class="pl-e">:</span><span class="pl-e">soap</span>=<span class="pl-s"><span class="pl-pds">"</span>http://www.w3.org/2003/05/soap-envelope<span class="pl-pds">"</span></span> 
               <span class="pl-e">xmlns</span><span class="pl-e">:</span><span class="pl-e">type</span>=<span class="pl-s"><span class="pl-pds">"</span>http://schemas.servicestack.net/types<span class="pl-pds">"</span></span>&gt;
  &lt;<span class="pl-ent">soap</span><span class="pl-ent">:</span><span class="pl-ent">Header</span>/&gt;
  &lt;<span class="pl-ent">soap</span><span class="pl-ent">:</span><span class="pl-ent">Body</span>&gt;
    &lt;<span class="pl-ent">type</span><span class="pl-ent">:</span><span class="pl-ent">Hello</span>/&gt;
  &lt;/<span class="pl-ent">soap</span><span class="pl-ent">:</span><span class="pl-ent">Body</span>&gt;
&lt;/<span class="pl-ent">soap</span><span class="pl-ent">:</span><span class="pl-ent">Envelope</span>&gt;</pre></div>

<p>You can resolve this issue by adding the following line to your AssemblyInfo file</p>

<div class="highlight highlight-source-cs"><pre>[assembly: ContractNamespace(<span class="pl-s"><span class="pl-pds">"</span>http://schemas.servicestack.net/types<span class="pl-pds">"</span></span>, 
           ClrNamespace = <span class="pl-s"><span class="pl-pds">"</span>&lt;YOUR NAMESPACE&gt;<span class="pl-pds">"</span></span>)]</pre></div>

<p>e.g:</p>

<div class="highlight highlight-source-cs"><pre>[assembly: ContractNamespace(<span class="pl-s"><span class="pl-pds">"</span>http://schemas.servicestack.net/types<span class="pl-pds">"</span></span>,
           ClrNamespace = <span class="pl-s"><span class="pl-pds">"</span>MyApp.ServiceModel<span class="pl-pds">"</span></span>)]
[assembly: ContractNamespace(<span class="pl-s"><span class="pl-pds">"</span>http://schemas.servicestack.net/types<span class="pl-pds">"</span></span>,
           ClrNamespace = <span class="pl-s"><span class="pl-pds">"</span>MyApp.ServiceModel.Types<span class="pl-pds">"</span></span>)]</pre></div>

<p>Rebuild and regenerate the request from the updated wsdl. You should get a correct request this time.</p>

<div class="highlight highlight-text-xml"><pre>&lt;<span class="pl-ent">soap</span><span class="pl-ent">:</span><span class="pl-ent">Envelope</span> <span class="pl-e">xmlns</span><span class="pl-e">:</span><span class="pl-e">soap</span>=<span class="pl-s"><span class="pl-pds">"</span>http://www.w3.org/2003/05/soap-envelope<span class="pl-pds">"</span></span> 
               <span class="pl-e">xmlns</span><span class="pl-e">:</span><span class="pl-e">type</span>=<span class="pl-s"><span class="pl-pds">"</span>http://schemas.servicestack.net/types<span class="pl-pds">"</span></span>&gt;
   &lt;<span class="pl-ent">soap</span><span class="pl-ent">:</span><span class="pl-ent">Header</span>/&gt;
   &lt;<span class="pl-ent">soap</span><span class="pl-ent">:</span><span class="pl-ent">Body</span>&gt;
      &lt;<span class="pl-ent">type</span><span class="pl-ent">:</span><span class="pl-ent">Hello</span>&gt;
         <span class="pl-c">&lt;!--Optional:--&gt;</span>
         &lt;<span class="pl-ent">type</span><span class="pl-ent">:</span><span class="pl-ent">Name</span>&gt;?&lt;/<span class="pl-ent">type</span><span class="pl-ent">:</span><span class="pl-ent">Name</span>&gt;
      &lt;/<span class="pl-ent">type</span><span class="pl-ent">:</span><span class="pl-ent">Hello</span>&gt;
   &lt;/<span class="pl-ent">soap</span><span class="pl-ent">:</span><span class="pl-ent">Body</span>&gt;
&lt;/<span class="pl-ent">soap</span><span class="pl-ent">:</span><span class="pl-ent">Envelope</span>&gt;</pre></div>

<h2>
<a id="user-content-changing-the-default-namespace" class="anchor" href="#changing-the-default-namespace" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Changing the default namespace</h2>

<p>A requirement with SOAP endpoints is for all DTO types to share the same single namespace which should match the <code>Config.WsdlServiceNamespace</code> if you want to change it from the default namespace: <code>http://schemas.servicestack.net/types</code>. E.g. You can change the default WSDL Namespace in your AppConfig with:</p>

<div class="highlight highlight-source-cs"><pre>SetConfig(<span class="pl-k">new</span> HostConfig {
    WsdlServiceNamespace = <span class="pl-s"><span class="pl-pds">"</span>http://my.new.namespace.com/types<span class="pl-pds">"</span></span>,
});</pre></div>

<p>This can easily be done by using the <code>[assembly:ContractNamespace]</code> attribute usually defined in the DTO project's AssemblyInfo.cs file, here is how this is done in the <a href="https://github.com/ServiceStack/ServiceStack.Examples/blob/master/src/ServiceStack.Examples/ServiceStack.Examples.ServiceModel/Properties/AssemblyInfo.cs#L39">ServiceStack.Examples project</a>:</p>

<div class="highlight highlight-source-cs"><pre>[assembly: ContractNamespace(<span class="pl-s"><span class="pl-pds">"</span>http://my.new.namespace.com/types<span class="pl-pds">"</span></span>,
           ClrNamespace = <span class="pl-s"><span class="pl-pds">"</span>ServiceStack.Examples.ServiceModel.Operations<span class="pl-pds">"</span></span>)]
[assembly: ContractNamespace(<span class="pl-s"><span class="pl-pds">"</span>http://my.new.namespace.com/types<span class="pl-pds">"</span></span>,
           ClrNamespace = <span class="pl-s"><span class="pl-pds">"</span>ServiceStack.Examples.ServiceModel.Types<span class="pl-pds">"</span></span>)]</pre></div>

<h3>
<a id="user-content-soap-exceptions" class="anchor" href="#soap-exceptions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>SOAP Exceptions</h3>

<p>Exceptions in SOAP responses are returned with an <code>200 OK</code> HTTP Status so they are deserialized as normal responses in code-generated SOAP clients. The original HTTP Status code is available in the <code>X-Status</code> HTTP Header or SOAP Response Header named <code>X-Status</code>. This is transparently converted into a typed WebServiceException when using ServiceStack's built-in Soap 1.1/1.2 generic Service Clients as seen in <a href="https://github.com/ServiceStack/ServiceStack/blob/master/tests/ServiceStack.WebHost.IntegrationTests/Tests/WebServicesTests.cs">WebServicesTests</a>.</p>

<p>To check if the response was an error in non ServiceStack SOAP clients, check the response.ResponseStatus.ErrorCode property for a non-null value.</p>

<h4>
<a id="user-content-convert-soap-exceptions-to-soap-faults" class="anchor" href="#convert-soap-exceptions-to-soap-faults" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Convert SOAP Exceptions to SOAP Faults</h4>

<p>If preferred, you can also convert SOAP Exceptions into a SOAP Fault by adding a ServiceExceptionHandler, e.g:</p>

<div class="highlight highlight-source-cs"><pre>ServiceExceptionHandlers.Add((req, request, ex) =&gt; {
    <span class="pl-k">var</span> requestMsg = req.GetItem(<span class="pl-s"><span class="pl-pds">"</span>SoapMessage<span class="pl-pds">"</span></span>) <span class="pl-k">as</span> System.ServiceModel.Channels.Message;
    <span class="pl-k">if</span> (requestMsg != <span class="pl-c1">null</span>)
    {
        <span class="pl-k">var</span> msgVersion = requestMsg.Version;
        <span class="pl-k">using</span> (<span class="pl-k">var</span> response = XmlWriter.Create(req.Response.OutputStream))
        {
            <span class="pl-k">var</span> message = System.ServiceModel.Channels.Message.CreateMessage(
                msgVersion, <span class="pl-k">new</span> FaultCode(<span class="pl-s"><span class="pl-pds">"</span>Receiver<span class="pl-pds">"</span></span>), ex.ToString(), <span class="pl-c1">null</span>);
            message.WriteMessage(response);
        }
        req.Response.End();
    }
    <span class="pl-k">return</span> <span class="pl-c1">null</span>;
});</pre></div>

<h2>
<a id="user-content-customize-wsdls-and-xsds" class="anchor" href="#customize-wsdls-and-xsds" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Customize WSDL's and XSD's</h2>

<p>There's finer-grain control available over which <strong>Operations</strong> and <strong>Types</strong> are exported in SOAP WSDL's and XSD's by overriding the new <code>ExportSoapOperationTypes()</code> and <code>ExportSoapType()</code> methods in your AppHost.</p>

<p>You can exclude specific Request DTO's from being emitted in WSDL's and XSD's with:</p>

<div class="highlight highlight-source-cs"><pre>[Exclude(Feature.Soap)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">HiddenFromSoap</span> { .. } </pre></div>

<h3>
<a id="user-content-customize-soap-response" class="anchor" href="#customize-soap-response" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Customize SOAP Response</h3>

<p>You can override and customize how the SOAP Message Responses are written, here's a basic example:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">override</span> WriteSoapMessage(Message message, Stream outputStream)
{
    <span class="pl-k">using</span> (<span class="pl-k">var</span> writer = XmlWriter.Create(outputStream, Config.XmlWriterSettings))
    {
        message.WriteMessage(writer);
    }
}</pre></div>

<blockquote>
<p>The default <a href="https://github.com/ServiceStack/ServiceStack/blob/fb08f5cb408ece66f203f677a4ec14ee9aad78ae/src/ServiceStack/ServiceStackHost.Runtime.cs#L484">WriteSoapMessage</a> implementation also raises a ServiceException and writes any returned response to a buffered Response Stream (if configured).</p>
</blockquote>

<h3>
<a id="user-content-visual-studios-add-service-reference" class="anchor" href="#visual-studios-add-service-reference" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Visual Studios Add Service Reference</h3>

<p>Since VS.NET's <code>Add Service Reference</code> is optimized for consuming <strong>.asmx</strong> or <strong>WCF</strong> RPC method calls it doesn't properly support multiple return values (e.g. when you also want a ResponseStatus property) where it will generate an ugly proxy API complete with <strong>out</strong> parameters.</p>

<p>If you want to ensure a <em>pretty proxy</em> is generated you should only have 1 first-level property which contains all the data you want to return.</p>

<h3>
<a id="user-content-using-xsdexe" class="anchor" href="#using-xsdexe" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Using XSD.exe</h3>

<p>One way around it is to share your services DTO's and use any of the typed <a href="https://github.com/ServiceStack/ServiceStack/wiki/Clients-overview">Generic Service Clients</a> that are in-built into ServiceStack. Alternatively you can use the <code>XSD.exe</code> command-line utility to generate your types on the client and use those in the typed Service Clients.</p>
