<p>In ServiceStack.Text's JsvFormatter class are extension methods which recursively dumps all the public properties of any type into a human readable <strong>pretty formatted</strong> string.</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">string</span> Dump&lt;T&gt;(<span class="pl-c1">this</span> T instance);
<span class="pl-k">string</span> SerializeAndFormat&lt;T&gt;(<span class="pl-c1">this</span> T instance);

<span class="pl-k">void</span> PrintDump&lt;T&gt;(<span class="pl-c1">this</span> T instance);</pre></div>

<p>The <code>Dump</code> and <code>SerializeAndFormat</code> methods achieve the same result, where the logically named but lengthier <code>SerializeAndFormat</code> describes exactly what it does, although most of the time we don't care and are happy to use the shortened <code>Dump</code> to mean the same thing. </p>

<p>There's also a convenient <code>PrintDump</code> extension which just writes the output to the Console to provide a wrist-friendly API for a common use-case.</p>

<h2>
<a id="user-content-example-usage" class="anchor" href="#example-usage" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Example Usage</h2>

<p>After importing the <strong>ServiceStack.Text</strong> namespace you can view the values of all fields as seen in <a href="https://github.com/ServiceStack/ServiceStack.Text/blob/master/tests/ServiceStack.Text.Tests/Utils/JsvFormatterTests.cs">the following example</a>:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> model = <span class="pl-k">new</span> TestModel();
model.PrintDump();</pre></div>

<h3>
<a id="user-content-example-output" class="anchor" href="#example-output" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Example Output</h3>

<div class="highlight highlight-source-cs"><pre>{
    Int: <span class="pl-c1">1</span>,
    String: One,
    DateTime: <span class="pl-c1">2010</span>-<span class="pl-c1">04</span>-<span class="pl-c1">11</span>,
    Guid: c050437f6fcd46be9b2d0806a0860b3e,
    EmptyIntList: [],
    IntList:
    [
        <span class="pl-c1">1</span>,
        <span class="pl-c1">2</span>,
        <span class="pl-c1">3</span>
    ],
    StringList:
    [
        one,
        two,
        three
    ],
    StringIntMap:
    {
        a: <span class="pl-c1">1</span>,
        b: <span class="pl-c1">2</span>,
        c: <span class="pl-c1">3</span>
    }
}</pre></div>

<h3>
<a id="user-content-inbuilt-into-service-stack-jsv-web-service-endpoint" class="anchor" href="#inbuilt-into-service-stack-jsv-web-service-endpoint" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Inbuilt into Service Stack JSV web service endpoint</h3>

<p>As this feature has come in super useful for debugging, it's also included it as part of the JSV endpoint by simply appending <code>&amp;debug</code> anywhere in the request’s query string. </p>

<p>Even if you don’t use the new JSV endpoint you can still benefit from it by instantly being able to read the data provided by your web service. Here are some live examples showing the same web services called from the XML and JSV endpoint that shows the difference in readability:</p>

<ul>
<li><a href="http://mono.servicestack.net/ServiceStack.Examples.Host.Web/ServiceStack/Jsv/SyncReply/GetNorthwindCustomerOrders?debug">GetNorthwindCustomerOrders</a></li>
<li><a href="http://mono.servicestack.net/ServiceStack.Examples.Host.Web/ServiceStack/Jsv/SyncReply/GetFibonacciNumbers?Skip=5&amp;Take=10&amp;debug#">GetFibonacciNumbers?Skip=5&amp;Take=10</a></li>
</ul>
