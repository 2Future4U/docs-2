<h1>
<a id="user-content-serialization-and-deserialization" class="anchor" href="#serialization-and-deserialization" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Serialization and deserialization</h1>

<h3>
<a id="user-content-passing-complex-objects-in-the-query-string" class="anchor" href="#passing-complex-objects-in-the-query-string" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Passing complex objects in the Query String</h3>

<p>ServiceStack uses the <a href="https://github.com/ServiceStack/ServiceStack.Text/wiki/JSV-Format">JSV-Format</a> (JSON without quotes) to parse QueryStrings.</p>

<p>JSV lets you embed deep object graphs in QueryString as seen <a href="http://www.servicestack.net/ServiceStack.Examples.Host.Web/ServiceStack/Json/SyncReply/StoreLogs?Loggers=%5B%7BId:786,Devices:%5B%7BId:5955,Type:Panel,TimeStamp:1199303309,Channels:%5B%7BName:Temperature,Value:58%7D,%7BName:Status,Value:On%7D%5D%7D,%7BId:5956,Type:Tank,TimeStamp:1199303309,Channels:%5B%7BName:Volume,Value:10035%7D,%7BName:Status,Value:Full%7D%5D%7D%5D%7D%5D">this example url</a>:</p>

<pre><code>http://www.servicestack.net/ServiceStack.Examples.Host.Web/ServiceStack/Json/
SyncReply/StoreLogs?Loggers=[{Id:786,Devices:[{Id:5955,Type:Panel,
  Channels:[{Name:Temperature,Value:58},{Name:Status,Value:On}]},
  {Id:5956,Type:Tank,TimeStamp:1199303309,
  Channels:[{Name:Volume,Value:10035},{Name:Status,Value:Full}]}]}]
</code></pre>

<p>If you want to change the default binding ServiceStack uses, you can register your own <strong>Custom Request Binder</strong>.</p>

<h2>
<a id="user-content-custom-media-types" class="anchor" href="#custom-media-types" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Custom Media Types</h2>

<p>ServiceStack serializes and deserializes your DTOs automatically. If you want to override the default serializers or you want to add a new format, you have to register your own <code>Content-Type</code>:</p>

<h3>
<a id="user-content-register-a-custom-format" class="anchor" href="#register-a-custom-format" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Register a custom format</h3>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">string</span> contentType = <span class="pl-s"><span class="pl-pds">"</span>application/yourformat<span class="pl-pds">"</span></span>; <span class="pl-c">//To override JSON eg, write "application/json"</span>
<span class="pl-k">var</span> serialize = (IRequest req, <span class="pl-k">object</span> response, Stream stream) =&gt; ...;
<span class="pl-k">var</span> deserialize = (Type type, Stream stream) =&gt; ...;

<span class="pl-c">//In AppHost Configure method</span>
<span class="pl-c">//Pass two delegates for serialization and deserialization</span>
<span class="pl-c1">this</span>.ContentTypes.Register(contentType, serialize, deserialize);    </pre></div>

<p>The [[Protobuf-format]] shows an example of registering a new format whilst the <a href="http://www.servicestack.net/ServiceStack.Northwind/vcard-format.htm">Northwind VCard Format</a> shows an example of creating a custom media type in ServiceStack.</p>

<hr>

<h2>
<a id="user-content-reading-in-and-de-serializing-ad-hoc-custom-requests" class="anchor" href="#reading-in-and-de-serializing-ad-hoc-custom-requests" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Reading in and De-Serializing ad-hoc custom requests</h2>

<p>There are 2 ways to deserialize your own custom format, via attaching a custom request binder for a particular service or marking your service with <code>IRequiresRequestStream</code> which will skip auto-deserialization and inject the ASP.NET Request stream instead.</p>

<h3>
<a id="user-content-create-a-custom-request-dto-binder" class="anchor" href="#create-a-custom-request-dto-binder" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Create a custom request dto binder</h3>

<p>You can register custom binders in your AppHost by using the example below:</p>

<pre><code>base.RequestBinders.Add(typeof(MyRequest), httpReq =&gt; ... requestDto);
</code></pre>

<p>This gives you access to the IHttpRequest object letting you parse it manually so you can construct and return the strong-typed request DTO manually which will be passed to the service instead.</p>

<h3>
<a id="user-content-uploading-files" class="anchor" href="#uploading-files" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Uploading Files</h3>

<p>You can access uploaded files independently of the Request DTO using <code>Request.Files</code>. e.g:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">object</span> Post(MyFileUpload request)
{
    <span class="pl-k">if</span> (<span class="pl-c1">this</span>.Request.Files.Length &gt; <span class="pl-c1">0</span>)
    {
        <span class="pl-k">var</span> uploadedFile = <span class="pl-c1">base</span>.Request.Files[<span class="pl-c1">0</span>];
        uploadedFile.SaveTo(MyUploadsDirPath.CombineWith(file.FileName));
    }
    <span class="pl-k">return</span> HttpResult.Redirect(<span class="pl-s"><span class="pl-pds">"</span>/<span class="pl-pds">"</span></span>);
}</pre></div>

<p>ServiceStack's <a href="http://imgur.servicestack.net">imgur.servicestack.net</a> example shows how to access the <a href="https://github.com/ServiceStackApps/Imgur/blob/master/src/Imgur/Global.asax.cs#L62">byte stream of multiple uploaded files</a>, e.g:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">object</span> Post(Upload request)
{
    <span class="pl-k">foreach</span> (<span class="pl-k">var</span> uploadedFile <span class="pl-k">in</span> <span class="pl-c1">base</span>.Request.Files
       .Where(uploadedFile =&gt; uploadedFile.ContentLength &gt; <span class="pl-c1">0</span>))
    {
        <span class="pl-k">using</span> (<span class="pl-k">var</span> ms = <span class="pl-k">new</span> MemoryStream())
        {
            uploadedFile.WriteTo(ms);
            WriteImage(ms);
        }
    }
    <span class="pl-k">return</span> HttpResult.Redirect(<span class="pl-s"><span class="pl-pds">"</span>/<span class="pl-pds">"</span></span>);
}</pre></div>

<h3>
<a id="user-content-reading-directly-from-the-request-stream" class="anchor" href="#reading-directly-from-the-request-stream" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Reading directly from the Request Stream</h3>

<p>Instead of registering a custom binder you can skip the serialization of the request DTO, you can add the <a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack.Interfaces/ServiceHost/IRequiresRequestStream.cs">IRequiresRequestStream</a> interface to directly retrieve the stream without populating the request DTO.</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">//Request DTO</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Hello</span> : <span class="pl-k">IRequiresRequestStream</span>
{
    <span class="pl-c">/// &lt;<span class="pl-ent">summary</span>&gt;</span>
    <span class="pl-c">/// The raw Http Request Input Stream</span>
    <span class="pl-c">/// &lt;/<span class="pl-ent">summary</span>&gt;</span>
    Stream <span class="pl-en">RequestStream</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}</pre></div>

<p>You can access raw WCF Message when accessed with the SOAP endpoints in your Service with <code>IHttpRequest.GetSoapMessage()</code> extension method, e.g:</p>

<pre><code>Message requestMsg = base.Request.GetSoapMessage();
</code></pre>

<p>To tell ServiceStack to skip Deserializing the SOAP request entirely, add the <code>IRequiresSoapMessage</code> interface to your Request DTO, e.g:</p>

<pre><code>public class RawWcfMessage : IRequiresSoapMessage {
    public Message Message { get; set; }
}

public object Post(RawWcfMessage request) { 
    request.Message... //Raw WCF SOAP Message
}
</code></pre>

<h3>
<a id="user-content-buffering-the-request-and-response-streams" class="anchor" href="#buffering-the-request-and-response-streams" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Buffering the Request and Response Streams</h3>

<p>ServiceStack's Request and Response stream are non-buffered (i.e. forward-only) by default. This can be changed at runtime using a PreRequestFilter to allow the Request Body and Response Output stream to be re-read multiple times should your Services need it:</p>

<div class="highlight highlight-source-cs"><pre>appHost.PreRequestFilters.Add((httpReq, httpRes) =&gt; {
    httpReq.UseBufferedStream = <span class="pl-c1">true</span>;
    httpRes.UseBufferedStream = <span class="pl-c1">true</span>;    
});</pre></div>
