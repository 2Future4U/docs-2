<h2>
<a id="user-content-servicestacks-new-api-design" class="anchor" href="#servicestacks-new-api-design" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>ServiceStack's new API design</h2>

<p>We're excited to announce a brand new API design for ServiceStack that's essentially better in every way than our previous API design:</p>

<ul>
<li>Promotes a more succinct, typed, end-to-end client API </li>
<li>Works with all the existing JSON, XML and JSV Service Clients</li>
<li>Typed client APIs use user-defined <a href="http://www.w3.org/TR/cooluris/">Cool Uris</a> without needing to build strings on the HTTP Client</li>
<li>Supports handling of any HTTP Verb </li>
<li>Less Restrictive and Opinionated - Allows for 'Pure Responses' whilst retaining structured exceptions in the typed clients</li>
<li>Each service can now handle any number of different Request types and HTTP Verbs</li>
<li>Easier to use - Merges and simplifies existing IService and IRestService concepts and interfaces together</li>
<li>Introduces finer-grained Action Request and Response filters</li>
<li>Smarter Routing</li>
<li>Easier to add custom hooks that's more decoupled and testable</li>
<li>Works with ServiceStack's existing features, e.g. Content Negotiation, Metadata pages, Razor views, Auto HTML report, etc.</li>
</ul>

<p>All this and the existing API wasn't actually bad :) It still promoted one of the DRY-est, typed APIs available in any .NET existing Web Services Framework, whilst continue to provide the most features out-of-the-box.</p>

<p>To give you a flavour of the new API design, you can now create a service with:</p>

<div class="highlight highlight-source-cs"><pre>[Route(<span class="pl-s"><span class="pl-pds">"</span>/reqstars<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">AllReqstars</span> : <span class="pl-k">IReturn</span>&lt;<span class="pl-k">List</span>&lt;<span class="pl-k">Reqstar</span>&gt;&gt; { }

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">ReqstarsService</span> : <span class="pl-k">Service</span>
{
    <span class="pl-k">public</span> List&lt;Reqstar&gt; <span class="pl-en">Get</span>(<span class="pl-k">AllReqstars</span> <span class="pl-smi">request</span>) 
    {
        <span class="pl-k">return</span> Db.Select&lt;Reqstar&gt;();
    }
}</pre></div>

<p>That your C# clients can call with just:</p>

<div class="highlight highlight-source-cs"><pre>List&lt;Reqstar&gt; response = client.Get(<span class="pl-k">new</span> AllReqstars());</pre></div>

<p>This will make a <strong>GET</strong> call to the custom <code>/reqstars</code> url, making it the <strong>minimum effort required in any Typed REST API in .NET!</strong> 
When the client doesn't contain the <code>[Route]</code> definition it automatically falls back to using ServiceStack's <a href="http://www.servicestack.net/ServiceStack.Hello/#predefinedroutes">pre-defined routes</a> - saving an extra LOC!</p>

<h3>
<a id="user-content-inspiration" class="anchor" href="#inspiration" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Inspiration</h3>

<p>We were heavily inspired by <a href="http://korneliuk.blogspot.com/2012/08/servicestack-reusing-dtos.html">Ivan Korneliuk's proposal</a> on how he customised ServiceStack to provide an even more succinct client API. We've embraced his idea and baked it into the heart of the framework which is now shipping in the latest release of ServiceStack (v3.9.13+). The beauty of this proposal was that it already fitted perfectly with ServiceStack's existing message-based semantics which meant we were able to implement it in record time without any disruption or breaking changes to the existing code-base. The result is that you can now start creating new services along side your existing services and they'll both continue to work seamlessly side-by-side.</p>

<h3>
<a id="user-content-recommended-for-future-web-service-development" class="anchor" href="#recommended-for-future-web-service-development" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Recommended for future Web Service Development</h3>

<p>As the new API Design offers many benefits over the existing API, we're recommending its use for any new web service development. It will take us some time, but we intend to port all the old examples to adopt the new API ourselves. One reason to still prefer the older API is if you also wanted to <a href="https://github.com/ServiceStack/ServiceStack/wiki/SOAP-support">support SOAP clients and endpoints</a> which still requires the strict-ness enforced by the previous approach.</p>

<h2>
<a id="user-content-less-invasive-and-more-flexible" class="anchor" href="#less-invasive-and-more-flexible" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Less invasive and more flexible</h2>

<h3>
<a id="user-content-a-recap-of-the-older-api" class="anchor" href="#a-recap-of-the-older-api" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>A recap of the older API</h3>

<p>Since its inception all ServiceStack's services were based upon this simple interface:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">interface</span> <span class="pl-en">IService</span>&lt;TRequest&gt;
{
    <span class="pl-k">public</span> <span class="pl-k">object</span> <span class="pl-en">Execute</span>(<span class="pl-k">object</span> <span class="pl-smi">request</span>);
}</pre></div>

<p>Where <code>Execute()</code> is called regardless of which Verb or Endpoint the request was received on.
As REST services require different implementations for each HTTP Verb, we introduced a new <code>IRestService&lt;T&gt;</code> interface and base class which is used to provide different implementations for selected HTTP Methods:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">RestServiceBase</span>&lt;T&gt;
{
    <span class="pl-k">object</span> <span class="pl-en">OnGet</span>(<span class="pl-k">T</span> <span class="pl-smi">request</span>) { .. }
    <span class="pl-k">object</span> <span class="pl-en">OnPost</span>(<span class="pl-k">T</span> <span class="pl-smi">request</span>) { .. }
    <span class="pl-k">object</span> <span class="pl-en">OnPut</span>(<span class="pl-k">T</span> <span class="pl-smi">request</span>) { .. }
    <span class="pl-k">object</span> <span class="pl-en">OnDelete</span>(<span class="pl-k">T</span> <span class="pl-smi">request</span>) { .. }
    <span class="pl-k">object</span> <span class="pl-en">OnPatch</span>(<span class="pl-k">T</span> <span class="pl-smi">request</span>) { .. }
}</pre></div>

<p>Service event hooks and built-in error handling routines were also contained on the <code>ServiceBase</code> and <code>RestServiceBase</code> base classes which you would need to subclass in order to override the built-in functionality.</p>

<h2>
<a id="user-content-introducing-the-new-api" class="anchor" href="#introducing-the-new-api" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Introducing the New API</h2>

<p>We'll walk through a few examples here but for a more detailed look into the usages and capabilities of the new API design checkout its
<a href="https://github.com/ServiceStack/ServiceStack/blob/master/tests/RazorRockstars.Console.Files/ReqStarsService.cs">Comprehensive Test Suite</a></p>

<p>The new API design simplifies the existing <code>IService&lt;T&gt;</code> and <code>IRestService&lt;T&gt;</code> with this single unified interface:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">interface</span> <span class="pl-en">IService</span> {}</pre></div>

<p>That is now able to handle both RPC Service and Rest Service requests in a single class.
The interface is just used as a Marker interface that ServiceStack uses to find, register and auto-wire your existing services.
A convenience concrete <code>Service</code> class is also included which contains easy access to ServiceStack's providers:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Service</span> : <span class="pl-k">IService</span> {
    T TryResolve&lt;T&gt;();                        <span class="pl-c">//Resolve dependency at runtime</span>
    T ResolveService&lt;T&gt;();                    <span class="pl-c">//Resolve an auto-wired service to delegate to</span>
    IRequest <span class="pl-en">Request</span> { <span class="pl-k">get</span>; }                 <span class="pl-c">//HTTP Request Wrapper</span>
    IResponse <span class="pl-en">Response</span> { <span class="pl-k">get</span>; }               <span class="pl-c">//HTTP Response Wrapper</span>
    ICacheClient <span class="pl-en">Cache</span> { <span class="pl-k">get</span>; }               <span class="pl-c">//Registered Caching Provider</span>
    IDbConnection <span class="pl-en">Db</span> { <span class="pl-k">get</span>; }                 <span class="pl-c">//Registered ADO.NET IDbConnection (if any)</span>
    ISession <span class="pl-en">SessionBag</span> { <span class="pl-k">get</span>; }              <span class="pl-c">//Dynamic Session Bag</span>
    TUserSession SessionAs&lt;TUserSession&gt;();   <span class="pl-c">//Typed UserSession</span>
    <span class="pl-k">void</span> <span class="pl-en">Dispose</span>();                           <span class="pl-c">//Override to dispose of any un-managed dependencies</span>
}</pre></div>

<h3>
<a id="user-content-basic-example---handling-any-http-verb" class="anchor" href="#basic-example---handling-any-http-verb" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Basic example - Handling Any HTTP Verb</h3>

<p>From here an equivalent example to the first <code>ServiceBase.Execute(TRequest)</code> shown at the start is:</p>

<div class="highlight highlight-source-cs"><pre>[Route(<span class="pl-s"><span class="pl-pds">"</span>/reqstars<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">AllReqstars</span> : <span class="pl-k">IReturn</span>&lt;<span class="pl-k">List</span>&lt;<span class="pl-k">Reqstar</span>&gt;&gt; { }

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">ReqstarsService</span> : <span class="pl-k">Service</span>
{
    <span class="pl-k">public</span> List&lt;Reqstar&gt; <span class="pl-en">Any</span>(<span class="pl-k">AllReqstars</span> <span class="pl-smi">request</span>) 
    {
        <span class="pl-k">return</span> Db.Select&lt;Reqstar&gt;();
    }
}</pre></div>

<p>The new API maps HTTP Requests to your Services <strong>Actions</strong>. An Action is any method that:</p>

<ul>
<li>Is public </li>
<li>Only contains a single argument - the typed Request DTO</li>
<li>Has a Method name matching a HTTP Method or <strong>Any</strong> which is used as a fallback if it exists</li>
</ul>

<p>The above example will handle any <code>AllReqstars</code> request made on any <strong>HTTP Verb</strong> or <strong>endpoint</strong> and will return the complete <code>List&lt;Reqstar&gt;</code> contained in your configured RDBMS. </p>

<h3>
<a id="user-content-micro-orms-and-adonets-idbconnection" class="anchor" href="#micro-orms-and-adonets-idbconnection" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Micro ORMs and ADO.NET's IDbConnection</h3>

<p>Code-First Micro ORMS like <a href="https://github.com/ServiceStack/ServiceStack.OrmLite">OrmLite</a> and 
<a href="http://code.google.com/p/dapper-dot-net/">Dapper</a> provides a pleasant high-level experience whilst working directly against ADO.NET's low-level <code>IDbConnection</code>. They both support all major databases so you immediately have access to a flexible RDBMS option out-of-the-box. At the same time you're not limited to using the providers contained in the <code>Service</code> class and can continue to use your own register IOC dependencies (inc. an alternate IOC itself). </p>

<h3>
<a id="user-content-micro-orm-pocos-make-good-dtos" class="anchor" href="#micro-orm-pocos-make-good-dtos" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Micro ORM POCOs make good DTOs</h3>

<p>The POCOs used in Micro ORMS are particularly well suited for re-using as DTOs since they don't contain any circular references that the Heavy ORMs have (e.g. EF). OrmLite goes 1-step further and borrows pages from NoSQL's playbook where any complex property e.g. <code>List&lt;MyPoco&gt;</code> is transparently blobbed in a schema-less text field, promoting the design of frictionless <strong>Pure POCOS</strong> that are uninhibited by RDBMS concerns. In many cases these POCO data models already make good DTOs and can be returned directly instead of mapping to domain-specific DTOs.</p>

<h3>
<a id="user-content-calling-services-from-a-typed-c-client" class="anchor" href="#calling-services-from-a-typed-c-client" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Calling Services from a Typed C# Client</h3>

<p>In Service development your services DTOs provides your technology agnostic <strong>Service Layer</strong> which you want to keep clean and as 'dependency-free' as possible for maximum accessibility and potential re-use. Our recommendation is to keep your service DTOs in a separate largely dep-free assembly. We intend to improve this story further with a commercial VS.NET extension to enable 'Add ServiceStack Reference' like behaviour providing a familiar productive development experience for existing VS.NET SOAP WebService developers.</p>

<p>One of ServiceStack's strengths is its ability to re-use your Server DTOs on the client enabling ServiceStack's productive end-to-end typed API. The exact DTOs aren't needed, only the shape of the DTOs is important, ServiceStack's message-based design means you can even use partial DTOs on the client containing just the fields they're interested in. </p>

<p>But lets say you take the normal route of copying the DTOs (in either source of binary form) so you have something like this on the client:</p>

<div class="highlight highlight-source-cs"><pre>[Route(<span class="pl-s"><span class="pl-pds">"</span>/reqstars<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">AllReqstars</span> : <span class="pl-k">IReturn</span>&lt;<span class="pl-k">List</span>&lt;<span class="pl-k">Reqstar</span>&gt;&gt; { }</pre></div>

<p>The code on the client now just becomes:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> client = <span class="pl-k">new</span> JsonServiceClient(BaseUri);
List&lt;Reqstar&gt; response = client.Get(<span class="pl-k">new</span> AllReqstars());</pre></div>

<p>Which makes a <strong>GET</strong> web request to the <code>/reqstars</code> route.
When a custom route is not present on the client it automatically falls back to using ServiceStack's <a href="http://www.servicestack.net/ServiceStack.Hello/#predefinedroutes">pre-defined routes</a>.</p>

<p>Finally you can also use the previous more explicit client API (ideal for when you don't have the <code>IReturn&lt;&gt;</code> marker):</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> response = client.Get&lt;List&lt;Reqstar&gt;&gt;(<span class="pl-s"><span class="pl-pds">"</span>/reqstars<span class="pl-pds">"</span></span>);</pre></div>

<p>All these APIs <strong>have async equivalents</strong> which you can use instead, when you need to.</p>

<h2>
<a id="user-content-everything-just-works" class="anchor" href="#everything-just-works" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Everything Just Works</h2>

<p>The immediate benefit we were able to realise from designing the new API within ServiceStack's existing semantics was that everything else just works. You're able to re-use the same Routes, Filters, Views and Validators together and it will continue to work just as it did before. </p>

<p>E.g. you can take advantage of <a href="http://razor.servicestack.net/">ServiceStack's recent Razor support</a> and create a web page for this service by just adding a <a href="https://github.com/ServiceStack/ServiceStack/blob/master/tests/RazorRockstars.Console.Files/Views/AllReqstars.cshtml">AllReqstars.cshtml</a> in your views folder. Thanks to the built-in Content Negotiation you can fetch the HTML contents calling the same url: </p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> html = <span class="pl-s"><span class="pl-pds">"</span>{0}/reqstars<span class="pl-pds">"</span></span>.Fmt(BaseUri).GetStringFromUrl(acceptContentType:<span class="pl-s"><span class="pl-pds">"</span>text/html<span class="pl-pds">"</span></span>);</pre></div>

<p>This <a href="http://razor.servicestack.net/#unified-stack">feature is particularly nice</a> as it lets you <strong>re-use your existing services</strong> to serve both Web and Native Mobile and Desktop clients.</p>

<h3>
<a id="user-content-action-filters" class="anchor" href="#action-filters" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Action Filters</h3>

<p>Service actions can also contain fine-grained application of Request and Response filters, e.g:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">ReqstarsService</span> : <span class="pl-k">Service</span>
{
    [ClientCanSwapTemplates]
    <span class="pl-k">public</span> List&lt;Reqstar&gt; <span class="pl-en">Any</span>(<span class="pl-k">AllReqstars</span> <span class="pl-smi">request</span>) 
    {
        <span class="pl-k">return</span> Db.Select&lt;Reqstar&gt;();
    }
}</pre></div>

<p>This Request Filter allows the client to <a href="http://razor.servicestack.net/#unified-stack">change the selected Razor <strong>View</strong> and <strong>Template</strong></a> used at runtime. By default the view with the same name as the <strong>Request</strong> or <strong>Response</strong> DTO is used.</p>

<h2>
<a id="user-content-handling-different-http-verbs" class="anchor" href="#handling-different-http-verbs" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Handling different HTTP Verbs</h2>

<p>The new API design now lets you handle any HTTP Verb. This lets you respond with CORS headers to a HTTP <strong>OPTIONS</strong> request with just:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">ReqstarsService</span> : <span class="pl-k">Service</span>
{
    [EnableCors]
    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Options</span>(<span class="pl-k">Reqstar</span> <span class="pl-smi">request</span>) {}
}</pre></div>

<p>Which if you now make an OPTIONS request to the above service, will emit the default <code>[EnableCors]</code> headers:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> webReq = (HttpWebRequest)WebRequest.Create(Host + <span class="pl-s"><span class="pl-pds">"</span>/reqstars<span class="pl-pds">"</span></span>);
webReq.Method = <span class="pl-s"><span class="pl-pds">"</span>OPTIONS<span class="pl-pds">"</span></span>;
<span class="pl-k">using</span> (var webRes = webReq.GetResponse())
{
    webRes.Headers[<span class="pl-s"><span class="pl-pds">"</span>Access-Control-Allow-Origin<span class="pl-pds">"</span></span>]     <span class="pl-c">// *</span>
    webRes.Headers[<span class="pl-s"><span class="pl-pds">"</span>Access-Control-Allow-Methods<span class="pl-pds">"</span></span>]    <span class="pl-c">// GET, POST, PUT, DELETE, OPTIONS</span>
    webRes.Headers[<span class="pl-s"><span class="pl-pds">"</span>Access-Control-Allow-Headers<span class="pl-pds">"</span></span>]    <span class="pl-c">// Content-Type</span>
}</pre></div>

<h3>
<a id="user-content-patch-request-example" class="anchor" href="#patch-request-example" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>PATCH request example</h3>

<p>Handling a PATCH request is just as easy, e.g. here's an example of using PATCH to handle a partial update of a Resource:</p>

<div class="highlight highlight-source-cs"><pre>[Route(<span class="pl-s"><span class="pl-pds">"</span>/reqstars/{Id}<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>PATCH<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">UpdateReqstar</span> : <span class="pl-k">IReturn</span>&lt;<span class="pl-k">Reqstar</span>&gt;
{
    <span class="pl-k">public</span> <span class="pl-k">int</span> <span class="pl-en">Id</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-k">int</span> <span class="pl-en">Age</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}

<span class="pl-k">public</span> Reqstar Patch(UpdateReqstar request)
{
    Db.Update&lt;Reqstar&gt;(request, x =&gt; x.Id == request.Id);
    <span class="pl-k">return</span> Db.Id&lt;Reqstar&gt;(request.Id);
}</pre></div>

<p>And the client call is just as easy as you would expect:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> response = client.Patch(<span class="pl-k">new</span> UpdateReqstar { Id = <span class="pl-c1">1</span>, Age = <span class="pl-c1">18</span> });</pre></div>

<p>Although sending different HTTP Verbs are unrestricted in native clients, they're unfortunately not allowed in some web browsers and proxies. So to simulate a PATCH from an AJAX request you need to set the <strong>X-Http-Method-Override</strong> HTTP Header.</p>

<h2>
<a id="user-content-structured-error-handling" class="anchor" href="#structured-error-handling" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Structured Error Handling</h2>

<p>In the previous API we had a restriction that if you wanted structured exceptions on the client you need to have a Response DTO with the same name as your Request DTO but with a 'Response' suffix. This restriction has now been lifted and we will now just use a generic <code>ErrorResponse</code> when a Response DTO can't be found. This is a transparent technical detail you don't need to know about.</p>

<p>So Error Handling is effectively the same as it was before, but now can work without needing a Response DTO, e.g:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> List&lt;Reqstar&gt; Post(Reqstar request)
{
    <span class="pl-k">if</span> (!request.Age.HasValue)
        <span class="pl-k">throw</span> <span class="pl-k">new</span> ArgumentException(<span class="pl-s"><span class="pl-pds">"</span>Age is required<span class="pl-pds">"</span></span>);

    Db.Insert(request.TranslateTo&lt;Reqstar&gt;());
    <span class="pl-k">return</span> Db.Select&lt;Reqstar&gt;();
}</pre></div>

<p>Which will throw this Error if the client tried to create an empty Reqstar:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">try</span>
{
    <span class="pl-k">var</span> response = client.Post(<span class="pl-k">new</span> Reqstar());
}
<span class="pl-k">catch</span> (WebServiceException webEx)
{
    webEx.StatusCode                    <span class="pl-c">// 400</span>
    webEx.StatusDescription             <span class="pl-c">// ArgumentException</span>
    webEx.ResponseStatus.ErrorCode      <span class="pl-c">// ArgumentException</span>
    webEx.ResponseStatus.Message        <span class="pl-c">// Age is required</span>
    webEx.ResponseDto <span class="pl-k">is</span> ErrorResponse  <span class="pl-c">// true</span>
}</pre></div>

<p>When your Service does have a conventionally named Response DTO, thrown exceptions will continue to be injected into an instance of that as seen in the <a href="https://github.com/ServiceStack/ServiceStack/blob/master/tests/RazorRockstars.Console.Files/ReqStarsService.cs#L310">invalid SearchReqstars request example</a>.</p>

<p>You can use the Service Clients Exception handling for handling any HTTP error generated in or outside of your service, e.g. here's how to detect if a HTTP Method isn't implemented or disallowed:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">try</span>
{
    <span class="pl-k">var</span> response = client.Send(<span class="pl-k">new</span> SearchReqstars());
}
<span class="pl-k">catch</span> (WebServiceException webEx)
{
    webEx.StatusCode                   <span class="pl-c">// 405</span>
    webEx.StatusDescription            <span class="pl-c">// Method Not Allowed</span>
}</pre></div>

<p>In addition to standard C# exceptions your services can also return multiple, rich and detailed validation errors as enforced by <a href="https://github.com/ServiceStack/ServiceStack/wiki/Validation">Fluent Validation's validators</a>.</p>

<h3>
<a id="user-content-overriding-the-default-exception-handling" class="anchor" href="#overriding-the-default-exception-handling" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Overriding the default Exception handling</h3>

<p>Overriding the default exception handling in ServiceStack just got a lot easier as well, you now no longer need to provide your own base class to do this and can easily just override it in your AppHost with:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">void</span> Configure(Container container) 
{
    <span class="pl-c1">this</span>.ServiceExceptionHandlers.Add((req, reqDto, ex) =&gt; {
        <span class="pl-k">return</span> ...;
    });
}</pre></div>

<h2>
<a id="user-content-smart-routing" class="anchor" href="#smart-routing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Smart Routing</h2>

<p>For the most part you won't need to know about this as ServiceStack's routing works as you would expect. Although this should still serve as a good reference to describe the resolution order of ServiceStack's Routes:</p>

<ol>
<li>Any exact Literal Matches are used first</li>
<li>Exact Verb match is preferred over All Verbs</li>
<li>The more variables in your route the less weighting it has</li>
<li>When Routes have the same weight, the order is determined by the position of the Action in the service or Order of Registration (FIFO)</li>
</ol>

<p>These Rules only come into play when there are multiple routes that matches the pathInfo of an incoming request.</p>

<p>Lets see some examples of these rules in action using the routes defined in the <a href="https://github.com/ServiceStack/ServiceStack/blob/master/tests/RazorRockstars.Console.Files/ReqStarsService.cs">new API Design test suite</a>:</p>

<div class="highlight highlight-source-cs"><pre>[Route(<span class="pl-s"><span class="pl-pds">"</span>/reqstars<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Reqstar</span> {}

[Route(<span class="pl-s"><span class="pl-pds">"</span>/reqstars<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>GET<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">AllReqstars</span> {}

[Route(<span class="pl-s"><span class="pl-pds">"</span>/reqstars/{Id}<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>GET<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">GetReqstar</span> {}

[Route(<span class="pl-s"><span class="pl-pds">"</span>/reqstars/{Id}/{Field}<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">ViewReqstar</span> {}

[Route(<span class="pl-s"><span class="pl-pds">"</span>/reqstars/{Id}/delete<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">DeleteReqstar</span> {}

[Route(<span class="pl-s"><span class="pl-pds">"</span>/reqstars/{Id}<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>PATCH<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">UpdateReqstar</span> {}

[Route(<span class="pl-s"><span class="pl-pds">"</span>/reqstars/reset<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">ResetReqstar</span> {}

[Route(<span class="pl-s"><span class="pl-pds">"</span>/reqstars/search<span class="pl-pds">"</span></span>)]
[Route(<span class="pl-s"><span class="pl-pds">"</span>/reqstars/aged/{Age}<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">SearchReqstars</span> {}</pre></div>

<p>These are results for these HTTP Requests</p>

<pre><code>GET   /reqstars           =&gt;    AllReqstars
POST  /reqstars           =&gt;    Reqstar
GET   /reqstars/search    =&gt;    SearchReqstars
GET   /reqstars/reset     =&gt;    ResetReqstar
PATCH /reqstars/reset     =&gt;    ResetReqstar
PATCH /reqstars/1         =&gt;    UpdateReqstar
GET   /reqstars/1         =&gt;    GetReqstar
GET   /reqstars/1/delete  =&gt;    DeleteReqstar
GET   /reqstars/1/foo     =&gt;    ViewReqstar
</code></pre>

<p>And if there were multiple of the exact same routes declared like:</p>

<div class="highlight highlight-source-cs"><pre>[Route(<span class="pl-s"><span class="pl-pds">"</span>/req/{Id}<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>GET<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Req2</span> {}

[Route(<span class="pl-s"><span class="pl-pds">"</span>/req/{Id}<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>GET<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Req1</span> {}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">MyService</span> : <span class="pl-k">Service</span> {
    <span class="pl-k">public</span> <span class="pl-k">object</span> <span class="pl-en">Get</span>(<span class="pl-k">Req1</span> <span class="pl-smi">request</span>) { ... }     
    <span class="pl-k">public</span> <span class="pl-k">object</span> <span class="pl-en">Get</span>(<span class="pl-k">Req2</span> <span class="pl-smi">request</span>) { ... }     
}</pre></div>

<p>The Route on the Action that was declared first gets selected, i.e:</p>

<pre><code>GET /req/1              =&gt; Req1
</code></pre>

<h2>
<a id="user-content-advanced-usages" class="anchor" href="#advanced-usages" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Advanced Usages</h2>

<h3>
<a id="user-content-custom-hooks" class="anchor" href="#custom-hooks" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Custom Hooks</h3>

<p>The ability to extend ServiceStack's service execution pipeline with Custom Hooks is an advanced customisation feature that for most times is not needed as the preferred way to add composable functionality to your services is to use <a href="https://github.com/ServiceStack/ServiceStack/wiki/Filter-attributes">Request / Response Filter attributes</a> or apply them globally with <a href="https://github.com/ServiceStack/ServiceStack/wiki/Request-and-response-filters">Global Request/Response Filters</a>.</p>

<p>Although this is another area we've improved on as you can now add your own custom hooks without needing to subclass any services. To do this we've introduced the concept of a <a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack.Interfaces/ServiceHost/IServiceRunner.cs">IServiceRunner</a> that decouples the execution of your service from the implementation of it.</p>

<p>To add your own Service Hooks you just need to override the default Service Runner in your AppHost from its default implementation:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">virtual</span> IServiceRunner&lt;TRequest&gt; CreateServiceRunner&lt;TRequest&gt;(ActionContext actionContext)
{           
    <span class="pl-k">return</span> <span class="pl-k">new</span> ServiceRunner&lt;TRequest&gt;(<span class="pl-c1">this</span>, actionContext); <span class="pl-c">//Cached per Service Action</span>
}</pre></div>

<p>With your own:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">override</span> IServiceRunner&lt;TRequest&gt; CreateServiceRunner&lt;TRequest&gt;(ActionContext actionContext)
{           
    <span class="pl-k">return</span> <span class="pl-k">new</span> MyServiceRunner&lt;TRequest&gt;(<span class="pl-c1">this</span>, actionContext); <span class="pl-c">//Cached per Service Action</span>
}</pre></div>

<p>Where <code>MyServiceRunner&lt;T&gt;</code> is just a custom class implementing the custom hooks you're interested in, e.g:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">MyServiceRunner</span>&lt;T&gt; : <span class="pl-k">ServiceRunner</span>&lt;<span class="pl-k">T</span>&gt; {
    <span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-k">void</span> <span class="pl-en">OnBeforeExecute</span>(<span class="pl-k">IRequestContext</span> <span class="pl-smi">requestContext</span>, <span class="pl-k">TRequest</span> <span class="pl-smi">request</span>) {
      <span class="pl-c">// Called just before any Action is executed</span>
    }

    <span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-k">object</span> <span class="pl-en">OnAfterExecute</span>(<span class="pl-k">IRequestContext</span> <span class="pl-smi">requestContext</span>, <span class="pl-k">object</span> <span class="pl-smi">response</span>) {
      <span class="pl-c">// Called just after any Action is executed, you can modify the response returned here as well</span>
    }

    <span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-k">object</span> <span class="pl-en">HandleException</span>(<span class="pl-k">IRequestContext</span> <span class="pl-smi">requestContext</span>, <span class="pl-k">TRequest</span> <span class="pl-smi">request</span>, <span class="pl-k">Exception</span> <span class="pl-smi">ex</span>) {
      <span class="pl-c">// Called whenever an exception is thrown in your Services Action</span>
    }
}</pre></div>

<h2>
<a id="user-content-limitations" class="anchor" href="#limitations" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Limitations</h2>

<p>This should probably be spelled out (even though wasn't possible with the previous API) but as the new API imposes less restriction we'll note it here: You're still not able to split the handling of a single Resource (i.e. Request DTO) over multiple service implementations. If you find you need to do this because your service is getting too big, consider using partial classes to spread the implementation over multiple files. Another option is encapsulating some of the re-usable functionality into Logic dependencies and inject them into your service.</p>

<h2>
<a id="user-content-other-notes" class="anchor" href="#other-notes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Other Notes</h2>

<p>Although they're not needed or used anywhere <a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack.Interfaces/ServiceHost/IService.cs#L18">we've introduced new HTTP service interfaces</a> that enforce the correct signature required by the services, e.g:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">MyService</span> : <span class="pl-k">Service</span>, <span class="pl-k">IAny</span>&lt;<span class="pl-k">AllReqstars</span>&gt;, <span class="pl-k">IGet</span>&lt;<span class="pl-k">SearchReqstars</span>&gt;, <span class="pl-k">IPost</span>&lt;<span class="pl-k">Reqstar</span>&gt;
{
    <span class="pl-k">public</span> <span class="pl-k">object</span> <span class="pl-en">Any</span>(<span class="pl-k">AllReqstars</span> <span class="pl-smi">request</span>) { .. }
    <span class="pl-k">public</span> <span class="pl-k">object</span> <span class="pl-en">Get</span>(<span class="pl-k">SearchReqstars</span> <span class="pl-smi">request</span>) { .. }
    <span class="pl-k">public</span> <span class="pl-k">object</span> <span class="pl-en">Post</span>(<span class="pl-k">Reqstar</span> <span class="pl-smi">request</span>) { .. }
}</pre></div>

<p>This has no effect to the runtime behaviour and your services will work the same way with or without the added interfaces.</p>

<h2>
<a id="user-content-refactoring-existing-services-to-use-the-new-api-design" class="anchor" href="#refactoring-existing-services-to-use-the-new-api-design" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Refactoring existing services to use the new API Design</h2>

<p>For the most part it should be fairly straight forward to port an existing service to the new API. To ease the process I'll walk through the changes we made to our most recent <a href="http://razor.servicestack.net">razor.servicestack.net</a> demo. The goal of this port is to retain exactly the same API and behaviour so all existing urls continue to work just as they did before. </p>

<p>The service that runs at the heart of the Razor Rockstars demo is the <a href="http://razor.servicestack.net/rockstars">/rockstars</a> uber-service which originally with old API that looked like:</p>

<div class="highlight highlight-source-cs"><pre>[Route(<span class="pl-s"><span class="pl-pds">"</span>/rockstars<span class="pl-pds">"</span></span>)]
[Route(<span class="pl-s"><span class="pl-pds">"</span>/rockstars/aged/{Age}<span class="pl-pds">"</span></span>)]
[Route(<span class="pl-s"><span class="pl-pds">"</span>/rockstars/delete/{Delete}<span class="pl-pds">"</span></span>)]
[Route(<span class="pl-s"><span class="pl-pds">"</span>/rockstars/{Id}<span class="pl-pds">"</span></span>)]                      <span class="pl-c">//All Routes on the single DTO</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Rockstars</span>                          <span class="pl-c">//All Fields merged into a single DTO</span>
{
    <span class="pl-k">public</span> <span class="pl-k">int</span> <span class="pl-en">Id</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">FirstName</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">LastName</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-k">int</span>? <span class="pl-en">Age</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-k">bool</span> <span class="pl-en">Alive</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">Delete</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}

[Csv(CsvBehavior.FirstEnumerable)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">RockstarsResponse</span>
{
    <span class="pl-k">public</span> <span class="pl-k">int</span> <span class="pl-en">Total</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-k">int</span>? <span class="pl-en">Aged</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> List&lt;Rockstar&gt; <span class="pl-en">Results</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}

[ClientCanSwapTemplates]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">RockstarsService</span> : <span class="pl-k">RestServiceBase</span>&lt;<span class="pl-k">Rockstars</span>&gt;
{
    <span class="pl-c">//Base class didn't include a IDbConnectionFactory</span>
    <span class="pl-k">public</span> IDbConnectionFactory <span class="pl-en">DbFactory</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }       

    <span class="pl-c">//Single implementation handling all GET requests</span>
    <span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-k">object</span> <span class="pl-en">OnGet</span>(<span class="pl-k">Rockstars</span> <span class="pl-smi">request</span>)           
    {
        <span class="pl-k">using</span> (<span class="pl-k">var</span> db = DbFactory.Open())
        {
            <span class="pl-k">if</span> (request.Delete == <span class="pl-s"><span class="pl-pds">"</span>reset<span class="pl-pds">"</span></span>)
            {
                db.DeleteAll&lt;Rockstar&gt;();
                db.InsertAll(Rockstar.SeedData);
            }
            <span class="pl-k">else</span> <span class="pl-k">if</span> (request.Delete.IsInt())
            {
                db.DeleteById&lt;Rockstar&gt;(request.Delete.ToInt());
            }

            <span class="pl-k">return</span> <span class="pl-k">new</span> RockstarsResponse {
                Aged = request.Age,
                Total = db.Scalar&lt;<span class="pl-k">int</span>&gt;(<span class="pl-s"><span class="pl-pds">"</span>select count(*) from Rockstar<span class="pl-pds">"</span></span>),
                Results = request.Id != <span class="pl-k">default</span>(<span class="pl-k">int</span>) ?
                    db.Select&lt;Rockstar&gt;(q =&gt; q.Id == request.Id)
                      : request.Age.HasValue ?
                    db.Select&lt;Rockstar&gt;(q =&gt; q.Age == request.Age.Value)
                      : db.Select&lt;Rockstar&gt;()
            };
        }
    }

    <span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-k">object</span> <span class="pl-en">OnPost</span>(<span class="pl-k">Rockstars</span> <span class="pl-smi">request</span>)
    {
        <span class="pl-k">using</span> (<span class="pl-k">var</span> db = DbFactory.Open())
        {
            db.Insert(request.TranslateTo&lt;Rockstar&gt;());
            <span class="pl-k">return</span> OnGet(<span class="pl-k">new</span> Rockstars());
        }
    }
}</pre></div>

<p>I've added comments to all the attributes where the implementations differ with the new service.
The biggest change is seen with the flexibility of the new API where it now allows a single service to handle multiple Request DTOs and lets you provide different implementations for each. This allows us to split existing operations in more cohesive parts and instead of a single merged Request DTO, we have more fine-grained DTOs with just the fields required for each operation:</p>

<div class="highlight highlight-source-cs"><pre>[Route(<span class="pl-s"><span class="pl-pds">"</span>/rockstars<span class="pl-pds">"</span></span>)]
[Route(<span class="pl-s"><span class="pl-pds">"</span>/rockstars/aged/{Age}<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Rockstars</span>               <span class="pl-c">//Include only fields used in the GET/Search action</span>
{
    <span class="pl-k">public</span> <span class="pl-k">int</span>? <span class="pl-en">Age</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-k">int</span> <span class="pl-en">Id</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}

[Route(<span class="pl-s"><span class="pl-pds">"</span>/rockstars/delete/{Id}<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">DeleteRockstar</span>         <span class="pl-c">//Specific Action to delete a Rockstar. Only Id field needed</span>
{
    <span class="pl-k">public</span> <span class="pl-k">int</span> <span class="pl-en">Id</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}

[Route(<span class="pl-s"><span class="pl-pds">"</span>/rockstars/delete/reset<span class="pl-pds">"</span></span>)]  <span class="pl-c">//The route for this can now be /rockstars/reset</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">ResetRockstars</span> { }     <span class="pl-c">//No fields required for this Action</span>

[Csv(CsvBehavior.FirstEnumerable)]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">RockstarsResponse</span>
{
    <span class="pl-k">public</span> <span class="pl-k">int</span> <span class="pl-en">Total</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-k">int</span>? <span class="pl-en">Aged</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> List&lt;Rockstar&gt; <span class="pl-en">Results</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}

[ClientCanSwapTemplates]
[DefaultView(<span class="pl-s"><span class="pl-pds">"</span>Rockstars<span class="pl-pds">"</span></span>)]                <span class="pl-c">//Default View for each Action</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">RockstarsService</span> : <span class="pl-k">Service</span>
{
    <span class="pl-k">public</span> <span class="pl-k">object</span> <span class="pl-en">Get</span>(<span class="pl-k">Rockstars</span> <span class="pl-smi">request</span>)  //Only concerned with GET/Search actions
    {
        <span class="pl-k">return</span> <span class="pl-k">new</span> RockstarsResponse {
            Aged = request.Age,
            Total = Db.Scalar&lt;<span class="pl-k">int</span>&gt;(<span class="pl-s"><span class="pl-pds">"</span>select count(*) from Rockstar<span class="pl-pds">"</span></span>),
            Results = request.Id != <span class="pl-k">default</span>(<span class="pl-k">int</span>) 
                ? Db.Select&lt;Rockstar&gt;(q =&gt; q.Id == request.Id)
                : request.Age.HasValue 
                    ? Db.Select&lt;Rockstar&gt;(q =&gt; q.Age == request.Age.Value)
                    : Db.Select&lt;Rockstar&gt;()
        };
    }

    <span class="pl-k">public</span> <span class="pl-k">object</span> <span class="pl-en">Any</span>(<span class="pl-k">DeleteRockstar</span> <span class="pl-smi">request</span>) //Handles any HTTP Verb
    {
        Db.DeleteById&lt;Rockstar&gt;(request.Id);
        <span class="pl-k">return</span> Get(<span class="pl-k">new</span> Rockstars());
    }

    <span class="pl-k">public</span> <span class="pl-k">object</span> <span class="pl-en">Post</span>(<span class="pl-k">Rockstar</span> <span class="pl-smi">request</span>)
    {
        Db.Insert(request);
        <span class="pl-k">return</span> Get(<span class="pl-k">new</span> Rockstars());
    }

    <span class="pl-k">public</span> <span class="pl-k">object</span> <span class="pl-en">Any</span>(<span class="pl-k">ResetRockstars</span> <span class="pl-smi">request</span>) //Handles any HTTP Verb
    {
        Db.DeleteAll&lt;Rockstar&gt;();
        Db.InsertAll(AppHost.SeedData);
        <span class="pl-k">return</span> Get(<span class="pl-k">new</span> Rockstars());
    }
}</pre></div>

<p>The major omission that's no longer required in the Port is the using statement around DB access since it's now available by default in the <code>Service</code> base class. If you have your own dependencies that a lot of your services use, it's a good idea to include them in your own custom base class as it reduces the amount of boilerplate needed.</p>

<p>The new introduction in this port is the <code>[DefaultView("Rockstars")]</code> Request Filter Attribute. This is required because we want the <strong>text/html</strong> format to use the <strong>Rockstars.cshtml</strong> Razor view to render the HTML page. In the old version when we only had 1 Request DTO named <strong>Rockstars</strong> this was able to inferred by the Razor View Engine. This is no longer the case now that we have multiple actions with different Request DTO's. Although if the Razor View was instead called <strong>RockstarsResponse.cshtml</strong> we wouldn't have needed the attribute since in all cases a populated <strong>RockstarsResponse</strong> DTO is returned. As we want this to be an exact port, rather than changing the name of the View we decided to specify the default view to be used in each action instead.</p>

<h4>
<a id="user-content-filter-attributes-can-be-applied-to-actions-as-well" class="anchor" href="#filter-attributes-can-be-applied-to-actions-as-well" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Filter Attributes can be Applied to Actions as well</h4>

<p>Other interesting points in this port is now that the new API allows Action Filter attributes we could've instead placed the Attribute on each action, instead of on the service where it applies to all Actions. Also it's worth pointing out that the <code>[DefaultView]</code> is a Request Filter Attribute so is executed before the Action therefore doesn't clobber the values set by <code>[ClientCanSwapTemplates]</code> since it's a Response Filter which is executed after the Action.</p>

<h3>
<a id="user-content-other-new-api-examples" class="anchor" href="#other-new-api-examples" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Other New API examples</h3>

<p>Examples of more converted services are in the New API [[Release Notes]].</p>
