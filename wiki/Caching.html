<h1>
<a id="user-content-caching" class="anchor" href="#caching" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Caching</h1>

<p>As caching is an essential technology in the development of high-performance web services, Service Stack has a number of different caching options available that each share the same
<a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack.Interfaces/Caching/ICacheClient.cs">common client interface (ICacheClient)</a>
for the following cache providers:</p>

<ul>
<li>
<a href="https://github.com/ServiceStack/ServiceStack.Redis">Redis</a> - A very fast key-value store that has  non-volatile persistent storage and support for rich data structures such as lists and sets.</li>
<li>
<a href="https://www.nuget.org/packages/ServiceStack.Server">OrmLiteCacheClient</a> - Supports all <a href="https://github.com/ServiceStack/ServiceStack.OrmLite/#download">OrmLite's RDBMS providers</a> for using an existing RDBMS as a distributed cache.</li>
<li>
<a href="https://nuget.org/packages/ServiceStack.Caching.Memcached">Memcached</a> - The tried and tested most widely used cache provider.</li>
<li>
<a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack/Caching/MemoryCacheClient.cs">In Memory Cache</a> - Useful for single host web services and enabling unit tests to run without needing access to a cache server.</li>
<li>
<a href="https://www.nuget.org/packages/ServiceStack.Aws/">Aws DynamoDB Cache Client</a> - For using with Amazon's Dynamo DB backend hosted on Amazon Web Services</li>
<li>
<a href="https://nuget.org/packages/ServiceStack.Caching.Azure">Azure Cache Client</a> - For using the Azure DataCache client when your application is hosted on Azure.</li>
</ul>

<p>To configure which cache should be used, the particular client has to be registered in the IoC container:</p>

<h4>
<a id="user-content-in-memory-cache" class="anchor" href="#in-memory-cache" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>In-memory cache:</h4>

<div class="highlight highlight-source-cs"><pre>container.Register&lt;ICacheClient&gt;(<span class="pl-k">new</span> MemoryCacheClient());</pre></div>

<h5>
<a id="user-content-nuget-package-servicestack" class="anchor" href="#nuget-package-servicestack" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>NuGet Package: <a href="http://www.nuget.org/packages/ServiceStack">ServiceStack</a>
</h5>

<h4>
<a id="user-content-redis" class="anchor" href="#redis" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Redis</h4>

<div class="highlight highlight-source-cs"><pre>container.Register&lt;IRedisClientsManager&gt;(c =&gt; 
    <span class="pl-k">new</span> PooledRedisClientManager(<span class="pl-s"><span class="pl-pds">"</span>localhost:6379<span class="pl-pds">"</span></span>));

container.Register(c =&gt; c.Resolve&lt;IRedisClientsManager&gt;().GetCacheClient());</pre></div>

<h5>
<a id="user-content-nuget-package-servicestackredis" class="anchor" href="#nuget-package-servicestackredis" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>NuGet Package: <a href="http://www.nuget.org/packages/ServiceStack.Redis">ServiceStack.Redis</a>
</h5>

<h4>
<a id="user-content-ormlite" class="anchor" href="#ormlite" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>OrmLite</h4>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">//Register OrmLite Db Factory if not already</span>
container.Register&lt;IDbConnectionFactory&gt;(c =&gt; 
    <span class="pl-k">new</span> OrmLiteConnectionFactory(connString, SqlServerDialect.Provider)); 

container.RegisterAs&lt;OrmLiteCacheClient, ICacheClient&gt;();

<span class="pl-c">//Create 'CacheEntry' RDBMS table if it doesn't exist already</span>
container.Resolve&lt;ICacheClient&gt;().InitSchema(); </pre></div>

<h5>
<a id="user-content-nuget-package-servicestackserver" class="anchor" href="#nuget-package-servicestackserver" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>NuGet Package: <a href="http://www.nuget.org/packages/ServiceStack.Server">ServiceStack.Server</a>
</h5>

<h4>
<a id="user-content-memcached" class="anchor" href="#memcached" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Memcached:</h4>

<div class="highlight highlight-source-cs"><pre>container.Register&lt;ICacheClient&gt;(
    <span class="pl-k">new</span> MemcachedClientCache(<span class="pl-k">new</span>[] { <span class="pl-s"><span class="pl-pds">"</span>127.0.0.0<span class="pl-pds">"</span></span> }); <span class="pl-c">//Add Memcached hosts</span></pre></div>

<h5>
<a id="user-content-nuget-package-servicestackcachingmemcached" class="anchor" href="#nuget-package-servicestackcachingmemcached" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>NuGet Package: <a href="http://www.nuget.org/packages/ServiceStack.Caching.Memcached">ServiceStack.Caching.Memcached</a>
</h5>

<h4>
<a id="user-content-aws-dynamodb" class="anchor" href="#aws-dynamodb" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>AWS DynamoDB:</h4>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> awsDb = <span class="pl-k">new</span> AmazonDynamoDBClient(AWS_ACCESS_KEY, AWS_SECRET_KEY, RegionEndpoint.USEast1);
<span class="pl-k">var</span> cache = <span class="pl-k">new</span> DynamoDbCacheClient(<span class="pl-k">new</span> PocoDynamo(awsDb));
cache.InitSchema();</pre></div>

<h5>
<a id="user-content-nuget-package-servicestackaws" class="anchor" href="#nuget-package-servicestackaws" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>NuGet Package: <a href="http://www.nuget.org/packages/ServiceStack.Aws">ServiceStack.Aws</a>
</h5>

<h4>
<a id="user-content-azure" class="anchor" href="#azure" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Azure:</h4>

<div class="highlight highlight-source-cs"><pre>container.Register&lt;ICacheClient&gt;(
    <span class="pl-k">new</span> AzureCacheClient(<span class="pl-s"><span class="pl-pds">"</span>MyAppCache<span class="pl-pds">"</span></span>)); <span class="pl-c">//Add your Azure CacheName if any</span></pre></div>

<h5>
<a id="user-content-nuget-package-servicestackcachingazure" class="anchor" href="#nuget-package-servicestackcachingazure" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>NuGet Package: <a href="http://www.nuget.org/packages/ServiceStack.Caching.Azure">ServiceStack.Caching.Azure</a>
</h5>

<h2>
<a id="user-content-cache-a-response-of-a-service" class="anchor" href="#cache-a-response-of-a-service" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Cache a response of a service</h2>

<p>To cache a response you simply have to call <code>ToOptimizedResultUsingCache</code> which is an extension method existing in <code>ServiceStack.ServiceHost</code>.</p>

<p>In your service:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">OrdersService</span> : <span class="pl-k">Service</span>
{
    <span class="pl-k">public</span> <span class="pl-k">object</span> <span class="pl-en">Get</span>(<span class="pl-k">CachedOrders</span> <span class="pl-smi">request</span>)
    {
        <span class="pl-k">var</span> cacheKey = <span class="pl-s"><span class="pl-pds">"</span>unique_key_for_this_request<span class="pl-pds">"</span></span>;
        <span class="pl-k">return</span> <span class="pl-c1">base</span>.Request.ToOptimizedResultUsingCache(<span class="pl-c1">base</span>.Cache,cacheKey,()=&gt; 
            {
                <span class="pl-c">//Delegate is executed if item doesn't exist in cache </span>
                <span class="pl-c">//Any response DTO returned here will be cached automatically</span>
            });
    }
}</pre></div>

<blockquote>
<p>Tip: There exists a class named <a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack.Common/UrnId.cs">UrnId</a> which provides helper methods to create unique keys for an object.</p>
</blockquote>

<p><code>ToOptimizedResultUsingCache</code> also has an overload which provides a parameter to set the timespan when the cache should be deleted (marked as expired). If now a client calls the same service method a second time and the cache expired, the provided delegate, which returns the response DTO, will be executed a second time.</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> cacheKey = <span class="pl-s"><span class="pl-pds">"</span>some_unique_key<span class="pl-pds">"</span></span>;
<span class="pl-c">//Cache should be deleted in 1h</span>
<span class="pl-k">var</span> expireInTimespan = <span class="pl-k">new</span> TimeSpan(<span class="pl-c1">1</span>, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>);
<span class="pl-k">return</span> <span class="pl-c1">base</span>.Request.ToOptimizedResultUsingCache(
    <span class="pl-c1">base</span>.Cache, cacheKey, expireInTimespan, ...)</pre></div>

<h2>
<a id="user-content-delete-cached-responses" class="anchor" href="#delete-cached-responses" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Delete cached responses</h2>

<p>If now for example an order gets updated and the order was cached before the update, the webservice will still return the same result, because the cache doesn't know that the order has been updated.</p>

<p>So there are two options:</p>

<ul>
<li>Use <strong>time based</strong> caching (and expire cache earlier)</li>
<li>Cache on <strong>validility</strong> </li>
</ul>

<blockquote>
<p>When the cache is based on <strong>validility</strong> the caches are invalidated manually (e.g. when a user modified his profile, &gt; clear his cache) which means you always get the latest version and you never need to hit the database again to rehydrate the cache if it hasn't changed, which will save resources.</p>
</blockquote>

<p>So if the order gets updated, you should delete the cache manually:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">CachedOrdersService</span> : <span class="pl-k">Service</span>
{
    <span class="pl-k">public</span> <span class="pl-k">object</span> <span class="pl-en">Put</span>(<span class="pl-k">CachedOrders</span> <span class="pl-smi">request</span>)
    {
        <span class="pl-c">//The order gets updated...</span>
        <span class="pl-k">var</span> cacheKey = <span class="pl-s"><span class="pl-pds">"</span>some_unique_key_for_order<span class="pl-pds">"</span></span>;
        <span class="pl-k">return</span> <span class="pl-c1">base</span>.Request.RemoveFromCache(<span class="pl-c1">base</span>.Cache, cacheKey);
    }
}</pre></div>

<p>If now the client calls the webservice to request the order, he'll get the latest version.</p>

<h3>
<a id="user-content-local-memorycacheclient" class="anchor" href="#local-memorycacheclient" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Local MemoryCacheClient</h3>

<p>As it sometimes beneficial to have access to a local in-memory Cache in addition to your registered <code>ICacheClient</code> 
<a href="https://github.com/ServiceStack/ServiceStack/wiki/Caching">Caching Provider</a>
we also pre-register a <code>MemoryCacheClient</code> that all your Services now have access to from the <code>LocalCache</code> 
property, i.e:</p>

<div class="highlight highlight-source-cs"><pre>    MemoryCacheClient LocalCache { <span class="pl-k">get</span>; }</pre></div>

<p>This doesn't affect any existing functionality that utilizes a cache like Sessions which continue to use
your registered <code>ICacheClient</code>, but it does let you change which cache you want different responses to use, e.g: </p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> cacheKey = <span class="pl-s"><span class="pl-pds">"</span>unique_key_for_this_request<span class="pl-pds">"</span></span>;
<span class="pl-k">return</span> <span class="pl-c1">base</span>.Request.ToOptimizedResultUsingCache(LocalCache, cacheKey, () =&gt; {
    <span class="pl-c">//Delegate is executed if item doesn't exist in cache </span>
});</pre></div>

<p>If you don't register a <code>ICacheClient</code> ServiceStack automatically registers a <code>MemoryCacheClient</code> for you 
which will also refer to the same instance registered for <code>LocalCache</code>.</p>

<h2>
<a id="user-content-icacheclientextended" class="anchor" href="#icacheclientextended" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack.Interfaces/Caching/ICacheClientExtended.cs">ICacheClientExtended</a>
</h2>

<p>The <a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack.Interfaces/Caching/ICacheClientExtended.cs">ICacheClientExtended</a>
API is used to to provide additional non-core functionality to our most popular 
<a href="https://github.com/ServiceStack/ServiceStack/wiki/Caching">Caching providers</a>:</p>

<ul>
<li>Redis</li>
<li>OrmLite RDBMS</li>
<li>In Memory</li>
<li>AWS</li>
</ul>

<p>The new API's are added as Extension methods on <code>ICacheClient</code> so they're easily accessible without casting, the new API's available include: </p>

<ul>
<li>GetKeysByPattern(pattern) - return keys matching a wildcard pattern</li>
<li>GetAllKeys() - return all keys in the caching provider</li>
<li>GetKeysStartingWith() - Streaming API to return all keys Starting with a prefix</li>
</ul>

<p>With these new API's you can now easily get all active User Sessions using any of the supported Caching providers above with:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> sessionPattern = IdUtils.CreateUrn&lt;IAuthSession&gt;(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>); <span class="pl-c">//= urn:iauthsession:</span>
<span class="pl-k">var</span> sessionKeys = Cache.GetKeysStartingWith(sessionPattern).ToList();

<span class="pl-k">var</span> allSessions = Cache.GetAll&lt;IAuthSession&gt;(sessionKeys);</pre></div>

<h2>
<a id="user-content-live-example-and-code" class="anchor" href="#live-example-and-code" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Live Example and code</h2>

<p>A live demo of the ICacheClient is available in <a href="http://northwind.servicestack.net/">The ServiceStack.Northwind's example project</a>. Here are some requests to cached services:</p>

<ul>
<li><a href="http://northwind.servicestack.net/cached/customers">/customers</a></li>
<li><a href="http://northwind.servicestack.net/cached/customers/ALFKI">/customers/ALFKI</a></li>
<li><a href="http://northwind.servicestack.net/cached/customers/ALFKI/orders">/customers/ALFKI/orders</a></li>
</ul>

<p>Which are simply existing web services wrapped using <strong>ICacheClient</strong> that are contained in <a href="https://github.com/ServiceStack/ServiceStack.Examples/blob/master/src/ServiceStack.Northwind/ServiceStack.Northwind.ServiceInterface/CachedServices.cs">CachedServices.cs</a></p>
