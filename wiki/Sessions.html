<p>The <code>AuthFeature</code> (plugin) already enables the SessionFeature, but if you want to make use of sessions and don't want to enable the built-in <a href="https://github.com/ServiceStack/ServiceStack/wiki/Authentication-and-authorization">Authentication</a>, you will need to register it manually in your AppHost with:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-k">void</span> Configure(Container container)
{
    Plugins.Add(<span class="pl-k">new</span> SessionFeature());
}</pre></div>

<h3>
<a id="user-content-cookie-session-ids" class="anchor" href="#cookie-session-ids" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Cookie Session Ids</h3>

<p>When the <code>SessionFeature</code> is enabled, a <a href="https://github.com/ServiceStack/ServiceStack/wiki/Request-and-response-filters">Global RequestFilter</a> is added to ServiceStack to ensure that all requests have a Temporary <code>ss-id</code> and a Permanent <code>ss-pid</code> session cookies set. These Session Cookies contain a unique Random Base64-encoded Id. The <code>ss-opt</code> cookie stores the users preference on whether they want their current session to be temporary (<code>ss-opt=temp</code>) or permanent (<code>ss-opt=perm</code>) - i.e. to <strong>RememberMe</strong> or not - The Default is Temporary. </p>

<h3>
<a id="user-content-permanent-and-temporary-session-ids" class="anchor" href="#permanent-and-temporary-session-ids" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Permanent and Temporary Session Ids</h3>

<p>The Permanent session cookie <code>ss-pid</code> is always created even if <code>ss-opt</code> is Temporary - this allows you to link and track subsequent requests together which can be helpful for user request analyzing. In contrast the temporary Session Id <code>ss-id</code> uses a temporary cookie that does not persist across a users browser sessions.</p>

<p>If you're interested in the implementation, all the source code for ServiceStack's Sessions are kept in the <a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack.Interfaces/Caching/ISession.cs">ISession</a>, <a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack/SessionFeature.cs">SessionFeature</a>, <a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack/SessionFactory.cs">SessionFactory</a>, <a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack/SessionExtensions.cs">SessionExtensions</a> and <a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack/ServiceExtensions.cs">ServiceExtensions</a> classes.</p>

<h2>
<a id="user-content-can-be-used-with-any-icacheclient" class="anchor" href="#can-be-used-with-any-icacheclient" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Can be used with any <a href="https://github.com/ServiceStack/ServiceStack/wiki/Caching">ICacheClient</a>
</h2>

<p>ServiceStack's implementation of Sessions are clean, in that they work with all of <a href="https://github.com/ServiceStack/ServiceStack/wiki/Caching">ServiceStack's Caching Providers</a> and are simply pointers to POCOs in your Cache. An example of getting ServiceStack to use an in-memory cache:</p>

<pre><code>container.Register&lt;ICacheClient&gt;(new MemoryCacheClient());
</code></pre>

<h3>
<a id="user-content-formatting-of-keys-used-in-cache-providers" class="anchor" href="#formatting-of-keys-used-in-cache-providers" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Formatting of Keys used in Cache Providers</h3>

<p>For typed or Custom AuthSession the <a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack.ServiceInterface/SessionFeature.cs#L64">key is</a>: </p>

<pre><code>urn:iauthsession:{sessionId}
</code></pre>

<p>When using un-typed <a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack.ServiceInterface/SessionFactory.cs#L27">Session Bag</a> the key is:</p>

<pre><code>sess:{sessionId}:{key}
</code></pre>

<p>The general recommendation is to use typed sessions, which will give you type-safety benefits as well as being able to fetch your entire users session with a single cache call. If you use the dynamic/session bag then it will be a network call for each key accessed - although as caches are designed for fast-access, this isn't too much of a concern.</p>

<h2>
<a id="user-content-using-typed-sessions-in-servicestack" class="anchor" href="#using-typed-sessions-in-servicestack" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Using Typed Sessions in ServiceStack</h2>

<p>An example of using Typed Sessions is in the <a href="https://github.com/ServiceStack/SocialBootstrapApi">Social Bootstrap Api</a> demo where a <a href="https://github.com/ServiceStack/SocialBootstrapApi/blob/master/src/SocialBootstrapApi/Models/CustomUserSession.cs">CustomUserSession</a> is defined as:</p>

<div class="highlight highlight-source-cs"><pre>[DataContract]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">CustomUserSession</span> : <span class="pl-k">AuthUserSession</span> 
{
    [DataMember]
    <span class="pl-k">public</span> <span class="pl-k">string</span> <span class="pl-en">CustomId</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}</pre></div>

<p>By inheriting <a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack/AuthUserSession.cs">AuthUserSession</a> you're able to keep all the users session together in 1 POCO, which allows you to access everything in 1 cache read or write.</p>

<blockquote>
<p>When inheriting from <code>AuthUserSession</code> you will need to annotate your properties with <code>[DataMember]</code> as AuthUserSession is a DataContract class.</p>
</blockquote>

<p>To tell ServiceStack to use your Custom Typed Session instead, register it in the <code>AuthFeature</code> plugin:</p>

<div class="highlight highlight-source-cs"><pre>Plugins.Add(<span class="pl-k">new</span> AuthFeature(() =&gt; <span class="pl-k">new</span> CustomUserSession(), ...));</pre></div>

<h2>
<a id="user-content-session-events" class="anchor" href="#session-events" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Session events</h2>

<p>Inheriting from the AuthUserSession also lets you add custom logic for different events in the User Session life-cycle:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">virtual</span> <span class="pl-k">void</span> OnCreated(IRequest httpReq) {}
<span class="pl-k">virtual</span> <span class="pl-k">void</span> OnRegistered(IServiceBase registrationService) {}
<span class="pl-k">virtual</span> <span class="pl-k">void</span> OnAuthenticated(IServiceBase authService, IAuthSession session, 
    IAuthTokens tokens, Dictionary&lt;<span class="pl-k">string</span>, <span class="pl-k">string</span>&gt; authInfo) {}
<span class="pl-k">virtual</span> <span class="pl-k">void</span> OnLogout(IServiceBase authService) {}</pre></div>

<h3>
<a id="user-content-auth-events" class="anchor" href="#auth-events" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Auth Events</h3>

<p>The same authentication hooks that are available in the Custom UserSession above are also available in <code>IAuthEvents</code> API: </p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">interface</span> <span class="pl-en">IAuthEvents</span>
{
    <span class="pl-k">void</span> <span class="pl-en">OnRegistered</span>(<span class="pl-k">IRequest</span> <span class="pl-smi">req</span>, <span class="pl-k">IAuthSession</span> <span class="pl-smi">session</span>, <span class="pl-k">IServiceBase</span> <span class="pl-smi">registerService</span>);
    <span class="pl-k">void</span> <span class="pl-en">OnAuthenticated</span>(<span class="pl-k">IRequest</span> <span class="pl-smi">req</span>, <span class="pl-k">IAuthSession</span> <span class="pl-smi">session</span>, <span class="pl-k">IServiceBase</span> <span class="pl-smi">authService</span>, 
        <span class="pl-k">IAuthTokens</span> <span class="pl-smi">tokens</span>, Dictionary&lt;string, string&gt; authInfo);
    <span class="pl-k">void</span> <span class="pl-en">OnLogout</span>(<span class="pl-k">IRequest</span> <span class="pl-smi">req</span>, <span class="pl-k">IAuthSession</span> <span class="pl-smi">session</span>, <span class="pl-k">IServiceBase</span> <span class="pl-smi">authService</span>);
    <span class="pl-k">void</span> <span class="pl-en">OnCreated</span>(<span class="pl-k">IRequest</span> <span class="pl-smi">req</span>, <span class="pl-k">IAuthSession</span> <span class="pl-smi">session</span>);
}</pre></div>

<p>The new AuthEvents API provide a loose-typed way where plugins can tap into the same hooks by registering it with <code>AuthFeature.AuthEvents</code>, e.g:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">WebSudoFeature</span> : <span class="pl-k">IPlugin</span>, <span class="pl-k">IAuthEvents</span>
{
    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Register</span>(<span class="pl-k">IAppHost</span> <span class="pl-smi">appHost</span>)
    {
        ...
        <span class="pl-k">var</span> authFeature = appHost.GetPlugin&lt;AuthFeature&gt;();
        authFeature.AuthEvents.Add(<span class="pl-c1">this</span>);
    }

    <span class="pl-c">// Add implementations of all `IAuthEvents` handlers</span>
    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">OnCreated</span>(<span class="pl-k">IRequest</span> <span class="pl-smi">httpReq</span>, <span class="pl-k">IAuthSession</span> <span class="pl-smi">session</span>) { ... }
}</pre></div>

<p>An alternative way for accessing <code>IAuthEvents</code> is to register it like a normal dependency, e.g:</p>

<div class="highlight highlight-source-cs"><pre>container.RegisterAs&lt;LogAuthEvents,IAuthEvents&gt;();</pre></div>

<p>To simplify custom implementations you can inherit from the empty concrete <a href="https://github.com/ServiceStack/ServiceStack/blob/7eb3a34a2e545a54c2591665328c16c5d398d37a/src/ServiceStack/Auth/AuthEvents.cs#L18-L25">AuthEvents</a> and choose to only implement the callbacks you're interested in, e.g:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">LogAuthEvents</span> : <span class="pl-k">AuthEvents</span>
{
    <span class="pl-k">public</span> <span class="pl-k">static</span> ILog Log = LogManager.GetLogger(<span class="pl-k">typeof</span>(LogAuthEvents));

    <span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-k">void</span> <span class="pl-en">OnLogout</span>(<span class="pl-k">IRequest</span> <span class="pl-smi">httpReq</span>, <span class="pl-k">IAuthSession</span> <span class="pl-smi">session</span>, <span class="pl-k">IServiceBase</span> <span class="pl-smi">authService</span>) 
    {
        Log.DebugFormat(<span class="pl-s"><span class="pl-pds">"</span>User #{0} {1} has logged out<span class="pl-pds">"</span></span>, session.UserAuthId, session.UserName);
    }
}</pre></div>

<h3>
<a id="user-content-accessing-typed-session" class="anchor" href="#accessing-typed-session" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Accessing Typed Session</h3>

<p>You can access your custom UserAuth session inside your service using the <code>SesssionAs&lt;T&gt;()</code> extension method, e.g:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">abstract</span> <span class="pl-k">class</span> <span class="pl-en">MyService</span> : <span class="pl-k">Service</span> 
{
    <span class="pl-k">public</span> <span class="pl-k">object</span> <span class="pl-en">Get</span>(<span class="pl-k">MyRequest</span> <span class="pl-smi">request</span>)
    {
        <span class="pl-k">var</span> typedSession = <span class="pl-c1">this</span>.SessionAs&lt;CustomUserSession&gt;();
    }
}</pre></div>

<h3>
<a id="user-content-adding-a-convenience-wrapper" class="anchor" href="#adding-a-convenience-wrapper" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Adding a Convenience wrapper</h3>

<p>To provide a typed, Convenient API for your service you can add the following to a base class, here's SocialBootstrapApi's <a href="https://github.com/ServiceStack/SocialBootstrapApi/blob/master/src/SocialBootstrapApi/ServiceInterface/AppServiceBase.cs">AppServiceBase</a> example:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">abstract</span> <span class="pl-k">class</span> <span class="pl-en">AppServiceBase</span> : <span class="pl-k">Service</span> {
    <span class="pl-k">private</span> CustomUserSession userSession;
    <span class="pl-k">protected</span> CustomUserSession <span class="pl-en">UserSession</span> {
        <span class="pl-k">get</span> {
            <span class="pl-k">return</span> <span class="pl-c1">base</span>.SessionAs&lt;CustomUserSession&gt;();
        }
    }
}</pre></div>

<p>This will then enable you to access your users Session in your ServiceStack services with <code>base.UserSession</code>.</p>

<h2>
<a id="user-content-sharing-servicestacks-typed-sessions-in-mvc-and-aspnet" class="anchor" href="#sharing-servicestacks-typed-sessions-in-mvc-and-aspnet" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Sharing ServiceStack's Typed Sessions in MVC and ASP.NET</h2>

<p>ASP.NET's Session Provider model still maintains its old legacy .NET 1.0 roots with it's heavy XML-encumbered config model, it's coupled and un-testable API, and its <a href="http://stackoverflow.com/questions/3629709/i-just-discovered-why-all-asp-net-websites-are-slow-and-i-am-trying-to-work-out">degrading performance limitations by design</a> makes it difficult for any web service framework to share the same User Sessions with the base ASP.NET Web Forms or MVC web host. </p>

<p>ServiceStack gets around these limitations by providing its own de-coupled, testable and dependency-free <a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack.Interfaces/Caching/ICacheClient.cs">ICacheClient</a> and <a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack.Interfaces/Caching/ISession.cs">ISession</a> APIs - which all work simply together as they're just plain Guid Session Keys stored in Caches pointing to POCOs.</p>

<p>The method SessionFeature.GetSessionKey allows you to get a Session Key for a current request if you are trying to access it in ASP.NET Web Forms or MVC web host. Using a Session Key you can have a full control over Session object:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">// CacheClient is instance of ICacheClient</span>

<span class="pl-k">var</span> sessionKey = SessionFeature.GetSessionKey();

<span class="pl-c">// geting an existing User Session or create a new one </span>
<span class="pl-k">var</span> userSession = SessionFeature.GetOrCreateSession&lt;AuthUserSession&gt;(CacheClient); 
<span class="pl-c">// or SessionFeature.GetOrCreateSession&lt;CustomUserSession&gt;(CacheClient); </span>

<span class="pl-c">// modifying User Session</span>
userSession.UserAuthId = model.UserName;

<span class="pl-c">// saving User Session</span>
CacheClient.CacheSet(sessionKey , userSession);</pre></div>

<h3>
<a id="user-content-saving-in-service" class="anchor" href="#saving-in-service" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Saving in Service</h3>

<p>As a typed session is just a disconnected POCO, it needs to explicitly saved to be persisted - which you can do with the <a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack/ServiceExtensions.cs#L68">base.SaveSession()</a> Extension method.</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">object</span> Any(Request request)
{
    <span class="pl-k">var</span> session = <span class="pl-c1">base</span>.SessionAs&lt;AuthUserSession&gt;();

    <span class="pl-c">// modify session</span>

    <span class="pl-c1">base</span>.Request.SaveSession(session);
}</pre></div>

<h3>
<a id="user-content-saving-outside-a-service" class="anchor" href="#saving-outside-a-service" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Saving outside a Service</h3>

<p>If your logic is outside a ServiceStack service you can save your typed session by getting access to the ServiceStack <code>IRequest</code> which you can create from ASP.NET Request objects:</p>

<div class="highlight highlight-source-cs"><pre>IHttpRequest httpReq = aspCtx.ToRequest(); <span class="pl-c">//HttpContext</span>
IHttpRequest httpReq = aspReq.ToRequest(); <span class="pl-c">//MVC HttpRequestBase</span>
IHttpRequest httpReq = listenerCtx.ToRequest(); <span class="pl-c">//HttpListenerContext</span>

<span class="pl-c">//In ASP.NET hosts via the singleton</span>
IHttpRequest httpReq = HostContext.AppHost.TryGetCurrentRequest(); </pre></div>

<p>Once you have access to the current <code>IRequest</code> you can save your typed session using the <code>SaveSession()</code> extension method:</p>

<div class="highlight highlight-source-cs"><pre>httpReq.SaveSession(session);</pre></div>

<p>This API is also available in MVC Controllers that inherit <code>ServiceStackController</code> or ASP.NET Pages that inherit <code>ServiceStackPage</code>:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-c1">base</span>.SaveSession(session);</pre></div>

<h3>
<a id="user-content-typed-sessions-in-mvc" class="anchor" href="#typed-sessions-in-mvc" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Typed Sessions in MVC</h3>

<p>To make use of it in MVC, you effectively do the same thing, although this time you can simply inherit the existing <a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack.Mvc/ServiceStackController.cs">ServiceStackController</a> which has the above templated code in a generic MVC Controller Template:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">ControllerBase</span> : <span class="pl-k">ServiceStackController</span>&lt;<span class="pl-k">CustomUserSession</span>&gt; {}</pre></div>

<p>From there it's just a basic property which you can use in your Controller or assign to your views <a href="https://github.com/ServiceStack/SocialBootstrapApi/blob/master/src/SocialBootstrapApi/Controllers/HomeController.cs#L12">like this</a>:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">partial</span> <span class="pl-k">class</span> <span class="pl-en">HomeController</span> : <span class="pl-k">ControllerBase</span> 
{
    <span class="pl-k">public</span> <span class="pl-k">virtual</span> ActionResult <span class="pl-en">Index</span>() 
    {
        ViewBag.Message = <span class="pl-s"><span class="pl-pds">"</span>MVC + ServiceStack PowerPack!<span class="pl-pds">"</span></span>;
        ViewBag.UserSession = <span class="pl-c1">base</span>.UserSession;
        <span class="pl-k">return</span> View();
    }   
}</pre></div>

<h3>
<a id="user-content-typed-sessions-in-aspnet-web-forms" class="anchor" href="#typed-sessions-in-aspnet-web-forms" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Typed Sessions in ASP.NET Web Forms</h3>

<p>It's the same thing in ASP.NET Web Forms although this comes in the form of a <a href="https://github.com/ServiceStack/ServiceStack/blob/master/NuGet/ServiceStack.Host.AspNet/content/App_Start/PageBase.cs.pp">base ASP.NET Web Page</a> which you get for free when you install ServiceStack via the <a href="http://nuget.org/packages/ServiceStack.Host.AspNet">ServiceStack.Host.AspNet</a> NuGet package.</p>

<h2>
<a id="user-content-using-dynamic--untyped-sessions-in-servicestack" class="anchor" href="#using-dynamic--untyped-sessions-in-servicestack" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Using Dynamic / Untyped Sessions in ServiceStack</h2>

<p>You can access the dynamic UserSession Bag in ServiceStack services via the <code>base.Session</code> property already built-in ServiceStack's <a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack/Service.cs">ServiceBase</a> base class, e.g:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-c1">base</span>.SessionBag[<span class="pl-s"><span class="pl-pds">"</span>cart<span class="pl-pds">"</span></span>] = <span class="pl-k">new</span> Cart { ... };
<span class="pl-k">var</span> cart = <span class="pl-c1">base</span>.SessionBag.Get&lt;Cart&gt;(<span class="pl-s"><span class="pl-pds">"</span>cart<span class="pl-pds">"</span></span>);</pre></div>

<h2>
<a id="user-content-use-http-headers-to-send-session-cookies" class="anchor" href="#use-http-headers-to-send-session-cookies" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Use HTTP Headers to Send Session Cookies</h2>

<p>You can now make a Session-enabled request with HTTP Headers instead of Cookies. The Session HTTP Headers have a <code>X-</code> prefix before the Session Id, i.e: <code>X-ss-id</code>, <code>X-ss-pid</code> and <code>X-ss-opts</code>.</p>

<h2>
<a id="user-content-inspecting-persisted-user-sessions" class="anchor" href="#inspecting-persisted-user-sessions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Inspecting persisted User Sessions</h2>

<p>ServiceStack Sessions are just serialized POCO's stored in the Registered <code>ICacheClient</code> at the following key:</p>

<pre><code>urn:iauthsession:{SessionId}
</code></pre>

<p>Where <code>{SessionId}</code> is either the users <code>ss-id</code> or <code>ss-pid</code> cookie depending on whether the user was authenticated with <code>RememberMe=true</code> which instructs ServiceStack to save the session against the <code>ss-pid</code> permanent cookie - this preference is stored in the <code>ss-opt=perm</code> cookie.</p>

<p>Since they're just plain POCO's stored at a predictable key format, we can easily iterate through all user sessions by using the <code>ICacheClient</code> API's directly, e.g:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> sessionPattern = IdUtils.CreateUrn&lt;IAuthSession&gt;(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>); <span class="pl-c">//= urn:iauthsession:</span>
<span class="pl-k">var</span> sessionKeys = Cache.GetKeysStartingWith(sessionPattern).ToList();

<span class="pl-k">var</span> allSessions = Cache.GetAll&lt;IAuthSession&gt;(sessionKeys);</pre></div>

<h1>
<a id="user-content-community-resources" class="anchor" href="#community-resources" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Community Resources</h1>

<ul>
<li>
<a href="http://teadriven.me.uk/2013/02/14/sliding-sessions-in-service-stack/">Sliding session expirations in ServiceStack</a> by <a href="https://twitter.com/teadriven">@teadriven</a>
</li>
<li>
<a href="http://www.richardfawcett.net/2012/02/29/accessing-asp-net-session-from-servicestack/">Accessing ASP.NET Session from ServiceStack</a> by <a href="https://twitter.com/yeurch">@yeurch</a>
</li>
<li>
<a href="http://openlandscape.net/2011/03/21/rest-web-services-with-servicestack/">REST Web Services with ServiceStack</a> by <a href="http://openlandscape.net/about/">Jacques du Preez</a>
</li>
</ul>
